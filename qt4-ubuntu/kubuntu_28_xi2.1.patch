--- a/config.tests/x11/xinput2/xinput2.cpp
+++ b/config.tests/x11/xinput2/xinput2.cpp
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the config.tests of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xge.h>
+
+#if XI_2_Major < 2 || XI_2_Minor < 2
+#  error "Missing XInput 2.2 or later"
+#endif
+
+int main(int, char **)
+{
+    // need XGenericEventCookie for XInput2 to work
+    Display *dpy = 0;
+    XEvent xevent;
+    if (XGetEventData(dpy, &xevent.xcookie)) {
+        XFreeEventData(dpy, &xevent.xcookie);
+    }
+
+    XIEvent *xievent;
+    xievent = 0;
+
+    XIDeviceEvent *xideviceevent;
+    xideviceevent = 0;
+
+    XIHierarchyEvent *xihierarchyevent;
+    xihierarchyevent = 0;
+
+    int deviceid = 0;
+    int len = 0;
+    Atom *atoms = XIListProperties(dpy, deviceid, &len);
+    if (atoms)
+        XFree(atoms);
+
+    return 0;
+}
--- a/config.tests/x11/xinput2/xinput2.pro
+++ b/config.tests/x11/xinput2/xinput2.pro
@@ -0,0 +1,4 @@
+CONFIG += x11
+CONFIG -= qt
+LIBS += -lXi
+SOURCES = xinput2.cpp
--- a/configure
+++ b/configure
@@ -834,6 +834,7 @@
 CFG_DECORATION_ON="${CFG_DECORATION_AVAILABLE}" # all on by default
 CFG_DECORATION_PLUGIN_AVAILABLE=
 CFG_DECORATION_PLUGIN=
+CFG_XINPUT2=auto
 CFG_XINPUT=runtime
 CFG_XKB=auto
 CFG_NIS=auto
@@ -1143,7 +1144,7 @@
         VAL=no
         ;;
     #Qt style yes options
-    -incremental|-qvfb|-profile|-shared|-static|-sm|-xinerama|-xshape|-xsync|-xinput|-egl|-reduce-exports|-pch|-separate-debug-info|-stl|-freetype|-xcursor|-xfixes|-xrandr|-xrender|-mitshm|-fontconfig|-xkb|-nis|-qdbus|-dbus|-dbus-linked|-glib|-gstreamer|-gtkstyle|-cups|-iconv|-largefile|-h|-help|-v|-verbose|-debug|-release|-fast|-accessibility|-confirm-license|-gnumake|-framework|-qt3support|-debug-and-release|-exceptions|-cocoa|-carbon|-universal|-harfbuzz|-prefix-install|-silent|-armfpa|-optimized-qmake|-dwarf2|-reduce-relocations|-sse|-openssl|-openssl-linked|-ptmalloc|-xmlpatterns|-phonon|-phonon-backend|-multimedia|-audio-backend|-svg|-declarative|-declarative-debug|-javascript-jit|-script|-scripttools|-rpath|-force-pkg-config|-s60|-usedeffiles|-icu)
+    -incremental|-qvfb|-profile|-shared|-static|-sm|-xinerama|-xshape|-xsync|-xinput|-xinput2|-egl|-reduce-exports|-pch|-separate-debug-info|-stl|-freetype|-xcursor|-xfixes|-xrandr|-xrender|-mitshm|-fontconfig|-xkb|-nis|-qdbus|-dbus|-dbus-linked|-glib|-gstreamer|-gtkstyle|-cups|-iconv|-largefile|-h|-help|-v|-verbose|-debug|-release|-fast|-accessibility|-confirm-license|-gnumake|-framework|-qt3support|-debug-and-release|-exceptions|-cocoa|-carbon|-universal|-harfbuzz|-prefix-install|-silent|-armfpa|-optimized-qmake|-dwarf2|-reduce-relocations|-sse|-openssl|-openssl-linked|-ptmalloc|-xmlpatterns|-phonon|-phonon-backend|-multimedia|-audio-backend|-svg|-declarative|-declarative-debug|-javascript-jit|-script|-scripttools|-rpath|-force-pkg-config|-s60|-usedeffiles|-icu)
         VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
         VAL=yes
         ;;
@@ -1834,6 +1835,13 @@
             UNKNOWN_OPT=yes
         fi
         ;;
+     xinput2)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XINPUT2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
     xinput)
         if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
             CFG_XINPUT="$VAL"
@@ -4251,6 +4259,13 @@
         XMY="*"
         XMN=" "
     fi
+    if [ "$CFG_XINPUT2" = "no" ]; then
+        X2Y=" "
+        X2N="*"
+    else
+        X2Y="*"
+        X2N=" "
+    fi
     if [ "$CFG_XINPUT" = "no" ]; then
         XIY=" "
         XIN="*"
@@ -4355,7 +4370,10 @@
                          Requires fontconfig/fontconfig.h, libfontconfig,
                          freetype.h and libfreetype.
 
- $XIN  -no-xinput ......... Do not compile Xinput support.
+ $X2N  -no-xinput2......... Do not compile XInput2 support.
+ $X2Y  -xinput2............ Compile XInput2 support.
+
+ $XIN  -no-xinput.......... Do not compile Xinput support.
  $XIY  -xinput ............ Compile Xinput support. This also enabled tablet support
                          which requires IRIX with wacom.h and libXi or
                          XFree86 with X11/extensions/XInput.h and libXi.
@@ -6326,7 +6344,22 @@
 	fi
     fi
 
-    # auto-detect Xinput support
+    # auto-detect XInput2/Xinput support
+    if [ "$CFG_XINPUT2" != "no" ]; then
+        if "$unixtests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/x11/xinput2 "XInput2" $L_FLAGS $I_FLAGS $l_FLAGS $X11TESTS_FLAGS; then
+	    CFG_XINPUT2=yes
+        else
+            if [ "$CFG_XINPUT2" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "XInput2 support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_XINPUT2=no
+            fi
+        fi
+    fi
     if [ "$CFG_XINPUT" != "no" ]; then
         if compileTest x11/xinput "XInput" $X11TESTS_FLAGS; then
 	    if [ "$CFG_XINPUT" != "runtime" ]; then
@@ -7548,9 +7581,12 @@
     if [ "$CFG_FONTCONFIG" = "yes" ]; then
         QT_CONFIG="$QT_CONFIG fontconfig"
     fi
-    if [ "$CFG_XINPUT" = "yes" ]; then
+    if [ "$CFG_XINPUT2" = "yes" -o "$CFG_XINPUT" = "yes" ]; then
 	QMakeVar set QMAKE_LIBS_X11 '-lXi $$QMAKE_LIBS_X11'
     fi
+    if [ "$CFG_XINPUT2" = "yes" ]; then
+	QT_CONFIG="$QT_CONFIG xinput2"
+    fi
     if [ "$CFG_XINPUT" = "yes" ]; then
         QT_CONFIG="$QT_CONFIG xinput tablet"
     fi
@@ -8469,6 +8505,7 @@
     [ "$CFG_XVIDEO" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XVIDEO"
     [ "$CFG_XSYNC" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XSYNC"
     [ "$CFG_XINPUT" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINPUT QT_NO_TABLET"
+    [ "$CFG_XINPUT2" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINPUT2"
 
     [ "$CFG_XCURSOR" = "runtime" ]   && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XCURSOR"
     [ "$CFG_XINERAMA" = "runtime" ]  && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XINERAMA"
@@ -9042,6 +9079,7 @@
     echo "Xfixes support ......... $CFG_XFIXES"
     echo "Xrandr support ......... $CFG_XRANDR"
     echo "Xrender support ........ $CFG_XRENDER"
+    echo "XInput2 support ........ $CFG_XINPUT2"
     echo "Xi support ............. $CFG_XINPUT"
     echo "MIT-SHM support ........ $CFG_MITSHM"
     echo "FontConfig support ..... $CFG_FONTCONFIG"
--- a/configure.orig
+++ b/configure.orig
@@ -0,0 +1,9424 @@
+#!/bin/sh
+#############################################################################
+##
+## Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+## Contact: http://www.qt-project.org/legal
+##
+## This file is the build configuration utility of the Qt Toolkit.
+##
+## $QT_BEGIN_LICENSE:LGPL$
+## Commercial License Usage
+## Licensees holding valid commercial Qt licenses may use this file in
+## accordance with the commercial license agreement provided with the
+## Software or, alternatively, in accordance with the terms contained in
+## a written agreement between you and Digia.  For licensing terms and
+## conditions see http://qt.digia.com/licensing.  For further information
+## use the contact form at http://qt.digia.com/contact-us.
+##
+## GNU Lesser General Public License Usage
+## Alternatively, this file may be used under the terms of the GNU Lesser
+## General Public License version 2.1 as published by the Free Software
+## Foundation and appearing in the file LICENSE.LGPL included in the
+## packaging of this file.  Please review the following information to
+## ensure the GNU Lesser General Public License version 2.1 requirements
+## will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+##
+## In addition, as a special exception, Digia gives you certain additional
+## rights.  These rights are described in the Digia Qt LGPL Exception
+## version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+##
+## GNU General Public License Usage
+## Alternatively, this file may be used under the terms of the GNU
+## General Public License version 3.0 as published by the Free Software
+## Foundation and appearing in the file LICENSE.GPL included in the
+## packaging of this file.  Please review the following information to
+## ensure the GNU General Public License version 3.0 requirements will be
+## met: http://www.gnu.org/copyleft/gpl.html.
+##
+##
+## $QT_END_LICENSE$
+##
+#############################################################################
+
+#-------------------------------------------------------------------------------
+# script initialization
+#-------------------------------------------------------------------------------
+
+# the name of this script
+relconf=`basename $0`
+# the directory of this script is the "source tree"
+relpath=`dirname $0`
+relpath=`(cd "$relpath"; /bin/pwd)`
+# the current directory is the "build tree" or "object tree"
+outpath=`/bin/pwd`
+
+#license file location
+LICENSE_FILE="$QT_LICENSE_FILE"
+[ -z "$LICENSE_FILE" ] && LICENSE_FILE="$HOME/.qt-license"
+if [ -f "$LICENSE_FILE" ]; then
+    tr -d '\r' <"$LICENSE_FILE" >"${LICENSE_FILE}.tmp"
+    diff "${LICENSE_FILE}.tmp" "${LICENSE_FILE}" >/dev/null 2>&1 || LICENSE_FILE="${LICENSE_FILE}.tmp"
+fi
+
+# later cache the command line in config.status
+OPT_CMDLINE=`echo $@ | sed "s,-v ,,g; s,-v$,,g"`
+
+# initialize global variables
+QMAKE_SWITCHES=
+QMAKE_VARS=
+QMAKE_CONFIG=
+QTCONFIG_CONFIG=
+QT_CONFIG=
+SUPPORTED=
+QMAKE_VARS_FILE=.qmake.vars
+DEVICE_VARS_FILE=.device.vars
+
+:> "$QMAKE_VARS_FILE"
+:> "$DEVICE_VARS_FILE"
+
+#-------------------------------------------------------------------------------
+# utility functions
+#-------------------------------------------------------------------------------
+
+shellEscape()
+{
+    echo "$@" | sed 's/ /\ /g'
+}
+
+# Adds a new qmake variable to the cache
+# Usage: QMakeVar mode varname contents
+#   where mode is one of: set, add, del
+QMakeVar()
+{
+    case "$1" in
+	set)
+	    eq="="
+	    ;;
+	add)
+	    eq="+="
+	    ;;
+	del)
+	    eq="-="
+	    ;;
+	*)
+	    echo >&2 "BUG: wrong command to QMakeVar: $1"
+	    ;;
+    esac
+
+    echo "$2" "$eq" "$3" >> "$QMAKE_VARS_FILE"
+}
+
+# Helper function for getQMakeConf. It parses include statements in
+# qmake.conf and prints out the expanded file
+getQMakeConf1()
+{
+    while read line; do case "$line" in
+        include*)
+	    inc_file=`echo "$line" | sed -n -e "/^include.*(.*)/s/include.*(\(.*\)).*$/\1/p"`
+	    current_dir=`dirname "$1"`
+	    conf_file="$current_dir/$inc_file"
+	    if [ ! -f  "$conf_file" ]; then
+                echo "WARNING: Unable to find file $conf_file" >&2
+                continue
+            fi
+            getQMakeConf1 "$conf_file"
+        ;;
+        *)
+            echo "$line"
+        ;;
+    esac; done < "$1"
+}
+
+getQMakeConf2()
+{
+    $AWK '
+BEGIN {
+    values["LITERAL_WHITESPACE"] = " "
+    values["LITERAL_DOLLAR"] = "$"
+}
+/^[_A-Z0-9.]+[ \t]*\+?=/ {
+    valStart = index($0, "=") + 1
+
+    append = 0
+    if (substr($0, valStart - 2, 1) == "+") {
+        append = 1
+    }
+
+    variable = substr($0, 0, valStart - 2 - append)
+    value = substr($0, valStart)
+    gsub("[ \t]+", "", variable)
+    gsub("^[ \t]+", "", value)
+    gsub("[ \t]+$", "", value)
+
+    ovalue = ""
+    while (match(value, /\$\$(\{[_A-Z0-9.]+\}|[_A-Z0-9.]+)/)) {
+        ovalue = ovalue substr(value, 1, RSTART - 1)
+        var = substr(value, RSTART + 2, RLENGTH - 2)
+        value = substr(value, RSTART + RLENGTH)
+        if (var ~ /^\{/) {
+            var = substr(var, 2, length(var) - 2)
+        }
+        ovalue = ovalue values[var]
+    }
+    ovalue = ovalue value
+
+    combinedValue = values[variable]
+    if (append == 1 && length(combinedValue) > 0) {
+        combinedValue = combinedValue " " ovalue
+    } else {
+        combinedValue = ovalue
+    }
+    values[variable] = combinedValue
+}
+END {
+    for (var in values) {
+        print var "=" values[var]
+    }
+}
+'
+}
+
+getQMakeConf3()
+{
+    echo "$2" | $AWK "/^($1)=/ { print substr(\$0, index(\$0, \"=\") + 1) }"
+}
+
+# relies on $QMAKESPEC being set correctly. parses include statements in
+# qmake.conf and prints out the expanded file
+getQMakeConf()
+{
+    if [ -z "$specvals" ]; then
+        specvals=`getQMakeConf1 "$QMAKESPEC/qmake.conf" | getQMakeConf2`
+    fi
+    getQMakeConf3 "$1" "$specvals"
+}
+
+getXQMakeConf()
+{
+    if [ -z "$xspecvals" ]; then
+        xspecvals=`getQMakeConf1 "$XQMAKESPEC/qmake.conf" | getQMakeConf2`
+    fi
+    getQMakeConf3 "$1" "$xspecvals"
+}
+
+compilerSupportsFlag()
+{
+    cat >conftest.cpp <<EOF
+int main() { return 0; }
+EOF
+    "$@" -o conftest-out.o conftest.cpp
+    ret=$?
+    rm -f conftest.cpp conftest-out.o
+    return $ret
+}
+
+linkerSupportsFlag()
+{
+    compiler=$1
+    shift
+    lflags=-Wl
+    for flag
+    do
+	safe_flag=`shellEscape "$flag"`
+	lflags=$lflags,$safe_flag
+    done
+    compilerSupportsFlag $compiler $lflags >/dev/null 2>&1
+}
+
+#-------------------------------------------------------------------------------
+# device options
+#-------------------------------------------------------------------------------
+DeviceVar()
+{
+    case "$1" in
+        set)
+            eq="="
+            ;;
+        *)
+            echo >&2 "BUG: wrong command to QMakeVar: $1"
+            ;;
+    esac
+
+    echo "$2" "$eq" "$3" >> "$DEVICE_VARS_FILE"
+}
+
+#-------------------------------------------------------------------------------
+# operating system detection
+#-------------------------------------------------------------------------------
+
+# need that throughout the script
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# detect the "echo without newline" style. usage: echo $ECHO_N "<string>$ECHO_C"
+if echo '\c' | grep '\c' >/dev/null; then
+    ECHO_N=-n
+else
+    ECHO_C='\c'
+fi
+
+#-------------------------------------------------------------------------------
+# window system detection
+#-------------------------------------------------------------------------------
+
+PLATFORM_X11=no
+PLATFORM_QWS=maybe
+PLATFORM_QPA=maybe
+BUILD_ON_MAC=no
+if [ -d /System/Library/Frameworks/Carbon.framework ]; then
+    PLATFORM_MAC=maybe
+    BUILD_ON_MAC=yes
+else
+    PLATFORM_MAC=no
+fi
+
+#-----------------------------------------------------------------------------
+# Qt version detection
+#-----------------------------------------------------------------------------
+QT_VERSION=`grep '^# *define *QT_VERSION_STR' "$relpath"/src/corelib/global/qglobal.h`
+QT_MAJOR_VERSION=
+QT_MINOR_VERSION=0
+QT_PATCH_VERSION=0
+if [ -n "$QT_VERSION" ]; then
+   QT_VERSION=`echo $QT_VERSION | sed 's,^# *define *QT_VERSION_STR *"*\([^ ]*\)"$,\1,'`
+   MAJOR=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\1,'`
+   if [ -n "$MAJOR" ]; then
+     MINOR=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\2,'`
+      PATCH=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\3,'`
+      QT_MAJOR_VERSION="$MAJOR"
+      [ -z "$MINOR" ] || QT_MINOR_VERSION="$MINOR"
+      [ -z "$PATCH" ] || QT_PATCH_VERSION="$PATCH"
+   fi
+fi
+if [ -z "$QT_MAJOR_VERSION" ]; then
+   echo "Cannot process version from qglobal.h: $QT_VERSION"
+   echo "Cannot proceed."
+   exit 1
+fi
+
+QT_PACKAGEDATE=`grep '^# *define *QT_PACKAGEDATE_STR' "$relpath"/src/corelib/global/qglobal.h | sed -e 's,^# *define *QT_PACKAGEDATE_STR *"\([^ ]*\)"$,\1,' -e s,-,,g`
+if [ -z "$QT_PACKAGEDATE" ]; then
+   echo "Unable to determine package date from qglobal.h: '$QT_PACKAGEDATE'"
+   echo "Cannot proceed"
+   exit 1
+fi
+
+#-------------------------------------------------------------------------------
+# check the license
+#-------------------------------------------------------------------------------
+COMMERCIAL_USER=ask
+CFG_DEV=no
+CFG_NOKIA=no
+CFG_EMBEDDED=no
+CFG_RTOS_ENABLED=yes
+EditionString=Commercial
+
+earlyArgParse()
+{
+    # parse the arguments, setting things to "yes" or "no"
+    while [ "$#" -gt 0 ]; do
+        CURRENT_OPT="$1"
+        UNKNOWN_ARG=no
+        case "$1" in
+        #Autoconf style options
+        --enable-*)
+            VAR=`echo $1 | sed "s,^--enable-\(.*\),\1,"`
+            VAL=yes
+            ;;
+        --disable-*)
+            VAR=`echo $1 | sed "s,^--disable-\(.*\),\1,"`
+            VAL=no
+            ;;
+        --*=*)
+            VAR=`echo $1 | sed "s,^--\(.*\)=.*,\1,"`
+            VAL=`echo $1 | sed "s,^--.*=\(.*\),\1,"`
+            ;;
+        --no-*)
+            VAR=`echo $1 | sed "s,^--no-\(.*\),\1,"`
+            VAL=no
+            ;;
+        -embedded)
+            VAR=embedded
+            # this option may or may not be followed by an argument
+            if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+                VAL=auto
+            else
+                shift;
+                VAL=$1
+            fi
+            ;;
+        -embedded-lite|-qpa)
+            VAR=qpa
+            # this option may or may not be followed by an argument
+            if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+                VAL=auto
+            else
+                shift;
+                VAL=$1
+            fi
+            ;;
+        -nacl)
+            shift;
+            VAR=nacl
+            VAL=$1
+            ;;
+
+        -h|help|--help|-help)
+            if [ "$VAL" = "yes" ]; then
+                OPT_HELP="$VAL"
+                COMMERCIAL_USER="no" #doesn't matter we will display the help
+            else
+                UNKNOWN_OPT=yes
+                COMMERCIAL_USER="no" #doesn't matter we will display the help
+            fi
+            ;;
+        --*)
+            VAR=`echo $1 | sed "s,^--\(.*\),\1,"`
+            VAL=yes
+            ;;
+        -*)
+            VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+            VAL="unknown"
+            ;;
+        *)
+            UNKNOWN_ARG=yes
+            ;;
+        esac
+        if [ "$UNKNOWN_ARG" = "yes" ]; then
+            shift
+            continue
+        fi
+        shift
+
+        UNKNOWN_OPT=no
+        case "$VAR" in
+        embedded)
+            CFG_EMBEDDED="$VAL"
+            PLATFORM_X11=no
+            PLATFORM_MAC=no
+            PLATFORM_QWS=yes
+            PLATFORM_QPA=no
+            ;;
+        qpa)
+            CFG_EMBEDDED="no"
+            if [ "$PLATFORM_QPA" != "no" ]; then
+                if [ "$PLATFORM_QPA" = "maybe" ]; then
+                    PLATFORM_X11=no
+                    PLATFORM_MAC=no
+                    PLATFORM_QWS=no
+                    PLATFORM_QPA=yes
+                fi
+            else
+                echo "No license exists to enable Qt QPA. Disabling."
+                CFG_EMBEDDED=no
+            fi
+            ;;
+        nacl)
+            echo "Using NaCl at $VAL."
+            PLATFORM_X11=no
+            PLATFORM_MAC=no
+            PLATFORM_QWS=no
+            CFG_NACL_PATH=$VAL
+            CFG_EMBEDDED=nacl
+            ;;
+
+        developer-build)
+            CFG_DEV="yes"
+            ;;
+        nokia-developer)
+            CFG_DEV="yes"
+            CFG_NOKIA="yes"
+            COMMERCIAL_USER="no"
+            ;;
+        commercial)
+            COMMERCIAL_USER="yes"
+            ;;
+        opensource)
+            COMMERCIAL_USER="no"
+            ;;
+        *)
+            UNKNOWN_OPT=yes
+            ;;
+        esac
+    done
+}
+
+earlyArgParse "$@"
+
+if [ "$COMMERCIAL_USER" = "ask" ]; then
+    while true; do
+        echo "Which edition of Qt do you want to use ?"
+        echo
+        echo "Type 'c' if you want to use the Commercial Edition."
+        echo "Type 'o' if you want to use the Open Source Edition."
+        echo
+        read commercial
+        echo
+        if [ "$commercial" = "c" ]; then
+            COMMERCIAL_USER="yes"
+            break
+        elif [ "$commercial" = "o" ]; then
+            COMMERCIAL_USER="no"
+            break
+        fi
+    done
+fi
+
+if [ "$CFG_NOKIA" = "yes" ]; then
+    Licensee="Nokia"
+    Edition="NokiaInternalBuild"
+    EditionString="Nokia Internal Build"
+    QT_EDITION="QT_EDITION_OPENSOURCE"
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+elif [ -f "$relpath"/LICENSE.PREVIEW.COMMERCIAL ] && [ $COMMERCIAL_USER = "yes" ]; then
+    # Commercial preview release
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    Licensee="Preview"
+    Edition="Preview"
+    QT_EDITION="QT_EDITION_DESKTOP"
+    LicenseType="Technology Preview"
+elif [ $COMMERCIAL_USER = "yes" ]; then
+    # one of commercial editions
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    [ "$PLATFORM_QPA" = "maybe" ] && PLATFORM_QPA=no
+    [ "$PLATFORM_QWS" = "maybe" ] && PLATFORM_QWS=no
+
+    # read in the license file
+    if [ -f "$LICENSE_FILE" ]; then
+        . "$LICENSE_FILE" >/dev/null 2>&1
+        if [ -z "$LicenseKeyExt" ]; then
+            echo
+            echo "You are using an old license file."
+            echo
+            echo "Please install the license file supplied by Digia,"
+            echo "or install the Qt Open Source Edition if you intend to"
+            echo "develop free software."
+            exit 1
+        fi
+	if [ -z "$Licensee" ]; then
+	    echo
+	    echo "Invalid license key. Please check the license key."
+	    exit 1
+	fi
+    else
+        if [ -z "$LicenseKeyExt" ]; then
+            echo
+            echo $ECHO_N "Please enter your license key: $ECHO_C"
+            read LicenseKeyExt
+            Licensee="Unknown user"
+        fi
+    fi
+
+    # Key verification
+    echo "$LicenseKeyExt" | grep ".....*-....*-....*-....*-.....*-.....*-...." >/dev/null 2>&1 \
+        && LicenseValid="yes" \
+        || LicenseValid="no"
+    if [ "$LicenseValid" != "yes" ]; then
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+    fi
+    ProductCode=`echo $LicenseKeyExt | cut -f 1 -d - | cut -b 1`
+    PlatformCode=`echo $LicenseKeyExt | cut -f 2 -d -`
+    LicenseTypeCode=`echo $LicenseKeyExt | cut -f 3 -d -`
+    LicenseFeatureCode=`echo $LicenseKeyExt | cut -f 4 -d - | cut -b 1`
+
+    # determine which edition we are licensed to use
+    case "$LicenseTypeCode" in
+    F4M)
+        LicenseType="Commercial"
+        case $ProductCode in
+        F)
+            Edition="Universal"
+            QT_EDITION="QT_EDITION_UNIVERSAL"
+            ;;
+        B)
+            Edition="FullFramework"
+            EditionString="Full Framework"
+            QT_EDITION="QT_EDITION_DESKTOP"
+            ;;
+        L)
+            Edition="GUIFramework"
+            EditionString="GUI Framework"
+            QT_EDITION="QT_EDITION_DESKTOPLIGHT"
+            ;;
+        esac
+        ;;
+    Z4M|R4M|Q4M)
+        LicenseType="Evaluation"
+        QMakeVar add DEFINES QT_EVAL
+        case $ProductCode in
+         B)
+            Edition="Evaluation"
+            QT_EDITION="QT_EDITION_EVALUATION"
+            ;;
+        esac
+        ;;
+    esac
+    if [ -z "$LicenseType" -o -z "$Edition" -o -z "$QT_EDITION" ]; then
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+    fi
+
+    # verify that we are licensed to use Qt on this platform
+    LICENSE_EXTENSION=
+    case "$PlatformCode" in
+	*L)
+	    CFG_RTOS_ENABLED=yes
+	    PlatformCode=`echo "$PlatformCode" | sed 'h;y/8NPQRTZ/UCWX9M7/;x;G;s/\(.\)....\(.\)./\1\2/'`
+	    ;;
+	*)
+	    CFG_RTOS_ENABLED=no
+	    PlatformCode=`echo "$PlatformCode" | sed 's/.$//'`
+	    ;;
+    esac
+    ### EMBEDDED_QPA logic missing ###
+    case "$PlatformCode,$PLATFORM_MAC,$PLATFORM_QWS" in
+        X9,* | XC,* | XU,* | XW,* | XM,*)
+            # Qt All-OS
+            LICENSE_EXTENSION="-ALLOS"
+            ;;
+        8M,* | KM,* | S9,* | SC,* | SM,* | SU,* | SW,* | X9,* | XC,* | XU,* | XW,*)
+            # Qt for Embedded Linux
+            LICENSE_EXTENSION="-EMBEDDED"
+            ;;
+        6M,*,no | N7,*,no | N9,*,no | NX,*,no)
+            # Embedded no-deploy
+            LICENSE_EXTENSION="-EMBEDDED"
+            ;;
+        FM,*,no | LM,yes,* | ZM,no,no)
+            # Desktop
+            LICENSE_EXTENSION="-DESKTOP"
+            ;;
+        *)
+            Platform=Linux/X11
+            [ "$PLATFORM_MAC" = "yes" ] && Platform='Mac OS X'
+            [ "$PLATFORM_QWS" = "yes" ] && Platform='Embedded Linux'
+            echo
+            echo "You are not licensed for the $Platform platform."
+            echo
+            echo "Please use contact form at http://qt.digia.com/contact-us to upgrade your license to"
+            echo "include the $Platform platform, or install the Qt Open Source Edition"
+            echo "if you intend to develop free software."
+            exit 1
+            ;;
+    esac
+
+    if test -r "$relpath/.LICENSE"; then
+	# Generic, non-final license
+	LICENSE_EXTENSION=""
+	line=`sed 'y/a-z/A-Z/;q' "$relpath"/.LICENSE`
+	case "$line" in
+	    *BETA*)
+		Edition=Beta
+		;;
+	    *TECHNOLOGY?PREVIEW*)
+		Edition=Preview
+		;;
+	    *EVALUATION*)
+		Edition=Evaluation
+		;;
+	    *)
+		echo >&2 "Invalid license files; cannot continue"
+		exit 1
+		;;
+	esac
+	Licensee="$Edition"
+	EditionString="$Edition"
+	QT_EDITION="QT_EDITION_DESKTOP"
+    fi
+
+    case "$LicenseFeatureCode" in
+    B|G|L|Y)
+        # US
+        case "$LicenseType" in
+        Commercial)
+            cp -f "$relpath/.LICENSE${LICENSE_EXTENSION}-US" "$outpath/LICENSE"
+            ;;
+        Evaluation)
+            cp -f "$relpath/.LICENSE-EVALUATION-US" "$outpath/LICENSE"
+            ;;
+        esac
+        ;;
+    2|4|5|F)
+        # non-US
+        case "$LicenseType" in
+        Commercial)
+            cp -f "$relpath/.LICENSE${LICENSE_EXTENSION}" "$outpath/LICENSE"
+            ;;
+        Evaluation)
+            cp -f "$relpath/.LICENSE-EVALUATION" "$outpath/LICENSE"
+            ;;
+        esac
+        ;;
+    *)
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+        ;;
+    esac
+    case "$LicenseFeatureCode" in
+	4|B|F|Y)
+	    CFG_RTOS_ENABLED=yes
+	    ;;
+	2|5|G|L)
+	    CFG_RTOS_ENABLED=no
+	    ;;
+    esac
+    if [ '!' -f "$outpath/LICENSE" ]; then
+        echo "The LICENSE, LICENSE.GPL3 LICENSE.LGPL file shipped with"
+        echo "this software has disappeared."
+        echo
+        echo "Sorry, you are not licensed to use this software."
+        echo "Try re-installing."
+        echo
+        exit 1
+    fi
+elif [ $COMMERCIAL_USER = "no" ]; then
+    # Open Source edition - may only be used under the terms of the GPL or LGPL.
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    Licensee="Open Source"
+    Edition="OpenSource"
+    EditionString="Open Source"
+    QT_EDITION="QT_EDITION_OPENSOURCE"
+fi
+
+#-------------------------------------------------------------------------------
+# initalize variables
+#-------------------------------------------------------------------------------
+
+SYSTEM_VARIABLES="RANLIB STRIP OBJDUMP LD CC CXX CFLAGS CXXFLAGS LDFLAGS"
+for varname in $SYSTEM_VARIABLES; do
+    qmakevarname="${varname}"
+    # use LDFLAGS for autoconf compat, but qmake uses QMAKE_LFLAGS
+    if [ "${varname}" = "LDFLAGS" ]; then
+        qmakevarname="LFLAGS"
+    elif [ "${varname}" = "LD" ]; then
+        qmakevarname="LINK"
+    fi
+    cmd=`echo \
+'if [ -n "\$'${varname}'" ]; then
+    QMakeVar set QMAKE_'${qmakevarname}' "\$'${varname}'"
+fi'`
+    eval "$cmd"
+done
+# Use CC/CXX to run config.tests
+mkdir -p "$outpath/config.tests"
+rm -f "$outpath/config.tests/.qmake.cache"
+cp "$QMAKE_VARS_FILE" "$outpath/config.tests/.qmake.cache"
+
+QMakeVar add styles "cde mac motif plastique cleanlooks windows"
+QMakeVar add decorations "default windows styled"
+QMakeVar add mouse-drivers "pc"
+if [ "$UNAME_SYSTEM" = "Linux" ] ; then
+    QMakeVar add gfx-drivers "linuxfb"
+    QMakeVar add mouse-drivers "linuxtp"
+fi
+QMakeVar add kbd-drivers "tty"
+
+if [ "$CFG_DEV" = "yes" ]; then
+    QMakeVar add kbd-drivers "um"
+fi
+
+# QTDIR may be set and point to an old or system-wide Qt installation
+unset QTDIR
+
+# the minimum version of libdbus-1 that we require:
+MIN_DBUS_1_VERSION=0.93
+
+# initalize internal variables
+CFG_CONFIGURE_EXIT_ON_ERROR=yes
+CFG_PROFILE=no
+CFG_EXCEPTIONS=unspecified
+CFG_GUI=auto # (yes|no|auto)
+CFG_SCRIPT=auto # (yes|no|auto)
+CFG_SCRIPTTOOLS=auto # (yes|no|auto)
+CFG_XMLPATTERNS=auto # (yes|no|auto)
+CFG_INCREMENTAL=auto
+CFG_QCONFIG=full
+CFG_DEBUG=auto
+CFG_MYSQL_CONFIG=
+CFG_DEBUG_RELEASE=no
+CFG_SHARED=yes
+CFG_SM=auto
+CFG_XSHAPE=auto
+CFG_XSYNC=auto
+CFG_XVIDEO=auto
+CFG_XINERAMA=runtime
+CFG_XFIXES=runtime
+CFG_ZLIB=auto
+CFG_SYMBIAN_DEFFILES=auto
+CFG_S60=auto
+CFG_SQLITE=qt
+CFG_GIF=auto
+CFG_TIFF=auto
+CFG_LIBTIFF=auto
+CFG_PNG=yes
+CFG_LIBPNG=auto
+CFG_JPEG=auto
+CFG_LIBJPEG=auto
+CFG_MNG=auto
+CFG_LIBMNG=auto
+CFG_XCURSOR=runtime
+CFG_XRANDR=runtime
+CFG_XRENDER=auto
+CFG_MITSHM=auto
+CFG_OPENGL=auto
+CFG_OPENVG=auto
+CFG_OPENVG_LC_INCLUDES=no
+CFG_OPENVG_SHIVA=auto
+CFG_OPENVG_ON_OPENGL=auto
+CFG_EGL=no
+CFG_EGL_GLES_INCLUDES=no
+CFG_SSE=auto
+CFG_FONTCONFIG=auto
+CFG_QWS_FREETYPE=auto
+CFG_LIBFREETYPE=auto
+CFG_SQL_AVAILABLE=
+QT_DEFAULT_BUILD_PARTS="libs tools examples demos docs translations"
+CFG_BUILD_PARTS=""
+CFG_NOBUILD_PARTS=""
+CFG_RELEASE_QMAKE=no
+CFG_PHONON=auto
+CFG_PHONON_BACKEND=yes
+CFG_MULTIMEDIA=auto
+CFG_AUDIO_BACKEND=auto
+CFG_SVG=auto
+CFG_DECLARATIVE=auto
+CFG_DECLARATIVE_DEBUG=yes
+CFG_WEBKIT=auto # (yes|no|auto|debug)
+CFG_JAVASCRIPTCORE_JIT=auto
+CFG_STACK_PROTECTOR_STRONG=auto
+
+CFG_GFX_AVAILABLE="linuxfb transformed qvfb vnc multiscreen directfb"
+CFG_GFX_ON="linuxfb multiscreen"
+CFG_GFX_PLUGIN_AVAILABLE=
+CFG_GFX_PLUGIN=
+CFG_GFX_OFF=
+CFG_KBD_AVAILABLE="tty linuxinput qvfb"
+CFG_KBD_ON="tty"    #default, see QMakeVar above
+CFG_MOUSE_AVAILABLE="pc linuxtp linuxinput tslib qvfb"
+CFG_MOUSE_ON="pc linuxtp"   #default, see QMakeVar above
+
+if [ -f "$relpath/src/gui/embedded/qscreenqnx_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} qnx"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} qnx"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} qnx"
+fi
+if [ -f "$relpath/src/gui/embedded/qscreenintegrityfb_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} integrity"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} integrity"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} integrityfb"
+fi
+
+if [ -f "$relpath/src/gui/embedded/qscreenvxworksfb_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} vxworks"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} vxworks"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} vxworksfb"
+fi
+
+CFG_ARCH=
+CFG_HOST_ARCH=
+CFG_KBD_PLUGIN_AVAILABLE=
+CFG_KBD_PLUGIN=
+CFG_KBD_OFF=
+CFG_MOUSE_PLUGIN_AVAILABLE=
+CFG_MOUSE_PLUGIN=
+CFG_MOUSE_OFF=
+CFG_USE_GNUMAKE=no
+CFG_IM=yes
+CFG_DECORATION_AVAILABLE="styled windows default"
+CFG_DECORATION_ON="${CFG_DECORATION_AVAILABLE}" # all on by default
+CFG_DECORATION_PLUGIN_AVAILABLE=
+CFG_DECORATION_PLUGIN=
+CFG_XINPUT=runtime
+CFG_XKB=auto
+CFG_NIS=auto
+CFG_CUPS=auto
+CFG_ICONV=auto
+CFG_DBUS=auto
+CFG_GLIB=auto
+CFG_GSTREAMER=auto
+CFG_QGTKSTYLE=auto
+CFG_QS60STYLE=auto
+CFG_LARGEFILE=auto
+CFG_OPENSSL=auto
+CFG_PTMALLOC=no
+CFG_STL=auto
+CFG_PRECOMPILE=auto
+CFG_SEPARATE_DEBUG_INFO=no
+CFG_SEPARATE_DEBUG_INFO_NOCOPY=no
+CFG_REDUCE_EXPORTS=auto
+CFG_MMX=auto
+CFG_3DNOW=auto
+CFG_SSE=auto
+CFG_SSE2=auto
+CFG_SSE3=auto
+CFG_SSSE3=auto
+CFG_SSE4_1=auto
+CFG_SSE4_2=auto
+CFG_AVX=auto
+CFG_REDUCE_RELOCATIONS=no
+CFG_IPV6=auto
+CFG_NAS=no
+CFG_QWS_DEPTHS=all
+CFG_USER_BUILD_KEY=
+CFG_ACCESSIBILITY=auto
+CFG_QT3SUPPORT=yes
+CFG_ENDIAN=auto
+CFG_HOST_ENDIAN=auto
+CFG_DOUBLEFORMAT=auto
+CFG_ARMFPA=auto
+CFG_IWMMXT=no
+CFG_NEON=auto
+CFG_CLOCK_GETTIME=auto
+CFG_CLOCK_MONOTONIC=auto
+CFG_MREMAP=auto
+CFG_GETADDRINFO=auto
+CFG_IPV6IFNAME=auto
+CFG_GETIFADDRS=auto
+CFG_INOTIFY=auto
+CFG_RPATH=yes
+CFG_FRAMEWORK=auto
+CFG_MAC_ARCHS=
+MAC_CONFIG_TEST_COMMANDLINE=  # used to make the configure tests run with the correct arch's and SDK settings
+CFG_MAC_DWARF2=auto
+CFG_MAC_XARCH=auto
+CFG_MAC_CARBON=no
+CFG_MAC_COCOA=yes
+COMMANDLINE_MAC_CARBON=no
+CFG_MAC_HARFBUZZ=no
+CFG_SXE=no
+CFG_PREFIX_INSTALL=yes
+CFG_SDK=
+D_FLAGS=
+I_FLAGS=
+L_FLAGS=
+RPATH_FLAGS=
+l_FLAGS=
+QCONFIG_FLAGS=
+XPLATFORM=              # This seems to be the QMAKESPEC, like "linux-g++" or "symbian-gcce"
+XPLATFORM_MINGW=no      # Whether target platform is MinGW (win32-g++*)
+XPLATFORM_INTEGRITY=no  # Whether target platform is INTEGRITY (*integrity*)
+XPLATFORM_SYMBIAN=no    # Whether target platform is SYMBIAN (*symbian*)
+XPLATFORM_SYMBIAN_SBSV2=no # Whether target platform is SYMBIAN_SBSV2 (symbian-sbsv2)
+XPLATFORM_QNX=no
+PLATFORM=$QMAKESPEC
+QT_CROSS_COMPILE=no
+OPT_CONFIRM_LICENSE=no
+OPT_SHADOW=maybe
+OPT_FAST=auto
+OPT_VERBOSE=no
+OPT_HELP=
+CFG_SILENT=no
+CFG_GRAPHICS_SYSTEM=default
+CFG_RUNTIME_SYSTEM=
+CFG_ALSA=auto
+CFG_PULSEAUDIO=auto
+CFG_COREWLAN=auto
+CFG_ICD=auto
+CFG_NOPROCESS=no
+CFG_ICU=auto
+CFG_SYSTEM_PROXIES=no
+CFG_SLOG2=auto
+
+# initalize variables used for installation
+QT_INSTALL_PREFIX=
+QT_INSTALL_DOCS=
+QT_INSTALL_HEADERS=
+QT_INSTALL_LIBS=
+QT_INSTALL_BINS=
+QT_INSTALL_PLUGINS=
+QT_INSTALL_IMPORTS=
+QT_INSTALL_DATA=
+QT_INSTALL_TRANSLATIONS=
+QT_INSTALL_SETTINGS=
+QT_INSTALL_EXAMPLES=
+QT_INSTALL_DEMOS=
+QT_HOST_PREFIX=
+
+#flags for SQL drivers
+QT_CFLAGS_PSQL=
+QT_LFLAGS_PSQL=
+QT_CFLAGS_MYSQL=
+QT_LFLAGS_MYSQL=
+QT_LFLAGS_MYSQL_R=
+QT_CFLAGS_SQLITE=
+QT_LFLAGS_SQLITE=
+QT_LFLAGS_ODBC="-lodbc"
+QT_LFLAGS_TDS=
+
+# flags for libdbus-1
+QT_CFLAGS_DBUS=
+QT_LIBS_DBUS=
+
+# flags for Glib (X11 only)
+QT_CFLAGS_GLIB=
+QT_LIBS_GLIB=
+
+# flags for GStreamer (X11 only)
+QT_CFLAGS_GSTREAMER=
+QT_LIBS_GSTREAMER=
+
+# default qpa platform
+QT_QPA_DEFAULT_PLATFORM=
+
+#flag for Symbian fpu settings
+QT_CFLAGS_FPU=
+
+# flags for libconnsettings0 (used for Maemo ICD bearer management plugin)
+QT_CFLAGS_CONNSETTINGS=
+QT_LIBS_CONNSETTINGS=
+
+#-------------------------------------------------------------------------------
+# check SQL drivers, mouse drivers and decorations available in this package
+#-------------------------------------------------------------------------------
+
+# opensource version removes some drivers, so force them to be off
+CFG_SQL_tds=no
+CFG_SQL_oci=no
+CFG_SQL_db2=no
+
+CFG_SQL_AVAILABLE=
+if [ -d "$relpath/src/plugins/sqldrivers" ]; then
+  for a in "$relpath/src/plugins/sqldrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_SQL_AVAILABLE="${CFG_SQL_AVAILABLE} ${base_a}"
+	 eval "CFG_SQL_${base_a}=auto"
+     fi
+  done
+fi
+
+CFG_DECORATION_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/decorations" ]; then
+  for a in "$relpath/src/plugins/decorations/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_DECORATION_PLUGIN_AVAILABLE="${CFG_DECORATION_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_KBD_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/kbddrivers" ]; then
+  for a in "$relpath/src/plugins/kbddrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_KBD_PLUGIN_AVAILABLE="${CFG_KBD_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_MOUSE_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/mousedrivers" ]; then
+  for a in "$relpath/src/plugins/mousedrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_MOUSE_PLUGIN_AVAILABLE="${CFG_MOUSE_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_GFX_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/gfxdrivers" ]; then
+  for a in "$relpath/src/plugins/gfxdrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_GFX_PLUGIN_AVAILABLE="${CFG_GFX_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+  CFG_GFX_OFF="$CFG_GFX_AVAILABLE" # assume all off
+fi
+
+CFG_IMAGEFORMAT_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/imageformats" ]; then
+    for a in "$relpath/src/plugins/imageformats/"*; do
+        if [ -d "$a" ]; then
+            base_a=`basename "$a"`
+            CFG_IMAGEFORMAT_PLUGIN_AVAILABLE="${CFG_IMAGEFORMAT_PLUGIN_AVAILABLE} ${base_a}"
+        fi
+    done
+fi
+
+#-------------------------------------------------------------------------------
+# Set Default NaCl options
+#-------------------------------------------------------------------------------
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    echo "Setting NaCl options:"
+    echo "-static"
+    CFG_SHARED=no
+    echo "-qpa nacl"
+    PLATFORM_QPA=yes
+    echo "-fast"
+    OPT_FAST=yes
+    echo "-qconfig nacl"
+    CFG_QCONFIG=nacl
+
+    if [ `uname` = "Linux" ]; then
+        I_FLAGS="$I_FLAGS -I${CFG_NACL_PATH}/toolchain/linux_x86/sdk/nacl-sdk/include"
+        L_FLAGS="$L_FLAGS -I${CFG_NACL_PATH}/toolchain/linux_x86/sdk/nacl-sdk/lib"
+    else
+        I_FLAGS="$I_FLAGS -I${CFG_NACL_PATH}/toolchain/mac_x86/sdk/nacl-sdk/include"
+        L_FLAGS="$L_FLAGS -I${CFG_NACL_PATH}/toolchain/mac_x86/sdk/nacl-sdk/lib"
+    fi
+
+    echo "-no-multimedia -no-webkit -no-phonon -no-nultimedia -no-mediaservices -no-xmlpatterns -no-script -no-sql-sqlite -nomake tests"
+    CFG_MULTIMEDIA=no
+    CFG_WEBKIT=no
+    CFG_PHONON=no
+    CFG_MULTIMEDIA=no
+    CFG_MEDIASERVICES=no
+    CFG_XMLPATTERNS=no
+    CFG_SCRIPT=no
+    CFG_SQLITE=no
+    CFG_SQL_sqlite=no
+    CFG_LIBTIFF=no
+    CFG_NOBUILD_PARTS="$CFG_NOBUILD_PARTS tests"
+    QT_CONFIG="$QT_CONFIG nacl"
+fi
+
+#-------------------------------------------------------------------------------
+# parse command line arguments
+#-------------------------------------------------------------------------------
+
+# parse the arguments, setting things to "yes" or "no"
+while [ "$#" -gt 0 ]; do
+    CURRENT_OPT="$1"
+    UNKNOWN_ARG=no
+    case "$1" in
+    #Autoconf style options
+    --enable-*)
+        VAR=`echo $1 | sed "s,^--enable-\(.*\),\1,"`
+        VAL=yes
+        ;;
+    --disable-*)
+        VAR=`echo $1 | sed "s,^--disable-\(.*\),\1,"`
+        VAL=no
+        ;;
+    --*=*)
+        VAR=`echo $1 | sed "s,^--\(.*\)=.*,\1,"`
+        VAL=`echo $1 | sed "s,^--.*=\(.*\),\1,"`
+        ;;
+    --no-*)
+        VAR=`echo $1 | sed "s,^--no-\(.*\),\1,"`
+        VAL=no
+        ;;
+    --*)
+        VAR=`echo $1 | sed "s,^--\(.*\),\1,"`
+        VAL=yes
+        ;;
+    -system-proxies)
+        VAR=system-proxies
+        VAL=yes
+        ;;
+    -no-system-proxies)
+        VAR=system-proxies
+        VAL=no
+        ;;
+    #Qt plugin options
+    -no-*-*|-plugin-*-*|-qt-*-*)
+        VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        VAL=`echo $1 | sed "s,^-\([^-]*\).*,\1,"`
+        ;;
+    #WebKit options
+    -webkit)
+        VAR="webkit"
+        VAL="yes"
+        ;;
+    -webkit-debug)
+        VAR="webkit"
+        VAL="debug"
+        ;;
+    -no-webkit)
+        VAR="webkit"
+        VAL="no"
+        ;;
+    #Qt style no options
+    -no-*)
+        VAR=`echo $1 | sed "s,^-no-\(.*\),\1,"`
+        VAL=no
+        ;;
+    #Qt style yes options
+    -incremental|-qvfb|-profile|-shared|-static|-sm|-xinerama|-xshape|-xsync|-xinput|-egl|-reduce-exports|-pch|-separate-debug-info|-stl|-freetype|-xcursor|-xfixes|-xrandr|-xrender|-mitshm|-fontconfig|-xkb|-nis|-qdbus|-dbus|-dbus-linked|-glib|-gstreamer|-gtkstyle|-cups|-iconv|-largefile|-h|-help|-v|-verbose|-debug|-release|-fast|-accessibility|-confirm-license|-gnumake|-framework|-qt3support|-debug-and-release|-exceptions|-cocoa|-carbon|-universal|-harfbuzz|-prefix-install|-silent|-armfpa|-optimized-qmake|-dwarf2|-reduce-relocations|-sse|-openssl|-openssl-linked|-ptmalloc|-xmlpatterns|-phonon|-phonon-backend|-multimedia|-audio-backend|-svg|-declarative|-declarative-debug|-javascript-jit|-script|-scripttools|-rpath|-force-pkg-config|-s60|-usedeffiles|-icu)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        VAL=yes
+        ;;
+    #Qt style options that pass an argument
+    -qconfig)
+        if [ "$PLATFORM_QWS" != "yes" -a "$PLATFORM_QPA" != "yes" ]; then
+            echo
+            echo "WARNING: -qconfig is only tested and supported on Qt for Embedded Linux."
+            echo
+        fi
+        CFG_QCONFIG="$VAL"
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        shift
+        VAL=$1
+        ;;
+    -prefix|-docdir|-headerdir|-plugindir|-importdir|-datadir|-libdir|-bindir|-translationdir|-sysconfdir|-examplesdir|-demosdir|-depths|-make|-nomake|-platform|-xplatform|-device-option|-buildkey|-sdk|-arch|-host-arch|-mysql_config|-sysroot)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        shift
+        VAL="$1"
+        ;;
+    #Qt style complex options in one command
+    -enable-*|-disable-*)
+        VAR=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+        VAL=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        ;;
+    #Qt Builtin/System style options
+    -no-*|-system-*|-qt-*)
+        VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        VAL=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+        ;;
+    #Options that cannot be generalized
+    -k|-continue)
+        VAR=fatal_error
+        VAL=no
+        ;;
+    -embedded)
+        VAR=embedded
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=auto
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -embedded-lite|-qpa)
+        VAR=qpa
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=auto
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -nacl)
+        VAR=nacl
+        shift;
+    ;;
+    -opengl)
+        VAR=opengl
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=yes
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -openvg)
+        VAR=openvg
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=yes
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -hostprefix)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=$outpath
+        else
+            shift;
+            VAL=$1
+        fi
+        ;;
+    -host-*-endian)
+        VAR=host_endian
+        VAL=`echo $1 | sed "s,^-.*-\(.*\)-.*,\1,"`
+        ;;
+    -*-endian)
+        VAR=endian
+        VAL=`echo $1 | sed "s,^-\(.*\)-.*,\1,"`
+        ;;
+    -qtnamespace)
+        VAR="qtnamespace"
+        shift
+        VAL="$1"
+        ;;
+    -graphicssystem)
+	VAR="graphicssystem"
+	shift
+	VAL=$1
+	;;
+    -runtimegraphicssystem)
+	VAR="runtimegraphicssystem"
+	shift
+	VAL=$1
+	;;
+    -qtlibinfix)
+        VAR="qtlibinfix"
+        shift
+        VAL="$1"
+        ;;
+    -D?*|-D)
+        VAR="add_define"
+        if [ "$1" = "-D" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-D,,'`
+        fi
+        ;;
+    -fpu)
+        VAR="fpu"
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=no
+        else
+            shift
+            VAL=$1
+        fi
+        ;;
+    -I?*|-I)
+        VAR="add_ipath"
+        if [ "$1" = "-I" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-I,,'`
+        fi
+        ;;
+    -L?*|-L)
+        VAR="add_lpath"
+        if [ "$1" = "-L" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-L,,'`
+        fi
+        ;;
+    -R?*|-R)
+        VAR="add_rpath"
+        if [ "$1" = "-R" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-R,,'`
+        fi
+        ;;
+    -l?*)
+        VAR="add_link"
+        VAL=`echo $1 | sed 's,-l,,'`
+        ;;
+    -F?*|-F)
+        VAR="add_fpath"
+        if [ "$1" = "-F" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-F,,'`
+        fi
+        ;;
+    -fw?*|-fw)
+        VAR="add_framework"
+        if [ "$1" = "-fw" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-fw,,'`
+        fi
+        ;;
+    -*)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        VAL="unknown"
+        ;;
+    *)
+        UNKNOWN_ARG=yes
+        ;;
+    esac
+    if [ "$UNKNOWN_ARG" = "yes" ]; then
+        echo "$1: unknown argument"
+        OPT_HELP=yes
+        ERROR=yes
+        shift
+        continue
+     fi
+    shift
+
+    UNKNOWN_OPT=no
+    case "$VAR" in
+    qt3support)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_QT3SUPPORT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    accessibility)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ACCESSIBILITY="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    license)
+	LICENSE_FILE="$VAL"
+	;;
+    gnumake)
+        CFG_USE_GNUMAKE="$VAL"
+        ;;
+    mysql_config)
+	CFG_MYSQL_CONFIG="$VAL"
+	;;
+    prefix)
+        QT_INSTALL_PREFIX="$VAL"
+        ;;
+    hostprefix)
+	QT_HOST_PREFIX="$VAL"
+	;;
+    force-pkg-config)
+        QT_FORCE_PKGCONFIG=yes
+        ;;
+    docdir)
+        QT_INSTALL_DOCS="$VAL"
+        ;;
+    headerdir)
+        QT_INSTALL_HEADERS="$VAL"
+        ;;
+    plugindir)
+        QT_INSTALL_PLUGINS="$VAL"
+        ;;
+    importdir)
+        QT_INSTALL_IMPORTS="$VAL"
+        ;;
+    datadir)
+        QT_INSTALL_DATA="$VAL"
+        ;;
+    libdir)
+        QT_INSTALL_LIBS="$VAL"
+        ;;
+    qtnamespace)
+        QT_NAMESPACE="$VAL"
+        ;;
+    qtlibinfix)
+        QT_LIBINFIX="$VAL"
+        ;;
+    translationdir)
+        QT_INSTALL_TRANSLATIONS="$VAL"
+        ;;
+    sysconfdir|settingsdir)
+        QT_INSTALL_SETTINGS="$VAL"
+        ;;
+    examplesdir)
+        QT_INSTALL_EXAMPLES="$VAL"
+        ;;
+    demosdir)
+        QT_INSTALL_DEMOS="$VAL"
+        ;;
+    qconfig)
+        CFG_QCONFIG="$VAL"
+        ;;
+    sysroot)
+        CFG_SYSROOT="$VAL"
+        ;;
+    bindir)
+        QT_INSTALL_BINS="$VAL"
+        ;;
+    buildkey)
+        CFG_USER_BUILD_KEY="$VAL"
+        ;;
+    sxe)
+	CFG_SXE="$VAL"
+        ;;
+    embedded)
+        CFG_EMBEDDED="$VAL"
+        PLATFORM_X11=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=yes
+        PLATFORM_QPA=no
+        ;;
+    embedded-lite|qpa)
+        CFG_EMBEDDED="no"
+        PLATFORM_X11=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=no
+        PLATFORM_QPA=yes
+        if [ "$VAL" != "auto" ]; then
+            QT_QPA_DEFAULT_PLATFORM="$VAL"
+        fi
+        ;;
+    nacl)
+        ;;
+    sse)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    endian)
+        if [ "$VAL" = "little" ]; then
+            CFG_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$VAL" = "big" ]; then
+            CFG_ENDIAN="Q_BIG_ENDIAN"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    host_endian)
+        if [ "$VAL" = "little" ]; then
+            CFG_HOST_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$VAL" = "big" ]; then
+            CFG_HOST_ENDIAN="Q_BIG_ENDIAN"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    armfpa)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ARMFPA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    depths)
+        CFG_QWS_DEPTHS="$VAL"
+        ;;
+    opengl)
+        if  [ "$VAL" = "auto" ] || [ "$VAL" = "desktop" ] ||
+            [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] ||
+            [ "$VAL" = "es1" ] || [ "$VAL" = "es2" ]; then
+            CFG_OPENGL="$VAL"
+            if  [ "$VAL" = "es1" ] || [ "$VAL" = "es2" ]; then
+                CFG_EGL="yes"
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openvg)
+        if [ "$VAL" = "auto" ] || [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_OPENVG="$VAL"
+            if [ "$CFG_EGL" = "no" ] && [ "$VAL" != "no" ]; then
+                CFG_EGL=auto
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    graphicssystem)
+        if [ "$PLATFORM_QWS" = "yes" ]; then
+            echo "Error: Graphics System plugins are not supported on QWS."
+            echo "   On QWS, the graphics system API is part of the QScreen plugin architecture "
+            echo "   rather than existing as a separate plugin."
+            echo ""
+            UNKNOWN_OPT=yes
+        else
+            if  [ "$VAL" = "opengl" ]; then
+                CFG_GRAPHICS_SYSTEM="opengl"
+            elif [ "$VAL" = "openvg" ]; then
+                CFG_GRAPHICS_SYSTEM="openvg"
+            elif [ "$VAL" = "raster" ]; then
+                CFG_GRAPHICS_SYSTEM="raster"
+            elif [ "$VAL" = "runtime" ]; then
+                CFG_GRAPHICS_SYSTEM="runtime"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+	;;
+    runtimegraphicssystem)
+        if  [ "$VAL" != "runtime" ]; then
+            CFG_RUNTIME_SYSTEM="$VAL"
+        fi
+	;;
+
+    qvfb) # left for commandline compatibility, not documented
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            if [ "$VAL" = "yes" ]; then
+		QMakeVar add gfx-drivers qvfb
+		QMakeVar add kbd-drivers qvfb
+		QMakeVar add mouse-drivers qvfb
+                CFG_GFX_ON="$CFG_GFX_ON qvfb"
+                CFG_KBD_ON="$CFG_KBD_ON qvfb"
+                CFG_MOUSE_ON="$CFG_MOUSE_ON qvfb"
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nomake)
+	CFG_NOBUILD_PARTS="$CFG_NOBUILD_PARTS $VAL"
+        ;;
+    make)
+	CFG_BUILD_PARTS="$CFG_BUILD_PARTS $VAL"
+        ;;
+    x11)
+        PLATFORM_QPA=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=no
+        PLATFORM_X11=yes
+        ;;
+    sdk)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            CFG_SDK="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+     dwarf2)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MAC_DWARF2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    arch)
+        # if this is a Mac then "windows" probably means
+        # we are cross-compiling for MinGW
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" != "windows" ]; then
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS $VAL"
+        else
+            CFG_ARCH=$VAL
+        fi
+        ;;
+    host-arch)
+        CFG_HOST_ARCH=$VAL
+        ;;
+    universal)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS x86 ppc"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    cocoa)
+#       do nothing - Cocoa is the default.
+        ;;
+    carbon)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_CARBON="$VAL"
+            COMMANDLINE_MAC_CARBON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    harfbuzz)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_CARBON" != "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_HARFBUZZ="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+
+    framework)
+        if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_QPA" = "yes" ]; then
+            CFG_FRAMEWORK="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    profile)
+        if [ "$VAL" = "yes" ]; then
+            CFG_PROFILE=yes
+	    QMakeVar add QMAKE_CFLAGS -pg
+	    QMakeVar add QMAKE_CXXFLAGS -pg
+	    QMakeVar add QMAKE_LFLAGS -pg
+            QMAKE_VARS="$QMAKE_VARS CONFIG+=nostrip"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    exceptions|g++-exceptions)
+        if [ "$VAL" = "no" ]; then
+            CFG_EXCEPTIONS=no
+        elif [ "$VAL" = "yes" ]; then
+            CFG_EXCEPTIONS=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    platform)
+        PLATFORM="$VAL"
+        # keep compatibility with old platform names
+        case $PLATFORM in
+        aix-64)
+            PLATFORM=aix-xlc-64
+            ;;
+        hpux-o64)
+            PLATFORM=hpux-acc-o64
+            ;;
+        hpux-n64)
+            PLATFORM=hpux-acc-64
+            ;;
+        hpux-acc-n64)
+            PLATFORM=hpux-acc-64
+            ;;
+        irix-n32)
+            PLATFORM=irix-cc
+            ;;
+        irix-64)
+            PLATFORM=irix-cc-64
+            ;;
+        irix-cc-n64)
+            PLATFORM=irix-cc-64
+            ;;
+        reliant-64)
+            PLATFORM=reliant-cds-64
+            ;;
+        solaris-64)
+            PLATFORM=solaris-cc-64
+            ;;
+        openunix-cc)
+            PLATFORM=unixware-cc
+            ;;
+        openunix-g++)
+            PLATFORM=unixware-g++
+            ;;
+        unixware7-cc)
+            PLATFORM=unixware-cc
+            ;;
+        unixware7-g++)
+            PLATFORM=unixware-g++
+            ;;
+        macx-g++-64)
+            PLATFORM=macx-g++
+	    NATIVE_64_ARCH=
+            case `uname -p` in
+            i386) NATIVE_64_ARCH="x86_64" ;;
+            powerpc) NATIVE_64_ARCH="ppc64" ;;
+            *)   echo "WARNING: Can't detect CPU architecture for macx-g++-64" ;;
+            esac
+	    if [ ! -z "$NATIVE_64_ARCH" ]; then
+		QTCONFIG_CONFIG="$QTCONFIG_CONFIG $NATIVE_64_ARCH"
+		CFG_MAC_ARCHS="$CFG_MAC_ARCHS $NATIVE_64_ARCH"
+            fi
+            ;;
+        esac
+        ;;
+    xplatform)
+        XPLATFORM="$VAL"
+        case `basename "$XPLATFORM"` in win32-g++*)
+            XPLATFORM_MINGW=yes
+            CFG_RPATH=no
+            CFG_REDUCE_EXPORTS=no
+            ;;
+        esac
+        case "$XPLATFORM" in *integrity*) XPLATFORM_INTEGRITY=yes;; esac
+        case "$XPLATFORM" in *symbian*) XPLATFORM_SYMBIAN=yes;; esac
+        case "$XPLATFORM" in symbian-sbsv2) XPLATFORM_SYMBIAN_SBSV2=yes;; esac
+        case "$XPLATFORM" in *qnx-*|*blackberry-*) XPLATFORM_QNX=yes;; esac
+        ;;
+    device-option)
+        DEV_VAR=`echo $VAL | sed "s,^\(.*\)=.*,\1,"`
+        DEV_VAL=`echo $VAL | sed "s,^.*=\(.*\),\1,"`
+        DeviceVar set $DEV_VAR $DEV_VAL
+        ;;
+    debug-and-release)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_DEBUG_RELEASE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    optimized-qmake)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_RELEASE_QMAKE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    release)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DEBUG=no
+        elif [ "$VAL" = "no" ]; then
+            CFG_DEBUG=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    prefix-install)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_PREFIX_INSTALL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    debug)
+        CFG_DEBUG="$VAL"
+        ;;
+    developer-build|commercial|opensource|nokia-developer)
+        # These switches have been dealt with already
+        ;;
+    static)
+        if [ "$VAL" = "yes" ]; then
+            CFG_SHARED=no
+        elif [ "$VAL" = "no" ]; then
+            CFG_SHARED=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    incremental)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_INCREMENTAL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fatal_error)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_CONFIGURE_EXIT_ON_ERROR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    feature-*)
+            FEATURE=`echo $VAR | sed "s,^[^-]*-\([^-]*\),\1," | tr 'abcdefghijklmnopqrstuvwxyz-' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+            if [ "$VAL" = "no" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_$FEATURE"
+            elif [ "$VAL" = "yes" ] || [ "$VAL" = "unknown" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_$FEATURE"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        ;;
+    shared)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SHARED="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gif)
+        if [ "$VAL" = "no" ]; then
+            CFG_GIF="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sm)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SM="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+
+        ;;
+    xinerama)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XINERAMA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xshape)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XSHAPE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xvideo)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XVIDEO="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xsync)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XSYNC="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xinput)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XINPUT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    egl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_EGL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    stl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_STL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    pch)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PRECOMPILE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    separate-debug-info)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SEPARATE_DEBUG_INFO="$VAL"
+        elif [ "$VAL" = "nocopy" ] ; then
+            CFG_SEPARATE_DEBUG_INFO="yes"
+            CFG_SEPARATE_DEBUG_INFO_NOCOPY="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    reduce-exports)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_REDUCE_EXPORTS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    mmx)
+        if [ "$VAL" = "no" ]; then
+            CFG_MMX="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    3dnow)
+        if [ "$VAL" = "no" ]; then
+            CFG_3DNOW="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse2)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse3)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE3="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    ssse3)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSSE3="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse4.1)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE4_1="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse4.2)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE4_2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    avx)
+        if [ "$VAL" = "no" ]; then
+            CFG_AVX="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    iwmmxt)
+	CFG_IWMMXT="yes"
+	;;
+    neon)
+        if [ "$VAL" = "no" ]; then
+            CFG_NEON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    reduce-relocations)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_REDUCE_RELOCATIONS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    freetype)
+        [ "$VAL" = "qt" ] && VAL=yes
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_QWS_FREETYPE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    zlib)
+        [ "$VAL" = "qt" ] && VAL=yes
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_ZLIB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        # No longer supported:
+        #[ "$VAL" = "no" ] && CFG_LIBPNG=no
+        ;;
+    s60)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_S60="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    usedeffiles)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SYMBIAN_DEFFILES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sqlite)
+        if [ "$VAL" = "system" ]; then
+            CFG_SQLITE=system
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libpng)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBPNG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libjpeg)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBJPEG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libmng)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBMNG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libtiff)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBTIFF="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nas-sound)
+        if [ "$VAL" = "system" ] || [ "$VAL" = "no" ]; then
+            CFG_NAS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xcursor)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XCURSOR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xfixes)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XFIXES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xrandr)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XRANDR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xrender)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XRENDER="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    mitshm)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MITSHM="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fontconfig)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_FONTCONFIG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xkb)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XKB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    cups)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_CUPS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    iconv)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ICONV="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    glib)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_GLIB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    slog2)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SLOG2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gstreamer)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_GSTREAMER="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gtkstyle)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_QGTKSTYLE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    style-s60)
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ]; then
+            CFG_QS60STYLE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gui)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_GUI="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_GUI="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    qdbus|dbus)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "linked" ]; then
+            CFG_DBUS="$VAL"
+	elif [ "$VAL" = "runtime" ]; then
+	    CFG_DBUS="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    dbus-linked)
+        if [ "$VAL" = "yes" ]; then
+	    CFG_DBUS="linked"
+	else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nis)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_NIS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    largefile)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_LARGEFILE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openssl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_OPENSSL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openssl-linked)
+        if [ "$VAL" = "yes" ]; then
+            CFG_OPENSSL="linked"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    ptmalloc)
+        if [ "$VAL" = "yes" ]; then
+            CFG_PTMALLOC="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+
+    xmlpatterns)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_XMLPATTERNS="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_XMLPATTERNS="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    script)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SCRIPT="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SCRIPT="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    scripttools)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SCRIPTTOOLS="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SCRIPTTOOLS="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    svg)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SVG="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SVG="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    declarative)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DECLARATIVE="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_DECLARATIVE="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+	;;
+    declarative-debug)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DECLARATIVE_DEBUG="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_DECLARATIVE_DEBUG="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    webkit)
+        [ "$VAL" = "auto" ] && VAL="yes"
+        CFG_WEBKIT="$VAL"
+        ;;
+    javascript-jit)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ] || [ "$VAL" = "no" ]; then 
+            CFG_JAVASCRIPTCORE_JIT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    confirm-license)
+        if [ "$VAL" = "yes" ]; then
+            OPT_CONFIRM_LICENSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    h|help)
+        if [ "$VAL" = "yes" ]; then
+            OPT_HELP="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sql-*|gfx-*|decoration-*|kbd-*|mouse-*|imageformat-*)
+        # if Qt style options were used, $VAL can be "no", "qt", or "plugin"
+        # if autoconf style options were used, $VAL can be "yes" or "no"
+        [ "$VAL" = "yes" ] && VAL=qt
+        # now $VAL should be "no", "qt", or "plugin"... double-check
+        if [ "$VAL" != "no" ] && [ "$VAL" != "qt" ] && [ "$VAL" != "plugin" ]; then
+            UNKNOWN_OPT=yes
+        fi
+        # now $VAL is "no", "qt", or "plugin"
+        OPT="$VAL"
+        VAL=`echo $VAR | sed "s,^[^-]*-\([^-]*\).*,\1,"`
+        VAR=`echo $VAR | sed "s,^\([^-]*\).*,\1,"`
+
+        # Grab the available values
+        case "$VAR" in
+        sql)
+            avail="$CFG_SQL_AVAILABLE"
+            ;;
+        gfx)
+            avail="$CFG_GFX_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_GFX_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        decoration)
+            avail="$CFG_DECORATION_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_DECORATION_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        kbd)
+            avail="$CFG_KBD_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_KBD_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        mouse)
+            avail="$CFG_MOUSE_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_MOUSE_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        imageformat)
+            avail="$CFG_IMAGEFORMAT_PLUGIN_AVAILABLE"
+            if [ "$OPT" != "plugin" ]; then
+                # png is always built in
+                avail="$avail png"
+            fi
+            ;;
+        *)
+            avail=""
+            echo "BUG: Unhandled type $VAR used in $CURRENT_OPT"
+            ;;
+        esac
+
+        # Check that that user's value is available.
+        found=no
+        for d in $avail; do
+            if [ "$VAL" = "$d" ]; then
+                found=yes
+                break
+            fi
+        done
+        [ "$found" = yes ] || ERROR=yes
+
+        if [ "$VAR" = "sql" ]; then
+            # set the CFG_SQL_driver
+            eval "CFG_SQL_$VAL=\$OPT"
+            continue
+        elif [ "$VAR" = "imageformat" ]; then
+            [ "$OPT" = "qt" ] && OPT=yes
+            VAL="`echo $VAL |tr a-z A-Z`"
+            eval "CFG_$VAL=$OPT"
+            continue
+        fi
+
+        if [ "$OPT" = "plugin" ] || [ "$OPT" = "qt" ]; then
+            if [ "$OPT" = "plugin" ]; then
+                [ "$VAR" = "decoration" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "decoration" ] && CFG_DECORATION_ON=`echo "${CFG_DECORATION_ON} " | sed "s,${VAL} ,,g"` && CFG_DECORATION_PLUGIN="$CFG_DECORATION_PLUGIN ${VAL}"
+                [ "$VAR" = "kbd" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "kbd" ] && CFG_KBD_ON=`echo "${CFG_KBD_ON} " | sed "s,${VAL} ,,g"` && CFG_KBD_PLUGIN="$CFG_KBD_PLUGIN ${VAL}"
+                [ "$VAR" = "mouse" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "mouse" ] && CFG_MOUSE_ON=`echo "${CFG_MOUSE_ON} " | sed "s,${VAL} ,,g"` && CFG_MOUSE_PLUGIN="$CFG_MOUSE_PLUGIN ${VAL}"
+                [ "$VAR" = "gfx" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "gfx" ] && CFG_GFX_ON=`echo "${CFG_GFX_ON} " | sed "s,${VAL} ,,g"` && CFG_GFX_PLUGIN="${CFG_GFX_PLUGIN} ${VAL}"
+                VAR="${VAR}-${OPT}"
+            else
+                if [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "decoration" ] || [ "$VAR" = "mouse" ]; then
+                    [ "$VAR" = "gfx" ] && CFG_GFX_ON="$CFG_GFX_ON $VAL"
+                    [ "$VAR" = "kbd" ] && CFG_KBD_ON="$CFG_KBD_ON $VAL"
+		    [ "$VAR" = "decoration" ] && CFG_DECORATION_ON="$CFG_DECORATION_ON $VAL"
+                    [ "$VAR" = "mouse" ] && CFG_MOUSE_ON="$CFG_MOUSE_ON $VAL"
+                    VAR="${VAR}-driver"
+                fi
+            fi
+	    QMakeVar add "${VAR}s" "${VAL}"
+        elif [ "$OPT" = "no" ]; then
+            PLUG_VAR="${VAR}-plugin"
+            if [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "mouse" ]; then
+                IN_VAR="${VAR}-driver"
+            else
+                IN_VAR="${VAR}"
+            fi
+            [ "$VAR" = "decoration" ] && CFG_DECORATION_ON=`echo "${CFG_DECORATION_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "gfx" ] && CFG_GFX_ON=`echo "${CFG_GFX_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "kbd" ] && CFG_KBD_ON=`echo "${CFG_KBD_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "mouse" ] && CFG_MOUSE_ON=`echo "${CFG_MOUSE_ON} " | sed "s,${VAL} ,,g"`
+	    QMakeVar del "${IN_VAR}s" "$VAL"
+	    QMakeVar del "${PLUG_VAR}s" "$VAL"
+        fi
+        if [ "$ERROR" = "yes" ]; then
+           echo "$CURRENT_OPT: unknown argument"
+           OPT_HELP=yes
+        fi
+        ;;
+    v|verbose)
+        if [ "$VAL" = "yes" ]; then
+            if [ "$OPT_VERBOSE" = "$VAL" ]; then            # takes two verboses to turn on qmake debugs
+                QMAKE_SWITCHES="$QMAKE_SWITCHES -d"
+            else
+                OPT_VERBOSE=yes
+            fi
+        elif [ "$VAL" = "no" ]; then
+            if [ "$OPT_VERBOSE" = "$VAL" ] && echo "$QMAKE_SWITCHES" | grep ' -d' >/dev/null 2>&1; then
+                QMAKE_SWITCHES=`echo $QMAKE_SWITCHES | sed "s, -d,,"`
+            else
+                OPT_VERBOSE=no
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fast)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            OPT_FAST="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    rpath)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_RPATH="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    add_define)
+        D_FLAGS="$D_FLAGS \"$VAL\""
+        ;;
+    add_ipath)
+        I_FLAGS="$I_FLAGS -I\"${VAL}\""
+        ;;
+    add_lpath)
+        L_FLAGS="$L_FLAGS -L\"${VAL}\""
+        ;;
+    add_rpath)
+        RPATH_FLAGS="$RPATH_FLAGS \"${VAL}\""
+        ;;
+    add_link)
+        l_FLAGS="$l_FLAGS -l\"${VAL}\""
+        ;;
+    add_fpath)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            L_FLAGS="$L_FLAGS -F\"${VAL}\""
+            I_FLAGS="$I_FLAGS -F\"${VAL}\""
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    add_framework)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            l_FLAGS="$l_FLAGS -framework \"${VAL}\""
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    silent)
+        CFG_SILENT="$VAL"
+        ;;
+    phonon)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PHONON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    phonon-backend)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PHONON_BACKEND="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    multimedia)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MULTIMEDIA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    dont-process)
+        CFG_NOPROCESS=yes
+        ;;
+    process)
+        CFG_NOPROCESS=no
+        ;;
+    audio-backend)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_AUDIO_BACKEND="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fpu)
+       if [ "$VAL" != "no" ]; then
+          QT_CFLAGS_FPU=$VAL
+       fi
+       ;;
+    icu)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ICU="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    system-proxies)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SYSTEM_PROXIES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    *)
+        UNKNOWN_OPT=yes
+        ;;
+    esac
+    if [ "$UNKNOWN_OPT" = "yes" ]; then
+        echo "${CURRENT_OPT}: invalid command-line switch"
+        OPT_HELP=yes
+        ERROR=yes
+    fi
+done
+
+if [ "$CFG_QCONFIG" != "full" ] && [ "$CFG_QT3SUPPORT" = "yes" ]; then
+    echo "Warning: '-qconfig $CFG_QCONFIG' will disable the qt3support library."
+    CFG_QT3SUPPORT="no"
+fi
+if [ "$CFG_GUI" = "no" ]; then
+    echo "Warning: -no-gui will disable the qt3support library."
+    CFG_QT3SUPPORT="no"
+fi
+
+#disable Qt3Support for Lighthouse
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    CFG_QT3SUPPORT="no"
+fi
+
+# update QT_CONFIG to show our current predefined configuration
+case "$CFG_QCONFIG" in
+minimal|small|medium|large|full)
+    # these are a sequence of increasing functionality
+    for c in minimal small medium large full; do
+        QT_CONFIG="$QT_CONFIG $c-config"
+        [ "$CFG_QCONFIG" = $c ] && break
+    done
+    ;;
+*)
+    # not known to be sufficient for anything
+    if [ '!' -f "$relpath/src/corelib/global/qconfig-${CFG_QCONFIG}.h" ] && [ '!' -f `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` ]; then
+        echo >&2 "Error: configuration file not found:"
+        echo >&2 "  $relpath/src/corelib/global/qconfig-${CFG_QCONFIG}.h"
+        echo >&2 "  or"
+        echo >&2 "  `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"`"
+        OPT_HELP=yes
+    fi
+esac
+
+#-------------------------------------------------------------------------------
+# build tree initialization
+#-------------------------------------------------------------------------------
+
+# where to find which..
+unixtests="$relpath/config.tests/unix"
+mactests="$relpath/config.tests/mac"
+symbiantests="$relpath/config.tests/symbian"
+WHICH="$unixtests/which.test"
+
+PERL=`$WHICH perl 2>/dev/null`
+
+# find out which awk we want to use, prefer gawk, then nawk, then regular awk
+AWK=
+for e in gawk nawk awk; do
+    if "$WHICH" $e >/dev/null 2>&1 && ( $e -f /dev/null /dev/null ) >/dev/null 2>&1; then
+        AWK=$e
+        break
+    fi
+done
+
+# find perl
+PERL="/usr/bin/perl"
+if "$WHICH" perl >/dev/null 2>&1 && ( perl /dev/null ) >/dev/null 2>&1; then
+    PERL=`$WHICH perl`
+fi
+
+### skip this if the user just needs help...
+if [ "$OPT_HELP" != "yes" ]; then
+
+# is this a shadow build?
+if [ "$OPT_SHADOW" = "maybe" ]; then
+    OPT_SHADOW=no
+    if [ "$relpath" != "$outpath" ] && [ '!' -f "$outpath/configure" ]; then
+        if [ -h "$outpath" ]; then
+            [ "$relpath" -ef "$outpath" ] || OPT_SHADOW=yes
+        else
+            OPT_SHADOW=yes
+        fi
+    fi
+fi
+if [ "$OPT_SHADOW" = "yes" ]; then
+    if [ -f "$relpath/.qmake.cache" -o -f "$relpath/src/corelib/global/qconfig.h" -o -f "$relpath/src/corelib/global/qconfig.cpp" ]; then
+        echo >&2 "You cannot make a shadow build from a source tree containing a previous build."
+        echo >&2 "Cannot proceed."
+        exit 1
+    fi
+    [ "$OPT_VERBOSE" = "yes" ] && echo "Performing shadow build..."
+fi
+
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ] && [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    echo
+    echo "WARNING: -debug-and-release is not supported anymore on Qt/X11 and Qt for Embedded Linux"
+    echo "Qt can be built in release mode with separate debug information, so"
+    echo "-debug-and-release is not necessary anymore"
+    echo
+fi
+
+# detect build style
+if [ "$CFG_DEBUG" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" -o "$XPLATFORM_MINGW" = "yes" ]; then
+        CFG_DEBUG_RELEASE=yes
+        CFG_DEBUG=yes
+    elif [ "$CFG_DEV" = "yes" ]; then
+        CFG_DEBUG_RELEASE=no
+        CFG_DEBUG=yes
+    else
+        CFG_DEBUG_RELEASE=no
+        CFG_DEBUG=no
+    fi
+fi
+if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG build_all"
+fi
+
+if [ "$CFG_SILENT" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG silent"
+fi
+
+# if the source tree is different from the build tree,
+# symlink or copy part of the sources
+if [ "$OPT_SHADOW" = "yes" ]; then
+    echo "Preparing build tree..."
+
+    if [ -z "$PERL" ]; then
+        echo
+        echo "You need perl in your PATH to make a shadow build."
+        echo "Cannot proceed."
+        exit 1
+    fi
+
+    [ -d "$outpath/bin" ] || mkdir -p "$outpath/bin"
+
+    # symlink the qmake directory
+    find "$relpath/qmake" | while read a; do
+        my_a=`echo "$a" | sed "s,^${relpath}/,${outpath}/,"`
+        if [ '!' -f "$my_a" ]; then
+            if [ -d "$a" ]; then
+                # directories are created...
+                mkdir -p "$my_a"
+            else
+                a_dir=`dirname "$my_a"`
+                [ -d "$a_dir" ] || mkdir -p "$a_dir"
+                # ... and files are symlinked
+                case `basename "$a"` in
+                *.o|*.d|GNUmakefile*|qmake)
+                    ;;
+                *)
+                    rm -f "$my_a"
+                    ln -s "$a" "$my_a"
+                    ;;
+                esac
+            fi
+        fi
+    done
+
+    # make a syncqt script that can be used in the shadow
+    rm -f "$outpath/bin/syncqt"
+    if [ -x "$relpath/bin/syncqt" ]; then
+        mkdir -p "$outpath/bin"
+        echo "#!/bin/sh" >"$outpath/bin/syncqt"
+        echo "QTDIR=\"$relpath\"; export QTDIR" >>"$outpath/bin/syncqt"
+        echo "perl \"$relpath/bin/syncqt\" -outdir \"$outpath\" \"\$@\"" >>"$outpath/bin/syncqt"
+        chmod 755 "$outpath/bin/syncqt"
+    fi
+
+    for i in elf2e32_qtwrapper createpackage patch_capabilities; do
+        rm -f "$outpath/bin/$i"
+        if [ -x "$relpath/bin/$i" ]; then
+            mkdir -p "$outpath/bin"
+            echo "#!/bin/sh" >"$outpath/bin/$i"
+            echo "QTDIR=\"$relpath\"; export QTDIR" >>"$outpath/bin/$i"
+            echo "\"$relpath/bin/$i\" \"\$@\"" >>"$outpath/bin/$i"
+            chmod 755 "$outpath/bin/$i"
+        fi
+    done
+
+    # symlink the mkspecs directory
+    mkdir -p "$outpath/mkspecs"
+    rm -rf "$outpath"/mkspecs/*
+    ln -s "$relpath"/mkspecs/* "$outpath/mkspecs"
+    rm -f "$outpath/mkspecs/default"
+
+    ShadowMkspecs()
+    {
+        rm -rf "$outpath/mkspecs/$1"
+        find "$relpath/mkspecs/$1" -type d | sed "s,^$relpath,$outpath," | xargs mkdir -p
+        find "$relpath/mkspecs/$1" -type f | sed "s,^$relpath/,," | while read f; do ln -s "$relpath/$f" "$outpath/$f"; done
+    }
+
+    # Special case for mkspecs/features directory.
+    # To be able to place .prf files into a shadow build directory,
+    # we're creating links for files only. The directory structure is reproduced.
+    ShadowMkspecs features
+
+    # The modules dir is special, too.
+    ShadowMkspecs modules
+
+    # symlink the doc directory
+    rm -rf "$outpath/doc"
+    ln -s "$relpath/doc" "$outpath/doc"
+
+    # make sure q3porting.xml can be found
+    mkdir -p "$outpath/tools/porting/src"
+    rm -f "$outpath/tools/porting/src/q3porting.xml"
+    ln -s "$relpath/tools/porting/src/q3porting.xml" "$outpath/tools/porting/src"
+fi
+
+# symlink fonts to be able to run application from build directory
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ] && [ ! -d "${outpath}/lib/fonts" ]; then
+    if [ "$PLATFORM" = "$XPLATFORM" ]; then
+        mkdir -p "${outpath}/lib"
+        ln -s "${relpath}/lib/fonts" "${outpath}/lib/fonts"
+    fi
+fi
+
+if [ "$OPT_FAST" = "auto" ]; then
+   if [ '!' -z "$AWK" ] && [ "$CFG_DEV" = "yes" ]; then
+       OPT_FAST=yes
+   else
+       OPT_FAST=no
+   fi
+fi
+
+# find a make command
+if [ -z "$MAKE" ]; then
+    MAKE=
+    for mk in gmake make; do
+        if "$WHICH" $mk >/dev/null 2>&1; then
+            MAKE=`"$WHICH" $mk`
+            break
+        fi
+    done
+    if [ -z "$MAKE" ]; then
+        echo >&2 "You don't seem to have 'make' or 'gmake' in your PATH."
+        echo >&2 "Cannot proceed."
+        exit 1
+    fi
+    # export MAKE, we need it later in the config.tests
+    export MAKE
+fi
+
+fi ### help
+
+#-------------------------------------------------------------------------------
+# auto-detect all that hasn't been specified in the arguments
+#-------------------------------------------------------------------------------
+
+[ "$PLATFORM_QWS" = "yes" -a "$CFG_EMBEDDED" = "no" ] && CFG_EMBEDDED=auto
+if [ "$CFG_EMBEDDED" != "no" ]; then
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+    Darwin:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/macx-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/macx-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    FreeBSD:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/freebsd-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/freebsd-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    SunOS:5*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/solaris-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/solaris-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    Linux:*)
+        if [ -z "$PLATFORM" ]; then
+            case "$UNAME_MACHINE" in
+            *86)
+                PLATFORM=qws/linux-x86-g++
+                ;;
+            *86_64)
+                PLATFORM=qws/linux-x86_64-g++
+                ;;
+            *)
+                PLATFORM=qws/linux-generic-g++
+                ;;
+            esac
+        fi
+        if [ -z "$XPLATFORM" ]; then
+            if [ "$CFG_EMBEDDED" = "auto" ]; then
+                if [ -n "$CFG_ARCH" ]; then
+                    CFG_EMBEDDED=$CFG_ARCH
+                else
+                    case "$UNAME_MACHINE" in
+                    *86)
+                        CFG_EMBEDDED=x86
+                        ;;
+                    *86_64)
+                        CFG_EMBEDDED=x86_64
+                        ;;
+                    *)
+                        CFG_EMBEDDED=generic
+                        ;;
+                    esac
+                fi
+            fi
+            XPLATFORM="qws/linux-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    QNX:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/qnx-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/qnx-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    CYGWIN*:*)
+	if [ -z "$XPLATFORM" ]; then
+		CFG_EMBEDDED=x86
+	fi
+	;;
+    *)
+        echo "Qt for Embedded Linux is not supported on this platform. Disabling."
+        CFG_EMBEDDED=no
+        PLATFORM_QWS=no
+        PLATFORM_QPA=no
+        ;;
+    esac
+fi
+if [ -z "$PLATFORM" ]; then
+    PLATFORM_NOTES=
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+     Darwin:*)
+        if [ "$PLATFORM_MAC" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+          PLATFORM=macx-g++
+        # PLATFORM=macx-xcode
+        else
+          PLATFORM=darwin-g++
+        fi
+        ;;
+     AIX:*)
+        #PLATFORM=aix-g++
+        #PLATFORM=aix-g++-64
+        PLATFORM=aix-xlc
+        #PLATFORM=aix-xlc-64
+        PLATFORM_NOTES="
+            - Also available for AIX: aix-g++ aix-g++-64 aix-xlc-64
+        "
+        ;;
+     GNU:*)
+        PLATFORM=hurd-g++
+        ;;
+     dgux:*)
+        PLATFORM=dgux-g++
+        ;;
+#     DYNIX/ptx:4*)
+#       PLATFORM=dynix-g++
+#       ;;
+     ULTRIX:*)
+        PLATFORM=ultrix-g++
+        ;;
+     FreeBSD:*)
+        PLATFORM=freebsd-g++
+        PLATFORM_NOTES="
+            - Also available for FreeBSD: freebsd-icc
+        "
+        ;;
+     OpenBSD:*)
+        PLATFORM=openbsd-g++
+        ;;
+     NetBSD:*)
+        PLATFORM=netbsd-g++
+        ;;
+     BSD/OS:*|BSD/386:*)
+        PLATFORM=bsdi-g++
+        ;;
+     IRIX*:*)
+        #PLATFORM=irix-g++
+        PLATFORM=irix-cc
+        #PLATFORM=irix-cc-64
+        PLATFORM_NOTES="
+            - Also available for IRIX: irix-g++ irix-cc-64
+        "
+        ;;
+     HP-UX:*)
+        case "$UNAME_MACHINE" in
+            ia64)
+                #PLATFORM=hpuxi-acc-32
+                PLATFORM=hpuxi-acc-64
+                PLATFORM_NOTES="
+                    - Also available for HP-UXi: hpuxi-acc-32
+                "
+            ;;
+            *)
+                #PLATFORM=hpux-g++
+                PLATFORM=hpux-acc
+                #PLATFORM=hpux-acc-64
+                #PLATFORM=hpux-cc
+                #PLATFORM=hpux-acc-o64
+                PLATFORM_NOTES="
+                    - Also available for HP-UX: hpux-g++ hpux-acc-64 hpux-acc-o64
+                "
+            ;;
+        esac
+        ;;
+     OSF1:*)
+        #PLATFORM=tru64-g++
+        PLATFORM=tru64-cxx
+        PLATFORM_NOTES="
+            - Also available for Tru64: tru64-g++
+        "
+        ;;
+     Linux:*)
+        PLATFORM=linux-g++
+        PLATFORM_NOTES="
+            - Also available for Linux: linux-kcc linux-icc linux-cxx
+        "
+        ;;
+     SunOS:5*)
+        if [ "$XPLATFORM_MINGW" = "yes" ]; then
+            PLATFORM="solaris-g++"
+        else
+            #PLATFORM=solaris-g++
+            PLATFORM=solaris-cc
+            #PLATFORM=solaris-cc64
+        fi
+        PLATFORM_NOTES="
+            - Also available for Solaris: solaris-g++ solaris-cc-64
+        "
+        ;;
+     ReliantUNIX-*:*|SINIX-*:*)
+        PLATFORM=reliant-cds
+        #PLATFORM=reliant-cds-64
+        PLATFORM_NOTES="
+            - Also available for Reliant UNIX: reliant-cds-64
+        "
+        ;;
+     CYGWIN*:*)
+        PLATFORM=cygwin-g++
+        ;;
+     LynxOS*:*)
+        PLATFORM=lynxos-g++
+        ;;
+     OpenUNIX:*)
+        #PLATFORM=unixware-g++
+        PLATFORM=unixware-cc
+        PLATFORM_NOTES="
+            - Also available for OpenUNIX: unixware-g++
+        "
+        ;;
+     UnixWare:*)
+        #PLATFORM=unixware-g++
+        PLATFORM=unixware-cc
+        PLATFORM_NOTES="
+            - Also available for UnixWare: unixware-g++
+        "
+        ;;
+     SCO_SV:*)
+        #PLATFORM=sco-g++
+        PLATFORM=sco-cc
+        PLATFORM_NOTES="
+            - Also available for SCO OpenServer: sco-g++
+        "
+        ;;
+     UNIX_SV:*)
+        PLATFORM=unixware-g++
+        ;;
+     QNX:*)
+        PLATFORM=unsupported/qnx-g++
+        ;;
+     *)
+        if [ "$OPT_HELP" != "yes" ]; then
+            echo
+            for p in $PLATFORMS; do
+                echo "    $relconf $* -platform $p"
+            done
+            echo >&2
+            echo "   The build script does not currently recognize all" >&2
+            echo "   platforms supported by Qt." >&2
+            echo "   Rerun this script with a -platform option listed to" >&2
+            echo "   set the system/compiler combination you use." >&2
+            echo >&2
+            exit 2
+        fi
+    esac
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    CFG_SM=no
+    PLATFORMS=`find "$relpath/mkspecs/qws" | sed "s,$relpath/mkspecs/qws/,,"`
+else
+    PLATFORMS=`find "$relpath/mkspecs/" -type f | grep -v qws | sed "s,$relpath/mkspecs/qws/,,"`
+fi
+
+[ -z "$XPLATFORM" ] && XPLATFORM="$PLATFORM"
+
+case `basename "$XPLATFORM"` in win32-g++*) XPLATFORM_MINGW=yes;; esac
+case "$XPLATFORM" in *integrity*) XPLATFORM_INTEGRITY=yes;; esac
+case "$XPLATFORM" in *symbian*) XPLATFORM_SYMBIAN=yes;; esac
+case "$XPLATFORM" in symbian-sbsv2) XPLATFORM_SYMBIAN_SBSV2=yes;; esac
+case "$XPLATFORM" in *qnx-*|*blackberry-*) XPLATFORM_QNX=yes;; esac
+
+if [ -d "$PLATFORM" ]; then
+  QMAKESPEC="$PLATFORM"
+else
+  QMAKESPEC="$relpath/mkspecs/${PLATFORM}"
+fi
+if [ -d "$XPLATFORM" ]; then
+  XQMAKESPEC="$XPLATFORM"
+else
+  XQMAKESPEC="$relpath/mkspecs/${XPLATFORM}"
+fi
+if [ "$PLATFORM" != "$XPLATFORM" ]; then
+    QT_CROSS_COMPILE=yes
+    QMAKE_CONFIG="$QMAKE_CONFIG cross_compile"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG cross_compile"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+   if [ `basename $QMAKESPEC` = "macx-xcode" ] || [ `basename $XQMAKESPEC` = "macx-xcode" ]; then
+      echo >&2
+      echo "   Platform 'macx-xcode' should not be used when building Qt/Mac." >&2
+      echo "   Please build Qt/Mac with 'macx-g++', then if you would like to" >&2
+      echo "   use mac-xcode on your application code it can link to a Qt/Mac" >&2
+      echo "   built with 'macx-g++'" >&2
+      echo >&2
+      exit 2
+    fi
+fi
+
+# check specified platforms are supported
+if [ '!' -d "$QMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "      $QMAKESPEC"
+    echo
+    echo "   Please see the README file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -d "$XQMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "      $XQMAKESPEC"
+    echo
+    echo "   Please see the README file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -f "${XQMAKESPEC}/qplatformdefs.h" ]; then
+    echo
+    echo "   The specified system/compiler port is not complete:"
+    echo
+    echo "      $XQMAKESPEC/qplatformdefs.h"
+    echo
+    echo "   Please contact qt-bugs@trolltech.com."
+    echo
+    exit 2
+fi
+
+# now look at the configs and figure out what platform we are config'd for
+[ "$CFG_EMBEDDED" = "no" ] && [ "$PLATFORM_QPA" != "yes" ] \
+  && [ -n "`getXQMakeConf QMAKE_LIBS_X11`" ] \
+  && PLATFORM_X11=yes
+### echo "$XQMAKESPEC" | grep mkspecs/qws >/dev/null 2>&1 && PLATFORM_QWS=yes
+
+if [ "$UNAME_SYSTEM" = "SunOS" ]; then
+    # Solaris 2.5 and 2.6 have libposix4, which was renamed to librt for Solaris 7 and up
+    if echo $UNAME_RELEASE | grep "^5\.[5|6]" >/dev/null 2>&1; then
+        sed -e "s,-lrt,-lposix4," "$XQMAKESPEC/qmake.conf" > "$XQMAKESPEC/qmake.conf.new"
+        mv "$XQMAKESPEC/qmake.conf.new" "$XQMAKESPEC/qmake.conf"
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# determine the system architecture
+#-------------------------------------------------------------------------------
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo "Determining system architecture... ($UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_MACHINE)"
+fi
+
+if [ "$CFG_EMBEDDED" != "no" -a "$CFG_EMBEDDED" != "auto" ] && [ -n "$CFG_ARCH" ]; then
+    if [ "$CFG_ARCH" != "$CFG_EMBEDDED" ]; then
+        echo ""
+        echo "You have specified a target architecture with -embedded and -arch."
+        echo "The two architectures you have specified are different, so we can"
+        echo "not proceed. Either set both to be the same, or only use -embedded."
+        echo ""
+        exit 1
+    fi
+fi
+
+if [ "$CFG_RTOS_ENABLED" = "no" ]; then
+    case `basename "$XPLATFORM"` in
+	qnx-* | vxworks-*)
+            echo ""
+            echo "You are not licensed for Qt for `basename $XPLATFORM`."
+            echo ""
+            echo "Please contact qt-info@nokia.com to upgrade your license to"
+            echo "include this platform, or install the Qt Open Source Edition"
+            echo "if you intend to develop free software."
+            exit 1
+	    ;;
+    esac
+fi
+
+if [ -z "${CFG_HOST_ARCH}" ]; then
+    case "$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_MACHINE" in
+    GNU:*:*)
+        CFG_HOST_ARCH=`echo ${UNAME_MACHINE} | sed -e 's,[-/].*$,,'`
+        case "$CFG_HOST_ARCH" in
+            i?86)
+                CFG_HOST_ARCH=i386
+                ;;
+        esac
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    GNU/Hurd ($CFG_HOST_ARCH)"
+        fi
+        ;;
+    IRIX*:*:*)
+        CFG_HOST_ARCH=`uname -p`
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    SGI ($CFG_HOST_ARCH)"
+        fi
+        ;;
+    SunOS:5*:*)
+        case "$UNAME_MACHINE" in
+	sun4u*|sun4v*)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    Sun SPARC (sparc)"
+            fi
+            CFG_HOST_ARCH=sparc
+            ;;
+        i86pc)
+	    case "$PLATFORM" in
+	    *-64*)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+	            echo "    64-bit AMD 80x86 (x86_64)"
+                fi
+                CFG_HOST_ARCH=x86_64
+                ;;
+	    *)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+	            echo "    32-bit Intel 80x86 (i386)"
+                fi
+                CFG_HOST_ARCH=i386
+                ;;
+            esac
+        esac
+        ;;
+    Darwin:*:*)
+        case "$UNAME_MACHINE" in
+            Power?Macintosh)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+                    echo "    32-bit Apple PowerPC (powerpc)"
+                fi
+                ;;
+            x86)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+                    echo "    32-bit Intel 80x86 (i386)"
+                fi
+                ;;
+        esac
+        CFG_HOST_ARCH=macosx
+        ;;
+    AIX:*:00????????00)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    64-bit IBM PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    HP-UX:*:9000*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    HP PA-RISC (parisc)"
+        fi
+        CFG_HOST_ARCH=parisc
+        ;;
+    *:*:i?86)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    32-bit Intel 80x86 (i386)"
+        fi
+        CFG_HOST_ARCH=i386
+        ;;
+    *:*:x86_64|*:*:amd64)
+        if [ "$PLATFORM" = "linux-g++-32" -o "$PLATFORM" = "linux-icc-32" ]; then
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    32 bit on 64-bit AMD 80x86 (i386)"
+            fi
+            CFG_HOST_ARCH=i386
+        else
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    64-bit AMD 80x86 (x86_64)"
+            fi
+            CFG_HOST_ARCH=x86_64
+        fi
+        ;;
+    *:*:ppc)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    32-bit PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    *:*:ppc64)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    64-bit PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    *:*:s390*)
+    	if [ "$OPT_VERBOSE" = "yes" ]; then
+    	    echo "    IBM S/390 (s390)"
+    	fi
+    	CFG_HOST_ARCH=s390
+    	;;
+    *:*:arm*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    ARM (arm)"
+        fi
+        CFG_HOST_ARCH=arm
+        ;;
+    Linux:*:sparc*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    Linux on SPARC"
+        fi
+        CFG_HOST_ARCH=sparc
+        ;;
+    QNX:*:*)
+        case "$UNAME_MACHINE" in
+        x86pc)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    QNX on Intel 80x86 (i386)"
+            fi
+            CFG_HOST_ARCH=i386
+            ;;
+        esac
+        ;;
+    *:*:*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    Trying '$UNAME_MACHINE'..."
+        fi
+        CFG_HOST_ARCH="$UNAME_MACHINE"
+        ;;
+    esac
+fi
+
+if [ "$PLATFORM" != "$XPLATFORM" -a "$CFG_EMBEDDED" != "no" ]; then
+    if [ -n "$CFG_ARCH" ]; then
+        CFG_EMBEDDED=$CFG_ARCH
+    fi
+
+    case "$CFG_EMBEDDED" in
+    x86)
+        CFG_ARCH=i386
+        ;;
+    x86_64)
+        CFG_ARCH=x86_64
+        ;;
+    ipaq|sharp)
+        CFG_ARCH=arm
+        ;;
+    dm7000)
+        CFG_ARCH=powerpc
+        ;;
+    dm800)
+        CFG_ARCH=mips
+        ;;
+    sh4al)
+        CFG_ARCH=sh4a
+        ;;
+    arm*)
+        CFG_ARCH=arm
+        ;;
+    *)
+        CFG_ARCH="$CFG_EMBEDDED"
+        ;;
+    esac
+elif [ "$XPLATFORM_MINGW" = "yes" ]; then
+    [ -z "$CFG_ARCH" ] && CFG_ARCH="windows"
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    CFG_ARCH=integrity
+elif [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    CFG_ARCH=symbian
+elif [ "$PLATFORM_MAC" = "yes" ] || [ -z "$CFG_ARCH" ]; then
+    CFG_ARCH=$CFG_HOST_ARCH
+fi
+
+# for compatibility
+COMPAT_ARCH=
+case "$CFG_ARCH" in
+arm*)
+    # previously, armv6 was a different arch
+    CFG_ARCH=arm
+    COMPAT_ARCH=armv6
+    ;;
+esac
+
+if [ -d "$relpath/src/corelib/arch/$CFG_ARCH" ]; then
+    if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    '$CFG_ARCH' is supported"
+    fi
+else
+    if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    '$CFG_ARCH' is unsupported, using 'generic'"
+    fi
+    CFG_ARCH=generic
+fi
+if [ "$CFG_HOST_ARCH" != "$CFG_ARCH" ]; then
+    if [ -d "$relpath/src/corelib/arch/$CFG_HOST_ARCH" ]; then
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    '$CFG_HOST_ARCH' is supported"
+        fi
+    else
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    '$CFG_HOST_ARCH' is unsupported, using 'generic'"
+        fi
+        CFG_HOST_ARCH=generic
+    fi
+fi
+
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo "System architecture: '$CFG_ARCH'"
+    if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+	echo "Host architecture: '$CFG_HOST_ARCH'"
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# tests that don't need qmake (must be run before displaying help)
+#-------------------------------------------------------------------------------
+
+# process CFG_MAC_ARCHS
+if [ "$PLATFORM_MAC" = "yes" ]; then
+#   check -arch arguments for validity.
+    ALLOWED="x86 ppc x86_64 ppc64 i386 arm armv6 armv7"
+    # Save the list so we can re-write it using only valid values
+    CFG_MAC_ARCHS_IN="$CFG_MAC_ARCHS"
+    CFG_MAC_ARCHS=
+    for i in $CFG_MAC_ARCHS_IN
+    do 
+        if echo "$ALLOWED" | grep -w -v "$i" > /dev/null 2>&1; then
+            echo "Unknown architecture: \"$i\". Supported architectures: x86[i386] ppc x86_64 ppc64 arm armv6 armv7";
+            exit 2;
+        fi
+        if [ "$i" = "i386" -o "$i" = "x86" ]; then
+            # These are synonymous values
+            # CFG_MAC_ARCHS requires x86 while GCC requires i386
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS x86"
+            MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -arch i386"
+        else
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS $i"
+            MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -arch $i"
+        fi
+    done
+fi
+
+# pass on $CFG_SDK to the configure tests.
+if [ '!' -z "$CFG_SDK" ]; then
+    MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -sdk $CFG_SDK"
+fi
+
+# find the default framework value
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$PLATFORM" != "macx-xlc" ]; then
+    if [ "$CFG_FRAMEWORK" = "auto" ]; then
+        CFG_FRAMEWORK="$CFG_SHARED"
+    elif [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_SHARED" = "no" ]; then
+	echo
+	echo "WARNING: Using static linking will disable the use of Mac frameworks."
+	echo
+        CFG_FRAMEWORK="no"
+    fi
+else
+    CFG_FRAMEWORK=no
+fi
+
+QMAKE_CONF_COMPILER=`getXQMakeConf QMAKE_CXX`
+TEST_COMPILER="$CXX"
+
+[ -z "$TEST_COMPILER" ] && TEST_COMPILER=$QMAKE_CONF_COMPILER
+if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    #for Symbian we don't need this checking
+    if [ -z "$TEST_COMPILER" ]; then
+        echo "ERROR: Cannot set the compiler for the configuration tests"
+        exit 1
+    fi
+fi
+
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    TEST_COMPILER="nacl-gcc"
+fi
+
+SYSROOT_FLAG=
+if [ -n "$CFG_SYSROOT" ]; then
+    if compilerSupportsFlag $TEST_COMPILER -c --sysroot="$CFG_SYSROOT"; then
+	[ "$OPT_VERBOSE" = "yes" ] && echo "Setting sysroot to: $CFG_SYSROOT"
+	SYSROOT_FLAG="--sysroot=$CFG_SYSROOT"
+    else
+	echo >&2 "The compiler doesn't support the --sysroot flag, I can't set the sysroot"
+	exit 1
+    fi
+fi
+export SYSROOT_FLAG    # used by config.tests/unix/compile.test
+
+# auto-detect precompiled header support
+if [ "$CFG_PRECOMPILE" = "auto" ]; then
+    if [ `echo "$CFG_MAC_ARCHS" | wc -w` -gt 1 ]; then
+       CFG_PRECOMPILE=no
+    elif "$unixtests/precomp.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+       CFG_PRECOMPILE=no
+    else
+       CFG_PRECOMPILE=yes
+    fi
+elif [ "$CFG_PRECOMPILE" = "yes" ] && [ `echo "$CFG_MAC_ARCHS" | wc -w` -gt 1 ]; then
+    echo
+    echo "WARNING: Using universal binaries disables precompiled headers."
+    echo
+    CFG_PRECOMPILE=no
+fi
+
+if [ "$XPLATFORM_MINGW" = "yes" ]; then
+    CFG_MAC_DWARF2=no
+    CFG_MAC_XARCH=no
+fi
+
+#auto-detect DWARF2 on the mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_DWARF2" = "auto" ]; then
+    if "$mactests/dwarf2.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests" $MAC_CONFIG_TEST_COMMANDLINE; then
+        CFG_MAC_DWARF2=no
+    else
+        CFG_MAC_DWARF2=yes
+    fi
+fi
+
+# auto-detect support for -Xarch on the mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_XARCH" = "auto" ]; then
+    if "$mactests/xarch.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests" ; then
+        CFG_MAC_XARCH=no
+    else
+        CFG_MAC_XARCH=yes
+    fi
+fi
+
+# don't autodetect support for separate debug info on objcopy when
+# cross-compiling as lots of toolchains seems to have problems with this
+if [ "$QT_CROSS_COMPILE" = "yes" ] && [ "$CFG_SEPARATE_DEBUG_INFO" = "auto" ]; then
+    CFG_SEPARATE_DEBUG_INFO="no"
+fi
+
+# auto-detect support for separate debug info in objcopy
+if [ "$CFG_SEPARATE_DEBUG_INFO" != "no" ] && [ "$CFG_SHARED" = "yes" ]; then
+    TEST_COMPILER_CFLAGS=`getXQMakeConf QMAKE_CFLAGS`
+    TEST_COMPILER_CXXFLAGS=`getXQMakeConf QMAKE_CXXFLAGS`
+    TEST_OBJCOPY=`getXQMakeConf QMAKE_OBJCOPY`
+    COMPILER_WITH_FLAGS="$TEST_COMPILER $TEST_COMPILER_CXXFLAGS"
+    COMPILER_WITH_FLAGS=`echo "$COMPILER_WITH_FLAGS" | sed -e "s%\\$\\$QMAKE_CFLAGS%$TEST_COMPILER_CFLAGS%g"`
+    if "$unixtests/objcopy.test" "$COMPILER_WITH_FLAGS" "$TEST_OBJCOPY" "$OPT_VERBOSE"; then
+       CFG_SEPARATE_DEBUG_INFO=no
+    else
+       case "$PLATFORM" in
+       hpux-*)
+           # binutils on HP-UX is buggy; default to no.
+           CFG_SEPARATE_DEBUG_INFO=no
+           ;;
+       *)
+           CFG_SEPARATE_DEBUG_INFO=yes
+           ;;
+       esac
+    fi
+fi
+
+# auto-detect -fvisibility support
+if [ "$CFG_REDUCE_EXPORTS" = "auto" ]; then
+    if "$unixtests/fvisibility.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+       CFG_REDUCE_EXPORTS=no
+    else
+       CFG_REDUCE_EXPORTS=yes
+    fi
+fi
+
+# auto-detect -fstack-protector-strong support (for QNX only currently)
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    if compilerSupportsFlag $TEST_COMPILER -fstack-protector-strong; then
+       CFG_STACK_PROTECTOR_STRONG=yes
+    else
+       CFG_STACK_PROTECTOR_STRONG=no
+    fi
+else
+   CFG_STACK_PROTECTOR_STRONG=no
+fi
+
+# detect the availability of the -Bsymbolic-functions linker optimization
+if [ "$CFG_REDUCE_RELOCATIONS" != "no" ]; then
+    if "$unixtests/bsymbolic_functions.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+        CFG_REDUCE_RELOCATIONS=no
+    else
+        CFG_REDUCE_RELOCATIONS=yes
+    fi
+fi
+
+# auto-detect GNU make support
+if [ "$CFG_USE_GNUMAKE" = "auto" ] && "$MAKE" -v | grep "GNU Make" >/dev/null 2>&1; then
+   CFG_USE_GNUMAKE=yes
+fi
+
+# If -opengl wasn't specified, don't try to auto-detect
+if [ "$PLATFORM_QWS" = "yes" ] && [ "$CFG_OPENGL" = "auto" ]; then
+        CFG_OPENGL=no
+fi
+
+# mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        CFG_OPENGL=desktop
+    fi
+fi
+
+# find the default framework value
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$PLATFORM" != "macx-xlc" ]; then
+    if [ "$CFG_FRAMEWORK" = "auto" ]; then
+        CFG_FRAMEWORK="$CFG_SHARED"
+    elif [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_SHARED" = "no" ]; then
+	echo
+	echo "WARNING: Using static linking will disable the use of Mac frameworks."
+	echo
+        CFG_FRAMEWORK="no"
+    fi
+else
+    CFG_FRAMEWORK=no
+fi
+
+# Print a warning if configure was called with the 10.4u SDK option on Snow Leopard
+# with the default mkspec. The 10.4u SDK does not support gcc 4.2.
+if [ "$PLATFORM_MAC" = "yes" ] && [ '!' -z "$CFG_SDK" ]; then
+    # get the darwin version. 10.0.0 and up means snow leopard.
+    VERSION=`uname -r | tr '.' ' ' | awk '{print $1}'`
+    if [ "$VERSION" -gt 9 ] && [ `basename "$CFG_SDK"` == "MacOSX10.4u.sdk" ] && [ "$PLATFORM" == "macx-g++" ]; then
+        echo
+        echo "WARNING: The 10.4u SDK does not support gcc 4.2. Configure with -platform macx-g++40. "
+        echo
+    fi
+fi
+
+# x11 tests are done after qmake is built
+
+
+#setup the build parts
+if [ -z "$CFG_BUILD_PARTS" ]; then
+    CFG_BUILD_PARTS="$QT_DEFAULT_BUILD_PARTS"
+
+    # don't build tools by default when cross-compiling
+    if [ "$PLATFORM" != "$XPLATFORM" ]; then
+	CFG_BUILD_PARTS=`echo "$CFG_BUILD_PARTS" | sed "s, tools,,g"`
+    fi
+fi
+for nobuild in $CFG_NOBUILD_PARTS; do
+    CFG_BUILD_PARTS=`echo "$CFG_BUILD_PARTS" | sed "s, $nobuild,,g"`
+done
+if echo $CFG_BUILD_PARTS | grep -v libs >/dev/null 2>&1; then
+#    echo
+#    echo "WARNING: libs is a required part of the build."
+#    echo
+    CFG_BUILD_PARTS="$CFG_BUILD_PARTS libs"
+fi
+
+#-------------------------------------------------------------------------------
+# post process QT_INSTALL_* variables
+#-------------------------------------------------------------------------------
+
+#prefix
+if [ -z "$QT_INSTALL_PREFIX" ]; then
+    if [ "$CFG_DEV" = "yes" ]; then
+        QT_INSTALL_PREFIX="$outpath" # In Development, we use sandboxed builds by default
+    elif [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+        if [ "$PLATFORM_QPA" = "yes" ]; then
+	QT_INSTALL_PREFIX="/usr/local/Trolltech/QtLighthouse-${QT_VERSION}"
+        else
+	QT_INSTALL_PREFIX="/usr/local/Trolltech/QtEmbedded-${QT_VERSION}"
+        fi
+        if [ "$PLATFORM" != "$XPLATFORM" ]; then
+            case "$XPLATFORM" in
+            *dkm*)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}-dkm" # VxWorks DKM
+                ;;
+            *rtp*)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}-rtp" # VxWorks RTP
+                ;;
+            *)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}"
+                ;;
+            esac
+        fi
+    elif [ -d "$EPOCROOT" ] && [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+            QT_INSTALL_PREFIX="$EPOCROOT/epoc32/"
+            QT_INSTALL_LIBS="$EPOCROOT/epoc32/release/armv5/lib/"
+        fi
+    else
+        QT_INSTALL_PREFIX="/usr/local/Trolltech/Qt-${QT_VERSION}" # the default install prefix is /usr/local/Trolltech/Qt-$QT_VERSION
+    fi
+fi
+QT_INSTALL_PREFIX=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_PREFIX"`
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    [ -z "$QT_HOST_PREFIX" ] && QT_HOST_PREFIX="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS=
+    [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS=
+    [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS=
+    [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS=
+    [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="\\\\resource\\\\qt$QT_LIBINFIX\\\\plugins"
+    [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="\\\\resource\\\\qt$QT_LIBINFIX\\\\imports"
+    [ -z "$QT_INSTALL_DATA" ] && QT_INSTALL_DATA=
+    [ -z "$QT_INSTALL_TRANSLATIONS" ] && QT_INSTALL_TRANSLATIONS="\\\\resource\\\\qt$QT_LIBINFIX\\\\translations"
+    [ -z "$QT_INSTALL_SETTINGS" ] && QT_INSTALL_SETTINGS=
+    [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES=
+    [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS=
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    [ -z "$QT_HOST_PREFIX" ] && QT_HOST_PREFIX="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS="$QT_INSTALL_PREFIX/doc"
+    [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS="$QT_INSTALL_PREFIX/include"
+    [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS="$QT_INSTALL_PREFIX/lib"
+    [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS="$QT_INSTALL_PREFIX/bin"
+    [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="$QT_INSTALL_PREFIX/plugins"
+    [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="$QT_INSTALL_PREFIX/imports"
+    [ -z "$QT_INSTALL_DATA" ] && QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_TRANSLATIONS" ] && QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+    [ -z "$QT_INSTALL_SETTINGS" ] && QT_INSTALL_SETTINGS="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES="$QT_INSTALL_PREFIX/examples"
+    [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS="$QT_INSTALL_PREFIX/demos"
+else
+    #docs
+    if [ -z "$QT_INSTALL_DOCS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_DOCS="/Developer/Documentation/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS="$QT_INSTALL_PREFIX/doc" #fallback
+
+    fi
+    QT_INSTALL_DOCS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DOCS"`
+
+    #headers
+    if [ -z "$QT_INSTALL_HEADERS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        if [ "$CFG_FRAMEWORK" = "yes" ]; then
+		    QT_INSTALL_HEADERS=
+                fi
+            fi
+        fi
+        [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS="$QT_INSTALL_PREFIX/include"
+
+    fi
+    QT_INSTALL_HEADERS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_HEADERS"`
+
+    #libs
+    if [ -z "$QT_INSTALL_LIBS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        if [ "$CFG_FRAMEWORK" = "yes" ]; then
+                   QT_INSTALL_LIBS="/Library/Frameworks"
+                fi
+            fi
+        fi
+        [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS="$QT_INSTALL_PREFIX/lib" #fallback
+    fi
+    QT_INSTALL_LIBS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_LIBS"`
+
+    #bins
+    if [ -z "$QT_INSTALL_BINS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_BINS="/Developer/Applications/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS="$QT_INSTALL_PREFIX/bin" #fallback
+
+    fi
+    QT_INSTALL_BINS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_BINS"`
+
+    #plugins
+    if [ -z "$QT_INSTALL_PLUGINS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_PLUGINS="/Developer/Applications/Qt/plugins"
+            fi
+        fi
+        [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="$QT_INSTALL_PREFIX/plugins" #fallback
+    fi
+    QT_INSTALL_PLUGINS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_PLUGINS"`
+
+    #imports
+    if [ -z "$QT_INSTALL_IMPORTS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_IMPORTS="/Developer/Applications/Qt/imports"
+            fi
+        fi
+        [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="$QT_INSTALL_PREFIX/imports" #fallback
+    fi
+    QT_INSTALL_IMPORTS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_IMPORTS"`
+
+    #data
+    if [ -z "$QT_INSTALL_DATA" ]; then #default
+        QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+    fi
+    QT_INSTALL_DATA=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DATA"`
+
+    #translations
+    if [ -z "$QT_INSTALL_TRANSLATIONS" ]; then #default
+        QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+    fi
+    QT_INSTALL_TRANSLATIONS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_TRANSLATIONS"`
+
+    #settings
+    if [ -z "$QT_INSTALL_SETTINGS" ]; then #default
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+	    QT_INSTALL_SETTINGS=/Library/Preferences/Qt
+        else
+	    QT_INSTALL_SETTINGS=/etc/xdg
+        fi
+    fi
+    QT_INSTALL_SETTINGS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_SETTINGS"`
+
+    #examples
+    if [ -z "$QT_INSTALL_EXAMPLES" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_EXAMPLES="/Developer/Examples/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES="$QT_INSTALL_PREFIX/examples" #fallback
+    fi
+    QT_INSTALL_EXAMPLES=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_EXAMPLES"`
+
+    #demos
+    if [ -z "$QT_INSTALL_DEMOS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_DEMOS="/Developer/Examples/Qt/Demos"
+            fi
+        fi
+        [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS="$QT_INSTALL_PREFIX/demos"
+    fi
+    QT_INSTALL_DEMOS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DEMOS"`
+fi
+
+#-------------------------------------------------------------------------------
+# help - interactive parts of the script _after_ this section please
+#-------------------------------------------------------------------------------
+
+# next, emit a usage message if something failed.
+if [ "$OPT_HELP" = "yes" ]; then
+    [ "x$ERROR" = "xyes" ] && echo
+    if [ "$CFG_NIS" = "no" ]; then
+        NSY=" "
+        NSN="*"
+    else
+        NSY="*"
+        NSN=" "
+    fi
+    if [ "$CFG_CUPS" = "no" ]; then
+        CUY=" "
+        CUN="*"
+    else
+        CUY="*"
+        CUN=" "
+    fi
+    if [ "$CFG_ICONV" = "no" ]; then
+        CIY=" "
+        CIN="*"
+    else
+        CIY="*"
+        CIN=" "
+    fi
+    if [ "$CFG_LARGEFILE" = "no" ]; then
+        LFSY=" "
+        LFSN="*"
+    else
+        LFSY="*"
+        LFSN=" "
+    fi
+    if [ "$CFG_STL" = "auto" ] || [ "$CFG_STL" = "yes" ]; then
+        SHY="*"
+        SHN=" "
+    else
+        SHY=" "
+        SHN="*"
+    fi
+    if [ "$CFG_IPV6" = "auto" ]; then
+        I6Y="*"
+        I6N=" "
+    fi
+    if [ "$CFG_PRECOMPILE" = "auto" ] || [ "$CFG_PRECOMPILE" = "no" ]; then
+        PHY=" "
+        PHN="*"
+    else
+        PHY="*"
+        PHN=" "
+    fi
+
+    cat <<EOF
+Usage:  $relconf [-h] [-prefix <dir>] [-prefix-install] [-bindir <dir>] [-libdir <dir>]
+        [-docdir <dir>] [-headerdir <dir>] [-plugindir <dir> ] [-importdir <dir>] [-datadir <dir>]
+        [-translationdir <dir>] [-sysconfdir <dir>] [-examplesdir <dir>]
+        [-demosdir <dir>] [-buildkey <key>] [-release] [-debug]
+        [-debug-and-release] [-developer-build] [-shared] [-static] [-no-fast] [-fast] [-no-largefile]
+        [-largefile] [-no-exceptions] [-exceptions] [-no-accessibility]
+        [-accessibility] [-no-stl] [-stl] [-no-sql-<driver>] [-sql-<driver>]
+        [-plugin-sql-<driver>] [-system-sqlite] [-no-qt3support] [-qt3support]
+        [-platform] [-D <string>] [-I <string>] [-L <string>] [-help]
+        [-qt-zlib] [-system-zlib] [-no-gif] [-no-libtiff] [-qt-libtiff] [-system-libtiff]
+        [-no-libpng] [-qt-libpng] [-system-libpng] [-no-libmng] [-qt-libmng]
+        [-system-libmng] [-no-libjpeg] [-qt-libjpeg] [-system-libjpeg] [-make <part>]
+        [-nomake <part>] [-R <string>]  [-l <string>] [-no-rpath]  [-rpath] [-continue]
+        [-verbose] [-v] [-silent] [-no-nis] [-nis] [-no-cups] [-cups] [-no-iconv]
+        [-iconv] [-no-pch] [-pch] [-no-dbus] [-dbus] [-dbus-linked] [-no-gui]
+        [-no-separate-debug-info] [-no-mmx] [-no-3dnow] [-no-sse] [-no-sse2]
+        [-no-sse3] [-no-ssse3] [-no-sse4.1] [-no-sse4.2] [-no-avx] [-no-neon]
+        [-qtnamespace <namespace>] [-qtlibinfix <infix>] [-separate-debug-info] [-armfpa]
+        [-no-optimized-qmake] [-optimized-qmake] [-no-xmlpatterns] [-xmlpatterns]
+        [-no-multimedia] [-multimedia] [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend]
+        [-no-media-backend] [-media-backend] [-no-audio-backend] [-audio-backend] 
+        [-no-openssl] [-openssl] [-openssl-linked]
+        [-no-gtkstyle] [-gtkstyle] [-no-svg] [-svg] [-no-webkit] [-webkit] [-webkit-debug]
+        [-no-javascript-jit] [-javascript-jit]
+        [-no-script] [-script] [-no-scripttools] [-scripttools] 
+        [-no-declarative] [-declarative] [-no-declarative-debug] [-declarative-debug]
+        [additional platform specific options (see below)]
+
+
+Installation options:
+
+    -qpa [name] ......... This will enable the QPA build.
+                          QPA is a window system agnostic implementation of Qt.
+                          If [name] is given, sets the default QPA platform (e.g xcb, cocoa).
+
+ These are optional, but you may specify install directories.
+
+    -prefix <dir> ...... This will install everything relative to <dir>
+                         (default $QT_INSTALL_PREFIX)
+EOF
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+cat <<EOF
+
+    -hostprefix [dir] .. Tools and libraries needed when developing
+                         applications are installed in [dir]. If [dir] is
+                         not given, the current build directory will be used.
+EOF
+fi
+cat <<EOF
+
+  * -prefix-install .... Force a sandboxed "local" installation of
+                         Qt. This will install into
+                         $QT_INSTALL_PREFIX, if this option is
+                         disabled then some platforms will attempt a
+                         "system" install by placing default values
+                         in a system location other than PREFIX.
+
+ You may use these to separate different parts of the install:
+
+    -bindir <dir> ......... Executables will be installed to <dir>
+                            (default PREFIX/bin)
+    -libdir <dir> ......... Libraries will be installed to <dir>
+                            (default PREFIX/lib)
+    -docdir <dir> ......... Documentation will be installed to <dir>
+                            (default PREFIX/doc)
+    -headerdir <dir> ...... Headers will be installed to <dir>
+                            (default PREFIX/include)
+    -plugindir <dir> ...... Plugins will be installed to <dir>
+                            (default PREFIX/plugins)
+    -importdir <dir> ...... Imports for QML will be installed to <dir>
+                            (default PREFIX/imports)
+    -datadir <dir> ........ Data used by Qt programs will be installed to <dir>
+                            (default PREFIX)
+    -translationdir <dir> . Translations of Qt programs will be installed to <dir>
+                            (default PREFIX/translations)
+    -sysconfdir <dir> ..... Settings used by Qt programs will be looked for in <dir>
+                            (default PREFIX/etc/settings)
+    -examplesdir <dir> .... Examples will be installed to <dir>
+                            (default PREFIX/examples)
+    -demosdir <dir> ....... Demos will be installed to <dir>
+                            (default PREFIX/demos)
+
+ You may use these options to turn on strict plugin loading.
+
+    -buildkey <key> .... Build the Qt library and plugins using the specified
+                         <key>.  When the library loads plugins, it will only
+                         load those that have a matching key.
+
+Configure options:
+
+ The defaults (*) are usually acceptable. A plus (+) denotes a default value
+ that needs to be evaluated. If the evaluation succeeds, the feature is
+ included. Here is a short explanation of each option:
+
+ *  -release ........... Compile and link Qt with debugging turned off.
+    -debug ............. Compile and link Qt with debugging turned on.
+    -debug-and-release . Compile and link two versions of Qt, with and without
+                         debugging turned on (Mac only).
+
+    -developer-build ... Compile and link Qt with Qt developer options (including auto-tests exporting)
+
+    -opensource ........ Compile and link the Open-Source Edition of Qt.
+    -commercial ........ Compile and link the Commercial Edition of Qt.
+
+
+ *  -shared ............ Create and use shared Qt libraries.
+    -static ............ Create and use static Qt libraries.
+
+ *  -no-fast ........... Configure Qt normally by generating Makefiles for all
+                         project files.
+    -fast .............. Configure Qt quickly by generating Makefiles only for
+                         library and subdirectory targets.  All other Makefiles
+                         are created as wrappers, which will in turn run qmake.
+
+    -no-largefile ...... Disables large file support.
+ +  -largefile ......... Enables Qt to access files larger than 4 GB.
+
+ *  -no-system-proxies . Do not use system network proxies by default.
+    -system-proxies .... Use system network proxies by default.
+
+EOF
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    EXCN="*"
+    EXCY=" "
+else
+    EXCN=" "
+    EXCY="*"
+fi
+if [ "$CFG_DBUS" = "no" ]; then
+    DBY=" "
+    DBN="+"
+else
+    DBY="+"
+    DBN=" "
+fi
+
+    cat << EOF
+ $EXCN  -no-exceptions ..... Disable exceptions on compilers that support it.
+ $EXCY  -exceptions ........ Enable exceptions on compilers that support it.
+
+    -no-accessibility .. Do not compile Accessibility support.
+ *  -accessibility ..... Compile Accessibility support.
+
+ $SHN  -no-stl ............ Do not compile STL support.
+ $SHY  -stl ............... Compile STL support.
+
+    -no-sql-<driver> ... Disable SQL <driver> entirely.
+    -qt-sql-<driver> ... Enable a SQL <driver> in the QtSql library, by default
+                         none are turned on.
+    -plugin-sql-<driver> Enable SQL <driver> as a plugin to be linked to
+                         at run time.
+
+                         Possible values for <driver>:
+                         [ $CFG_SQL_AVAILABLE ]
+
+    -system-sqlite ..... Use sqlite from the operating system.
+
+    -no-qt3support ..... Disables the Qt 3 support functionality.
+ *  -qt3support ........ Enables the Qt 3 support functionality.
+
+    -no-xmlpatterns .... Do not build the QtXmlPatterns module.
+ +  -xmlpatterns ....... Build the QtXmlPatterns module.
+                         QtXmlPatterns is built if a decent C++ compiler
+                         is used and exceptions are enabled.
+
+    -no-multimedia ..... Do not build the QtMultimedia module.
+ +  -multimedia ........ Build the QtMultimedia module.
+
+    -no-audio-backend .. Do not build the platform audio backend into QtMultimedia.
+ +  -audio-backend ..... Build the platform audio backend into QtMultimedia if available.
+
+    -no-phonon ......... Do not build the Phonon module.
+ +  -phonon ............ Build the Phonon module.
+                         Phonon is built if a decent C++ compiler is used.
+    -no-phonon-backend.. Do not build the platform phonon plugin.
+ +  -phonon-backend..... Build the platform phonon plugin.
+
+    -no-svg ............ Do not build the SVG module.
+ +  -svg ............... Build the SVG module.
+
+    -no-webkit ......... Do not build the WebKit module.
+ +  -webkit ............ Build the WebKit module.
+                         WebKit is built if a decent C++ compiler is used.
+    -webkit-debug ...... Build the WebKit module with debug symbols.
+
+    -no-javascript-jit . Do not build the JavaScriptCore JIT compiler.
+ +  -javascript-jit .... Build the JavaScriptCore JIT compiler.
+
+    -no-script ......... Do not build the QtScript module.
+ +  -script ............ Build the QtScript module.
+
+    -no-scripttools .... Do not build the QtScriptTools module.
+ +  -scripttools ....... Build the QtScriptTools module.
+
+    -no-declarative ..... Do not build the declarative module.
+ +  -declarative ....... Build the declarative module.
+
+    -no-declarative-debug ..... Do not build the declarative debugging support.
+ +  -declarative-debug ....... Build the declarative debugging support.
+
+    -platform target ... The operating system and compiler you are building
+                         on ($PLATFORM).
+
+                         See the README file for a list of supported
+                         operating systems and compilers.
+EOF
+
+if [ "${PLATFORM_QWS}" != "yes" -a "${PLATFORM_QPA}" != "yes" ]; then
+cat << EOF
+    -graphicssystem <sys> Sets an alternate graphics system. Available options are:
+                           raster - Software rasterizer
+                           opengl - Rendering via OpenGL, Experimental!
+                           openvg - Rendering via OpenVG, Experimental!
+
+EOF
+fi
+
+cat << EOF
+
+    -no-mmx ............ Do not compile with use of MMX instructions.
+    -no-3dnow .......... Do not compile with use of 3DNOW instructions.
+    -no-sse ............ Do not compile with use of SSE instructions.
+    -no-sse2 ........... Do not compile with use of SSE2 instructions.
+    -no-sse3 ........... Do not compile with use of SSE3 instructions.
+    -no-ssse3 .......... Do not compile with use of SSSE3 instructions.
+    -no-sse4.1.......... Do not compile with use of SSE4.1 instructions.
+    -no-sse4.2.......... Do not compile with use of SSE4.2 instructions.
+    -no-avx ............ Do not compile with use of AVX instructions.
+    -no-neon ........... Do not compile with use of NEON instructions.
+
+    -qtnamespace <name>  Wraps all Qt library code in 'namespace <name> {...}'.
+    -qtlibinfix <infix>  Renames all libQt*.so to libQt*<infix>.so.
+
+    -D <string> ........ Add an explicit define to the preprocessor.
+    -I <string> ........ Add an explicit include path.
+    -L <string> ........ Add an explicit library path.
+
+    -help, -h .......... Display this information.
+
+Third Party Libraries:
+
+    -qt-zlib ........... Use the zlib bundled with Qt.
+ +  -system-zlib ....... Use zlib from the operating system.
+                         See http://www.gzip.org/zlib
+
+    -no-gif ............ Do not compile GIF reading support.
+
+    -no-libtiff ........ Do not compile TIFF support.
+    -qt-libtiff ........ Use the libtiff bundled with Qt.
+ +  -system-libtiff .... Use libtiff from the operating system.
+                         See http://www.libtiff.org
+
+    -no-libpng ......... Do not compile PNG support.
+    -qt-libpng ......... Use the libpng bundled with Qt.
+ +  -system-libpng ..... Use libpng from the operating system.
+                         See http://www.libpng.org/pub/png
+
+    -no-libmng ......... Do not compile MNG support.
+    -qt-libmng ......... Use the libmng bundled with Qt.
+ +  -system-libmng ..... Use libmng from the operating system.
+                         See http://www.libmng.com
+
+    -no-libjpeg ........ Do not compile JPEG support.
+    -qt-libjpeg ........ Use the libjpeg bundled with Qt.
+ +  -system-libjpeg .... Use libjpeg from the operating system.
+                         See http://www.ijg.org
+
+    -no-openssl ........ Do not compile support for OpenSSL.
+ +  -openssl ........... Enable run-time OpenSSL support.
+    -openssl-linked .... Enabled linked OpenSSL support.
+
+    -ptmalloc .......... Override the system memory allocator with ptmalloc.
+                         (Experimental.)
+
+Additional options:
+
+    -make <part> ....... Add part to the list of parts to be built at make time.
+                         ($QT_DEFAULT_BUILD_PARTS)
+    -nomake <part> ..... Exclude part from the list of parts to be built.
+
+    -R <string> ........ Add an explicit runtime library path to the Qt
+                         libraries.
+    -l <string> ........ Add an explicit library.
+
+    -no-rpath .......... Do not use the library install path as a runtime
+                         library path.
+ +  -rpath ............. Link Qt libraries and executables using the library
+                         install path as a runtime library path. Equivalent
+                         to -R install_libpath
+
+    -continue .......... Continue as far as possible if an error occurs.
+
+    -verbose, -v ....... Print verbose information about each step of the
+                         configure process.
+
+    -silent ............ Reduce the build output so that warnings and errors
+                         can be seen more easily.
+
+ *  -no-optimized-qmake ... Do not build qmake optimized.
+    -optimized-qmake ...... Build qmake optimized.
+
+    -no-gui ............ Don't build the Qt GUI library
+
+ $NSN  -no-nis ............ Do not compile NIS support.
+ $NSY  -nis ............... Compile NIS support.
+
+ $CUN  -no-cups ........... Do not compile CUPS support.
+ $CUY  -cups .............. Compile CUPS support.
+                         Requires cups/cups.h and libcups.so.2.
+
+ $CIN  -no-iconv .......... Do not compile support for iconv(3).
+ $CIY  -iconv ............. Compile support for iconv(3).
+
+ $PHN  -no-pch ............ Do not use precompiled header support.
+ $PHY  -pch ............... Use precompiled header support.
+
+ $DBN  -no-dbus ........... Do not compile the QtDBus module.
+ $DBY  -dbus .............. Compile the QtDBus module and dynamically load libdbus-1.
+    -dbus-linked ....... Compile the QtDBus module and link to libdbus-1.
+
+    -reduce-relocations ..... Reduce relocations in the libraries through extra
+                              linker optimizations (Qt/X11 and Qt for Embedded Linux only;
+                              experimental; needs GNU ld >= 2.18).
+EOF
+
+if [ "$CFG_SEPARATE_DEBUG_INFO" = "auto" ]; then
+    if [ "$QT_CROSS_COMPILE" = "yes" ]; then
+        SBY=""
+        SBN="*"
+    else
+        SBY="*"
+        SBN=" "
+    fi
+elif [ "$CFG_SEPARATE_DEBUG_INFO" = "yes" ]; then
+    SBY="*"
+    SBN=" "
+else
+    SBY=" "
+    SBN="*"
+fi
+
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+
+    cat << EOF
+
+ $SBN  -no-separate-debug-info . Do not store debug information in a separate file.
+ $SBY  -separate-debug-info .... Strip debug information into a separate file.
+
+EOF
+
+fi # X11/QWS
+
+if [ "$PLATFORM_X11" = "yes" ]; then
+    if [ "$CFG_SM" = "no" ]; then
+        SMY=" "
+        SMN="*"
+    else
+        SMY="*"
+        SMN=" "
+    fi
+    if [ "$CFG_XSHAPE" = "no" ]; then
+        SHY=" "
+        SHN="*"
+    else
+        SHY="*"
+        SHN=" "
+    fi
+    if [ "$CFG_XVIDEO" = "no" ]; then
+        XVY=" "
+        XVN="*"
+    else
+        XVY="*"
+        XVN=" "
+    fi
+    if [ "$CFG_XINERAMA" = "no" ]; then
+        XAY=" "
+        XAN="*"
+    else
+        XAY="*"
+        XAN=" "
+    fi
+    if [ "$CFG_FONTCONFIG" = "no" ]; then
+        FCGY=" "
+        FCGN="*"
+    else
+        FCGY="*"
+        FCGN=" "
+    fi
+    if [ "$CFG_XCURSOR" = "no" ]; then
+        XCY=" "
+        XCN="*"
+    else
+        XCY="*"
+        XCN=" "
+    fi
+    if [ "$CFG_XFIXES" = "no" ]; then
+        XFY=" "
+        XFN="*"
+    else
+        XFY="*"
+        XFN=" "
+    fi
+    if [ "$CFG_XRANDR" = "no" ]; then
+        XZY=" "
+        XZN="*"
+    else
+        XZY="*"
+        XZN=" "
+    fi
+    if [ "$CFG_XRENDER" = "no" ]; then
+        XRY=" "
+        XRN="*"
+    else
+        XRY="*"
+        XRN=" "
+    fi
+    if [ "$CFG_MITSHM" = "no" ]; then
+        XMY=" "
+        XMN="*"
+    else
+        XMY="*"
+        XMN=" "
+    fi
+    if [ "$CFG_XINPUT" = "no" ]; then
+        XIY=" "
+        XIN="*"
+    else
+        XIY="*"
+        XIN=" "
+    fi
+    if [ "$CFG_XKB" = "no" ]; then
+        XKY=" "
+        XKN="*"
+    else
+        XKY="*"
+        XKN=" "
+    fi
+    if [ "$CFG_IM" = "no" ]; then
+        IMY=" "
+        IMN="*"
+    else
+        IMY="*"
+        IMN=" "
+    fi
+    cat << EOF
+
+Qt/X11 only:
+
+    -no-gtkstyle ....... Do not build the GTK theme integration.
+ +  -gtkstyle .......... Build the GTK theme integration.
+
+ *  -no-nas-sound ...... Do not compile in NAS sound support.
+    -system-nas-sound .. Use NAS libaudio from the operating system.
+                         See http://radscan.com/nas.html
+
+    -egl ............... Use EGL instead of GLX to manage contexts.
+                         When building for desktop OpenGL, this option will
+                         make Qt use EGL to manage contexts rather than the
+                         GLX, which is the default. Note: For OpenGL ES, EGL
+                         is always used.
+
+    -no-opengl ......... Do not support OpenGL.
+ +  -opengl <api> ...... Enable OpenGL support.
+                         With no parameter, this will auto-detect the "best"
+                         OpenGL API to use. If desktop OpenGL is available, it
+                         will be used. Use desktop, es1, or es2 for <api>
+                         to force the use of the Desktop (OpenGL 1.x or 2.x),
+                         OpenGL ES 1.x Common profile, or 2.x APIs instead.
+
+     -no-openvg ........ Do not support OpenVG.
+ +   -openvg ........... Enable OpenVG support.
+                         Requires EGL support, typically supplied by an OpenGL
+                         or other graphics implementation.
+
+ $SMN  -no-sm ............. Do not support X Session Management.
+ $SMY  -sm ................ Support X Session Management, links in -lSM -lICE.
+
+ $SHN  -no-xshape ......... Do not compile XShape support.
+ $SHY  -xshape ............ Compile XShape support.
+                         Requires X11/extensions/shape.h.
+
+ $XVN  -no-xvideo ......... Do not compile XVideo support.
+ $XVY  -xvideo ............ Compile XVideo support.
+                         Requires X11/extensions/Xv.h & Xvlib.h.
+
+ $SHN  -no-xsync .......... Do not compile XSync support.
+ $SHY  -xsync ............. Compile XSync support.
+                         Requires X11/extensions/sync.h.
+
+ $XAN  -no-xinerama ....... Do not compile Xinerama (multihead) support.
+ $XAY  -xinerama .......... Compile Xinerama support.
+                         Requires X11/extensions/Xinerama.h and libXinerama.
+			 By default, Xinerama support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XCN  -no-xcursor ........ Do not compile Xcursor support.
+ $XCY  -xcursor ........... Compile Xcursor support.
+                         Requires X11/Xcursor/Xcursor.h and libXcursor.
+			 By default, Xcursor support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XFN  -no-xfixes ......... Do not compile Xfixes support.
+ $XFY  -xfixes ............ Compile Xfixes support.
+                         Requires X11/extensions/Xfixes.h and libXfixes.
+			 By default, Xfixes support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XZN  -no-xrandr ......... Do not compile Xrandr (resize and rotate) support.
+ $XZY  -xrandr ............ Compile Xrandr support.
+                         Requires X11/extensions/Xrandr.h and libXrandr.
+
+ $XRN  -no-xrender ........ Do not compile Xrender support.
+ $XRY  -xrender ........... Compile Xrender support.
+                         Requires X11/extensions/Xrender.h and libXrender.
+
+ $XMN  -no-mitshm ......... Do not compile MIT-SHM support.
+ $XMY  -mitshm ............ Compile MIT-SHM support.
+                         Requires sys/ipc.h, sys/shm.h and X11/extensions/XShm.h
+
+ $FCGN  -no-fontconfig ..... Do not compile FontConfig (anti-aliased font) support.
+ $FCGY  -fontconfig ........ Compile FontConfig support.
+                         Requires fontconfig/fontconfig.h, libfontconfig,
+                         freetype.h and libfreetype.
+
+ $XIN  -no-xinput ......... Do not compile Xinput support.
+ $XIY  -xinput ............ Compile Xinput support. This also enabled tablet support
+                         which requires IRIX with wacom.h and libXi or
+                         XFree86 with X11/extensions/XInput.h and libXi.
+
+ $XKN  -no-xkb ............ Do not compile XKB (X KeyBoard extension) support.
+ $XKY  -xkb ............... Compile XKB support.
+
+EOF
+fi
+
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    cat << EOF
+
+    -no-slog2 .......... Do not compile with slog2 support.
+    -slog2 ............. Compile with slog2 support.
+
+EOF
+
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    cat << EOF
+
+Qt/Mac only:
+
+    -Fstring ........... Add an explicit framework path.
+    -fw string ......... Add an explicit framework.
+
+    -cocoa ............. [Deprecated] Cocoa is now enabled by default.
+
+    -carbon .............Build the Carbon version of Qt. 64-bit archs
+                         are not supported by carbon and will be built
+                         with cocoa
+
+ *  -framework ......... Build Qt as a series of frameworks and
+                         link tools against those frameworks.
+    -no-framework ...... Do not build Qt as a series of frameworks.
+
+ *  -dwarf2 ............ Enable dwarf2 debugging symbols.
+    -no-dwarf2 ......... Disable dwarf2 debugging symbols.
+
+    -universal ......... Equivalent to -arch "ppc x86"
+
+    -arch <arch> ....... Build Qt for <arch>
+                         Example values for <arch>: x86 ppc x86_64 ppc64
+                         Multiple -arch arguments can be specified.
+
+    -sdk <sdk> ......... Build Qt using Apple provided SDK <sdk>. This option requires gcc 4.
+                         To use a different SDK with gcc 3.3, set the SDKROOT environment variable.
+
+    -harfbuzz .......... Use HarfBuzz to do text layout instead of Core Text when possible.
+                         It is only available to Cocoa builds.
+ *  -no-harfbuzz ....... Disable HarfBuzz on Mac. It can still be enabled by setting
+                         QT_ENABLE_HARFBUZZ environment variable.
+
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    cat << EOF
+Qt for Embedded Linux:
+
+    -embedded <arch> .... This will enable the embedded build, you must have a
+                          proper license for this switch to work.
+                          Example values for <arch>: arm mips x86 generic
+EOF
+fi
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    cat << EOF
+Qt for QPA only:
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    cat << EOF
+
+    -xplatform target ... The target platform when cross-compiling.
+
+    -device-option <key=value> ... Add device specific options for the device mkspec
+                                   (experimental)
+
+    -no-feature-<feature> Do not compile in <feature>.
+    -feature-<feature> .. Compile in <feature>. The available features
+                          are described in src/corelib/global/qfeatures.txt
+
+    -armfpa ............. Target platform uses the ARM-FPA floating point format.
+    -no-armfpa .......... Target platform does not use the ARM-FPA floating point format.
+
+                          The floating point format is usually autodetected by configure. Use this
+                          to override the detected value.
+
+    -little-endian ...... Target platform is little endian (LSB first).
+    -big-endian ......... Target platform is big endian (MSB first).
+
+    -host-little-endian . Host platform is little endian (LSB first).
+    -host-big-endian .... Host platform is big endian (MSB first).
+
+                          You only need to specify the endianness when
+                          cross-compiling, otherwise the host
+                          endianness will be used.
+
+    -no-freetype ........ Do not compile in Freetype2 support.
+    -qt-freetype ........ Use the libfreetype bundled with Qt.
+ *  -system-freetype .... Use libfreetype from the operating system.
+                          See http://www.freetype.org/
+
+    -qconfig local ...... Use src/corelib/global/qconfig-local.h rather than the
+                          default ($CFG_QCONFIG).
+
+    -no-opengl .......... Do not support OpenGL.
+    -opengl <api> ....... Enable OpenGL ES support
+                          With no parameter, this will attempt to auto-detect OpenGL ES 1.x
+                          or 2.x, or regular desktop OpenGL.
+                          Use es1 or es2 for <api> to override auto-detection.
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    cat << EOF
+
+    -depths <list> ...... Comma-separated list of supported bit-per-pixel
+                          depths, from: 1, 4, 8, 12, 15, 16, 18, 24, 32 and 'all'.
+
+    -qt-decoration-<style> ....Enable a decoration <style> in the QtGui library,
+                               by default all available decorations are on.
+			       Possible values for <style>: [ $CFG_DECORATION_AVAILABLE ]
+    -plugin-decoration-<style> Enable decoration <style> as a plugin to be
+                               linked to at run time.
+			       Possible values for <style>: [ $CFG_DECORATION_PLUGIN_AVAILABLE ]
+    -no-decoration-<style> ....Disable decoration <style> entirely.
+                               Possible values for <style>: [ $CFG_DECORATION_AVAILABLE ]
+
+    -qt-gfx-<driver> ... Enable a graphics <driver> in the QtGui library.
+                         Possible values for <driver>: [ $CFG_GFX_AVAILABLE ]
+    -plugin-gfx-<driver> Enable graphics <driver> as a plugin to be
+                         linked to at run time.
+                         Possible values for <driver>: [ $CFG_GFX_PLUGIN_AVAILABLE ]
+    -no-gfx-<driver> ... Disable graphics <driver> entirely.
+                         Possible values for <driver>: [ $CFG_GFX_AVAILABLE ]
+
+    -qt-kbd-<driver> ... Enable a keyboard <driver> in the QtGui library.
+                         Possible values for <driver>: [ $CFG_KBD_AVAILABLE ]
+
+    -plugin-kbd-<driver> Enable keyboard <driver> as a plugin to be linked to
+                         at runtime.
+                         Possible values for <driver>: [ $CFG_KBD_PLUGIN_AVAILABLE ]
+
+    -no-kbd-<driver> ... Disable keyboard <driver> entirely.
+                         Possible values for <driver>: [ $CFG_KBD_AVAILABLE ]
+
+    -qt-mouse-<driver> ... Enable a mouse <driver> in the QtGui library.
+                           Possible values for <driver>: [ $CFG_MOUSE_AVAILABLE ]
+    -plugin-mouse-<driver> Enable mouse <driver> as a plugin to be linked to
+                           at runtime.
+                           Possible values for <driver>: [ $CFG_MOUSE_PLUGIN_AVAILABLE ]
+    -no-mouse-<driver> ... Disable mouse <driver> entirely.
+                           Possible values for <driver>: [ $CFG_MOUSE_AVAILABLE ]
+
+    -iwmmxt ............ Compile using the iWMMXt instruction set
+                         (available on some XScale CPUs).
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" -o "$PLATFORM_X11" = "yes" ]; then
+    if [ "$CFG_GLIB" = "no" ]; then
+        GBY=" "
+        GBN="+"
+    else
+        GBY="+"
+        GBN=" "
+    fi
+    cat << EOF
+ $GBN  -no-glib ........... Do not compile Glib support.
+ $GBY  -glib .............. Compile Glib support.
+
+EOF
+fi
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    cat << EOF
+
+Qt for Symbian only:
+    -no-s60 ............ Do not compile in S60 support.
+ +  -s60 ............... Compile with support for the S60 UI Framework.
+    -no-style-s60....... Disable s60 style
+ +  -qt-style-s60....... Enable s60 style in the Qt Library
+
+    -no-usedeffiles .... Disable the usage of DEF files.
+ *  -usedeffiles ....... Enable the usage of DEF files.
+EOF
+fi
+   [ "x$ERROR" = "xyes" ] && exit 1
+   exit 0
+fi # Help
+
+
+# -----------------------------------------------------------------------------
+# LICENSING, INTERACTIVE PART
+# -----------------------------------------------------------------------------
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    Platform="Qt for Embedded Linux"
+elif [ "$PLATFORM_QPA" = "yes" ]; then
+    Platform="Qt Lighthouse"
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    Platform="Qt for INTEGRITY"
+elif [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    Platform="Qt for Symbian"
+elif [ "$PLATFORM_MAC" = "yes" ]; then
+    Platform="Qt for Mac OS X"
+elif [ "$XPLATFORM_MINGW" = "yes" ]; then
+    Platform="Qt for Windows"
+elif [ -n "`getXQMakeConf grep QMAKE_LIBS_X11`" ]; then
+    PLATFORM_X11=yes
+    Platform="Qt for Linux/X11"
+fi
+
+echo
+echo "This is the $Platform ${EditionString} Edition."
+echo
+
+if [ "$Edition" = "NokiaInternalBuild" ]; then
+    echo "Detected -nokia-developer option"
+    echo "Nokia employees and agents are allowed to use this software under"
+    echo "the authority of Nokia Corporation and/or its subsidiary(-ies)"
+elif [ "$Edition" = "OpenSource" ]; then
+    while true; do
+        echo "You are licensed to use this software under the terms of"
+        echo "the Lesser GNU General Public License (LGPL) versions 2.1."
+        if [ -f "$relpath/LICENSE.GPL3" ]; then
+            echo "You are also licensed to use this software under the terms of"
+            echo "the GNU General Public License (GPL) versions 3."
+            affix="either"
+        else
+            affix="the"
+        fi
+        echo
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+            echo "You have already accepted the terms of the $LicenseType license."
+            acceptance=yes
+        else
+            if [ -f "$relpath/LICENSE.GPL3" ]; then
+                echo "Type '3' to view the GNU General Public License version 3."
+            fi
+            echo "Type 'L' to view the Lesser GNU General Public License version 2.1."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of $affix license? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ] || [ "$acceptance" = "y" ]; then
+            break
+        elif [ "$acceptance" = "no" ]; then
+            echo "You are not licensed to use this software."
+            echo
+            exit 1
+        elif [ "$acceptance" = "3" ]; then
+            more "$relpath/LICENSE.GPL3"
+        elif [ "$acceptance" = "L" ]; then
+            more "$relpath/LICENSE.LGPL"
+        fi
+    done
+elif [ "$Edition" = "Preview" ]; then
+    TheLicense=`head -n 1 "$relpath/LICENSE.PREVIEW.COMMERCIAL"`
+    while true; do
+
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+            echo "You have already accepted the terms of the $LicenseType license."
+            acceptance=yes
+        else
+            echo "You are licensed to use this software under the terms of"
+            echo "the $TheLicense"
+            echo
+            echo "Type '?' to read the Preview License."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of the license? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ]; then
+            break
+        elif [ "$acceptance" = "no" ] ;then
+            echo "You are not licensed to use this software."
+            echo
+            exit 0
+        elif [ "$acceptance" = "?" ]; then
+            more "$relpath/LICENSE.PREVIEW.COMMERCIAL"
+        fi
+    done
+elif [ "$Edition" != "OpenSource" ]; then
+    if [ -n "$ExpiryDate" ]; then
+        ExpiryDate=`echo $ExpiryDate | sed -e "s,-,,g" | tr -d "\n\r"`
+        [ -z "$ExpiryDate" ] && ExpiryDate="0"
+        Today=`date +%Y%m%d`
+        if [ "$Today" -gt "$ExpiryDate" ]; then
+            case "$LicenseType" in
+            Commercial|Academic|Educational)
+                if [ "$QT_PACKAGEDATE" -gt "$ExpiryDate" ]; then
+                    echo
+                    echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                    echo
+                    echo "  Your support and upgrade period has expired."
+                    echo
+                    echo "  You are no longer licensed to use this version of Qt."
+                    echo "  Please contact qt-info@nokia.com to renew your support"
+                    echo "  and upgrades for this license."
+                    echo
+                    echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                    echo
+                    exit 1
+                else
+                    echo
+                    echo "WARNING  WARNING  WARNING  WARNING"
+                    echo
+                    echo "  Your support and upgrade period has expired."
+                    echo
+                    echo "  You may continue to use your last licensed release"
+                    echo "  of Qt under the terms of your existing license"
+                    echo "  agreement. But you are not entitled to technical"
+                    echo "  support, nor are you entitled to use any more recent"
+                    echo "  Qt releases."
+                    echo
+                    echo "  Please contact qt-info@nokia.com to renew your"
+                    echo "  support and upgrades for this license."
+                    echo
+                    echo "WARNING  WARNING  WARNING  WARNING"
+                    echo
+                    sleep 3
+                fi
+                ;;
+            Evaluation|*)
+                echo
+                echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                echo
+                echo "  Your Evaluation license has expired."
+                echo
+                echo "  You are no longer licensed to use this software. Please"
+                echo "  contact qt-info@nokia.com to purchase license, or install"
+                echo "  the Qt Open Source Edition if you intend to develop free"
+                echo "  software."
+                echo
+                echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                echo
+                exit 1
+                ;;
+            esac
+        fi
+    fi
+    TheLicense=`head -n 1 "$outpath/LICENSE"`
+    while true; do
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+	    echo "You have already accepted the terms of the $TheLicense."
+            acceptance=yes
+        else
+            echo "You are licensed to use this software under the terms of"
+            echo "the $TheLicense."
+            echo
+            echo "Type '?' to view the $TheLicense."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of the $TheLicense? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ]; then
+            break
+        elif [ "$acceptance" = "no" ]; then
+            echo "You are not licensed to use this software."
+            echo
+            exit 1
+        else [ "$acceptance" = "?" ]
+            more "$outpath/LICENSE"
+        fi
+    done
+fi
+
+# this should be moved somewhere else
+case "$PLATFORM" in
+aix-*)
+    AIX_VERSION=`uname -v`
+    if [ "$AIX_VERSION" -lt "5" ]; then
+	QMakeVar add QMAKE_LIBS_X11 -lbind
+    fi
+    ;;
+*)
+    ;;
+esac
+
+#-------------------------------------------------------------------------------
+# generate qconfig.cpp
+#-------------------------------------------------------------------------------
+[ -d "$outpath/src/corelib/global" ] || mkdir -p "$outpath/src/corelib/global"
+
+LICENSE_USER_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_lcnsuser=$Licensee"`
+LICENSE_PRODUCTS_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_lcnsprod=$Edition"`
+PREFIX_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_prfxpath=$QT_INSTALL_PREFIX"`
+DOCUMENTATION_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_docspath=$QT_INSTALL_DOCS"`
+HEADERS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_hdrspath=$QT_INSTALL_HEADERS"`
+LIBRARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_libspath=$QT_INSTALL_LIBS"`
+BINARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_binspath=$QT_INSTALL_BINS"`
+PLUGINS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_plugpath=$QT_INSTALL_PLUGINS"`
+IMPORTS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_impspath=$QT_INSTALL_IMPORTS"`
+DATA_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_datapath=$QT_INSTALL_DATA"`
+TRANSLATIONS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_trnspath=$QT_INSTALL_TRANSLATIONS"`
+SETTINGS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_stngpath=$QT_INSTALL_SETTINGS"`
+EXAMPLES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_xmplpath=$QT_INSTALL_EXAMPLES"`
+DEMOS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_demopath=$QT_INSTALL_DEMOS"`
+
+TODAY=`date +%Y-%m-%d`
+cat > "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* License Info */
+static const char qt_configure_licensee_str          [256 + 12] = "$LICENSE_USER_STR";
+static const char qt_configure_licensed_products_str [256 + 12] = "$LICENSE_PRODUCTS_STR";
+
+/* Installation date */
+static const char qt_configure_installation          [12+11]    = "qt_instdate=$TODAY";
+EOF
+
+
+if [ ! -z "$QT_HOST_PREFIX" ]; then
+    HOSTPREFIX_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_prfxpath=$QT_HOST_PREFIX"`
+    HOSTDOCUMENTATION_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_docspath=$QT_HOST_PREFIX/doc"`
+    HOSTHEADERS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_hdrspath=$QT_HOST_PREFIX/include"`
+    HOSTLIBRARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_libspath=$QT_HOST_PREFIX/lib"`
+    HOSTBINARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_binspath=$QT_HOST_PREFIX/bin"`
+    HOSTPLUGINS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_plugpath=$QT_HOST_PREFIX/plugins"`
+    HOSTIMPORTS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_impspath=$QT_HOST_PREFIX/IMPORTS"`
+    HOSTDATA_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_datapath=$QT_HOST_PREFIX"`
+    HOSTTRANSLATIONS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_trnspath=$QT_HOST_PREFIX/translations"`
+    HOSTSETTINGS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_stngpath=$QT_INSTALL_SETTINGS"`
+    HOSTEXAMPLES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_xmplpath=$QT_INSTALL_EXAMPLES"`
+    HOSTDEMOS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_demopath=$QT_INSTALL_DEMOS"`
+
+    cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+
+#if defined(QT_BOOTSTRAPPED) || defined(QT_BUILD_QMAKE)
+/* Installation Info */
+static const char qt_configure_prefix_path_str       [256 + 12] = "$HOSTPREFIX_PATH_STR";
+static const char qt_configure_documentation_path_str[256 + 12] = "$HOSTDOCUMENTATION_PATH_STR";
+static const char qt_configure_headers_path_str      [256 + 12] = "$HOSTHEADERS_PATH_STR";
+static const char qt_configure_libraries_path_str    [256 + 12] = "$HOSTLIBRARIES_PATH_STR";
+static const char qt_configure_binaries_path_str     [256 + 12] = "$HOSTBINARIES_PATH_STR";
+static const char qt_configure_plugins_path_str      [256 + 12] = "$HOSTPLUGINS_PATH_STR";
+static const char qt_configure_imports_path_str      [256 + 12] = "$HOSTIMPORTS_PATH_STR";
+static const char qt_configure_data_path_str         [256 + 12] = "$HOSTDATA_PATH_STR";
+static const char qt_configure_translations_path_str [256 + 12] = "$HOSTTRANSLATIONS_PATH_STR";
+static const char qt_configure_settings_path_str     [256 + 12] = "$HOSTSETTINGS_PATH_STR";
+static const char qt_configure_examples_path_str     [256 + 12] = "$HOSTEXAMPLES_PATH_STR";
+static const char qt_configure_demos_path_str        [256 + 12] = "$HOSTDEMOS_PATH_STR";
+#else // QT_BOOTSTRAPPED
+EOF
+fi
+
+cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* Installation Info */
+static const char qt_configure_prefix_path_str       [256 + 12] = "$PREFIX_PATH_STR";
+static const char qt_configure_documentation_path_str[256 + 12] = "$DOCUMENTATION_PATH_STR";
+static const char qt_configure_headers_path_str      [256 + 12] = "$HEADERS_PATH_STR";
+static const char qt_configure_libraries_path_str    [256 + 12] = "$LIBRARIES_PATH_STR";
+static const char qt_configure_binaries_path_str     [256 + 12] = "$BINARIES_PATH_STR";
+static const char qt_configure_plugins_path_str      [256 + 12] = "$PLUGINS_PATH_STR";
+static const char qt_configure_imports_path_str      [256 + 12] = "$IMPORTS_PATH_STR";
+static const char qt_configure_data_path_str         [256 + 12] = "$DATA_PATH_STR";
+static const char qt_configure_translations_path_str [256 + 12] = "$TRANSLATIONS_PATH_STR";
+static const char qt_configure_settings_path_str     [256 + 12] = "$SETTINGS_PATH_STR";
+static const char qt_configure_examples_path_str     [256 + 12] = "$EXAMPLES_PATH_STR";
+static const char qt_configure_demos_path_str        [256 + 12] = "$DEMOS_PATH_STR";
+EOF
+
+if [ ! -z "$QT_HOST_PREFIX" ]; then
+    cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+#endif // QT_BOOTSTRAPPED
+
+EOF
+fi
+
+cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* strlen( "qt_lcnsxxxx" ) == 12 */
+#define QT_CONFIGURE_LICENSEE qt_configure_licensee_str + 12;
+#define QT_CONFIGURE_LICENSED_PRODUCTS qt_configure_licensed_products_str + 12;
+#define QT_CONFIGURE_PREFIX_PATH qt_configure_prefix_path_str + 12;
+#define QT_CONFIGURE_DOCUMENTATION_PATH qt_configure_documentation_path_str + 12;
+#define QT_CONFIGURE_HEADERS_PATH qt_configure_headers_path_str + 12;
+#define QT_CONFIGURE_LIBRARIES_PATH qt_configure_libraries_path_str + 12;
+#define QT_CONFIGURE_BINARIES_PATH qt_configure_binaries_path_str + 12;
+#define QT_CONFIGURE_PLUGINS_PATH qt_configure_plugins_path_str + 12;
+#define QT_CONFIGURE_IMPORTS_PATH qt_configure_imports_path_str + 12;
+#define QT_CONFIGURE_DATA_PATH qt_configure_data_path_str + 12;
+#define QT_CONFIGURE_TRANSLATIONS_PATH qt_configure_translations_path_str + 12;
+#define QT_CONFIGURE_SETTINGS_PATH qt_configure_settings_path_str + 12;
+#define QT_CONFIGURE_EXAMPLES_PATH qt_configure_examples_path_str + 12;
+#define QT_CONFIGURE_DEMOS_PATH qt_configure_demos_path_str + 12;
+EOF
+
+# avoid unecessary rebuilds by copying only if qconfig.cpp has changed
+if cmp -s "$outpath/src/corelib/global/qconfig.cpp" "$outpath/src/corelib/global/qconfig.cpp.new"; then
+    rm -f "$outpath/src/corelib/global/qconfig.cpp.new"
+else
+    [ -f "$outpath/src/corelib/global/qconfig.cpp" ] && chmod +w "$outpath/src/corelib/global/qconfig.cpp"
+    mv "$outpath/src/corelib/global/qconfig.cpp.new" "$outpath/src/corelib/global/qconfig.cpp"
+    chmod -w "$outpath/src/corelib/global/qconfig.cpp"
+fi
+
+# -----------------------------------------------------------------------------
+if [ "$LicenseType" = "Evaluation" ]; then
+    EVALKEY=`"$relpath/config.tests/unix/padstring" 524 "qt_qevalkey=$LicenseKeyExt"`
+elif echo "$D_FLAGS" | grep QT_EVAL >/dev/null 2>&1; then
+    EVALKEY=`"$relpath/config.tests/unix/padstring" 524 "qt_qevalkey="`
+fi
+
+if [ -n "$EVALKEY" ]; then
+    rm -f "$outpath/src/corelib/global/qconfig_eval.cpp"
+    cat > "$outpath/src/corelib/global/qconfig_eval.cpp" <<EOF
+/* Evaluation license key */
+static const volatile char qt_eval_key_data                   [512 + 12] = "$EVALKEY";
+EOF
+    chmod -w "$outpath/src/corelib/global/qconfig_eval.cpp"
+fi
+
+
+# -----------------------------------------------------------------------------
+# build qmake
+# -----------------------------------------------------------------------------
+
+# symlink includes
+if [ -n "$PERL" ] && [ -x "$relpath/bin/syncqt" ]; then
+    SYNCQT_OPTS=
+    [ "$CFG_DEV" = "yes" ] && SYNCQT_OPTS="$SYNCQT_OPTS -check-includes"
+    if [ "$OPT_SHADOW" = "yes" ]; then
+        "$outpath/bin/syncqt" $SYNCQT_OPTS || exit 1
+    elif [ "$CFG_DEV" = "yes" ] || [ ! -d $relpath/include ] || [ -d $relpath/.git ]; then
+        QTDIR="$relpath" perl "$outpath/bin/syncqt" $SYNCQT_OPTS || exit 1
+    fi
+fi
+
+# $1: input variable name (awk regexp)
+# $2: optional output variable name
+# $3: optional value transformation (sed command)
+# relies on $QMAKESPEC, $COMPILER_CONF and $mkfile being set correctly, as the latter
+# is where the resulting variable is written to
+setBootstrapVariable()
+{
+    getQMakeConf "$1" | echo ${2-$1} = `if [ -n "$3" ]; then sed "$3"; else cat; fi` >> "$mkfile"
+}
+
+# build qmake
+if true; then ###[ '!' -f "$outpath/bin/qmake" ];
+    echo "Creating qmake. Please wait..."
+
+    OLD_QCONFIG_H=
+    QCONFIG_H="$outpath/src/corelib/global/qconfig.h"
+    QMAKE_QCONFIG_H="${QCONFIG_H}.qmake"
+    if [ -f "$QCONFIG_H" ]; then
+         OLD_QCONFIG_H=$QCONFIG_H
+         mv -f "$OLD_QCONFIG_H" "${OLD_QCONFIG_H}.old"
+    fi
+
+    # create temporary qconfig.h for compiling qmake, if it doesn't exist
+    # when building qmake, we use #defines for the install paths,
+    # however they are real functions in the library
+    if [ '!' -f "$QMAKE_QCONFIG_H" ]; then
+        mkdir -p "$outpath/src/corelib/global"
+        [ -f "$QCONFIG_H" ] && chmod +w "$QCONFIG_H"
+        echo "/* All features enabled while building qmake */" >"$QMAKE_QCONFIG_H"
+    fi
+
+    mv -f "$QMAKE_QCONFIG_H" "$QCONFIG_H"
+
+    #mkspecs/default is used as a (gasp!) default mkspec so QMAKESPEC needn't be set once configured
+    rm -rf mkspecs/default
+    ln -s `echo $XQMAKESPEC | sed "s,^${relpath}/mkspecs/,,"` mkspecs/default
+    # fix makefiles
+    for mkfile in GNUmakefile Makefile; do
+        EXTRA_LFLAGS=
+        EXTRA_CFLAGS=
+        in_mkfile="${mkfile}.in"
+        if [ "$mkfile" = "Makefile" ]; then
+#           if which qmake >/dev/null 2>&1 && [ -f qmake/qmake.pro ]; then
+#               (cd qmake && qmake) >/dev/null 2>&1 && continue
+#           fi
+            in_mkfile="${mkfile}.unix"
+        fi
+        in_mkfile="$relpath/qmake/$in_mkfile"
+        mkfile="$outpath/qmake/$mkfile"
+        if [ -f "$mkfile" ]; then
+            [ "$CFG_DEV" = "yes" ] && "$WHICH" chflags >/dev/null 2>&1 && chflags nouchg "$mkfile"
+            rm -f "$mkfile"
+        fi
+        [ -f "$in_mkfile" ] || continue
+
+        echo "########################################################################" > "$mkfile"
+        echo "## This file was autogenerated by configure, all changes will be lost ##" >> "$mkfile"
+        echo "########################################################################" >> "$mkfile"
+        EXTRA_OBJS=
+        EXTRA_SRCS=
+        EXTRA_CFLAGS="\$(QMAKE_CFLAGS)"
+        EXTRA_CXXFLAGS="\$(QMAKE_CXXFLAGS)"
+        EXTRA_LFLAGS="\$(QMAKE_LFLAGS)"
+
+        if [ "$PLATFORM" = "irix-cc" ] || [ "$PLATFORM" = "irix-cc-64" ]; then
+	    EXTRA_LFLAGS="$EXTRA_LFLAGS -lm"
+        fi
+
+	[ -n "$CC" ] && echo "CC = $CC" >> "$mkfile"
+	[ -n "$CXX" ] && echo "CXX = $CXX" >> "$mkfile"
+        [ "$CFG_SILENT" = "yes" ] && CC_TRANSFORM='s,^,\@,' || CC_TRANSFORM=
+        [ -z "$CC" ] && setBootstrapVariable QMAKE_CC CC "$CC_TRANSFORM"
+        [ -z "$CXX" ] && setBootstrapVariable QMAKE_CXX CXX "$CC_TRANSFORM"
+        setBootstrapVariable QMAKE_CFLAGS
+        setBootstrapVariable QMAKE_CXXFLAGS
+        setBootstrapVariable QMAKE_LFLAGS
+
+        if [ $QT_EDITION = "QT_EDITION_OPENSOURCE" ]; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -DQMAKE_OPENSOURCE_EDITION"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS -DQMAKE_OPENSOURCE_EDITION"
+        fi
+        if [ "$CFG_RELEASE_QMAKE" = "yes" ]; then
+            setBootstrapVariable QMAKE_CFLAGS_RELEASE
+            setBootstrapVariable QMAKE_CXXFLAGS_RELEASE
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QMAKE_CFLAGS_RELEASE)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(QMAKE_CXXFLAGS_RELEASE)"
+        elif [ "$CFG_DEBUG" = "yes" ]; then
+            setBootstrapVariable QMAKE_CFLAGS_DEBUG
+            setBootstrapVariable QMAKE_CXXFLAGS_DEBUG
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QMAKE_CFLAGS_DEBUG)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(QMAKE_CXXFLAGS_DEBUG)"
+        fi
+
+        if [ -n "$RPATH_FLAGS" ] && [ -n "`getQMakeConf 'QMAKE_(LFLAGS_)?RPATH'`" ]; then
+            setBootstrapVariable "QMAKE_(LFLAGS_)?RPATH" QMAKE_LFLAGS_RPATH
+            for rpath in $RPATH_FLAGS; do
+                EXTRA_LFLAGS="\$(QMAKE_LFLAGS_RPATH)\"$rpath\" $EXTRA_LFLAGS"
+            done
+        fi
+        if [ "$BUILD_ON_MAC" = "yes" ]; then
+            echo "export MACOSX_DEPLOYMENT_TARGET = 10.5" >> "$mkfile"
+            echo "CARBON_LFLAGS =-framework ApplicationServices" >>"$mkfile"
+            echo "CARBON_CFLAGS =-fconstant-cfstrings" >>"$mkfile"
+            EXTRA_LFLAGS="$EXTRA_LFLAGS \$(CARBON_LFLAGS)"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(CARBON_CFLAGS)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(CARBON_CFLAGS)"
+            EXTRA_OBJS="qsettings_mac.o qcore_mac.o"
+            EXTRA_SRCS="\"$relpath/src/corelib/io/qsettings_mac.cpp\" \"$relpath/src/corelib/kernel/qcore_mac.cpp\""
+	    if echo "$CFG_MAC_ARCHS" | grep x86 > /dev/null 2>&1; then # matches both x86 and x86_64
+		X86_CFLAGS="-arch i386"
+		X86_LFLAGS="-arch i386"
+		EXTRA_CFLAGS="$X86_CFLAGS $EXTRA_CFLAGS"
+		EXTRA_CXXFLAGS="$X86_CFLAGS $EXTRA_CXXFLAGS"
+                EXTRA_LFLAGS="$EXTRA_LFLAGS $X86_LFLAGS"
+            fi
+	    if echo "$CFG_MAC_ARCHS" | grep ppc > /dev/null 2>&1; then # matches both ppc and ppc64
+		PPC_CFLAGS="-arch ppc"
+		PPC_LFLAGS="-arch ppc"
+		EXTRA_CFLAGS="$PPC_CFLAGS $EXTRA_CFLAGS"
+		EXTRA_CXXFLAGS="$PPC_CFLAGS $EXTRA_CXXFLAGS"
+                EXTRA_LFLAGS="$EXTRA_LFLAGS $PPC_LFLAGS"
+            fi
+	    if [ '!' -z "$CFG_SDK" ]; then
+		echo "SDK_LFLAGS =-Wl,-syslibroot,$CFG_SDK" >>"$mkfile"
+		echo "SDK_CFLAGS =-isysroot $CFG_SDK" >>"$mkfile"
+		EXTRA_CFLAGS="$EXTRA_CFLAGS \$(SDK_CFLAGS)"
+		EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(SDK_CFLAGS)"
+		EXTRA_LFLAGS="$EXTRA_LFLAGS \$(SDK_LFLAGS)"
+            fi
+        fi
+        [ "$CFG_EMBEDDED" != "no" ] && EXTRA_CFLAGS="$EXTRA_CFLAGS -DQWS"
+        if [ '!' -z "$D_FLAGS" ]; then
+            for DEF in $D_FLAGS; do
+                EXTRA_CFLAGS="$EXTRA_CFLAGS \"-D${DEF}\""
+            done
+        fi
+        QMAKE_BIN_DIR="$QT_INSTALL_BINS"
+        [ -z "$QMAKE_BIN_DIR" ] && QMAKE_BIN_DIR="${QT_INSTALL_PREFIX}/bin"
+        QMAKE_DATA_DIR="$QT_INSTALL_DATA"
+        [ -z "$QMAKE_DATA_DIR" ] && QMAKE_DATA_DIR="${QT_INSTALL_PREFIX}"
+        echo >>"$mkfile"
+	adjrelpath=`echo "$relpath" | sed 's/ /\\\\\\\\ /g'`
+	adjoutpath=`echo "$outpath" | sed 's/ /\\\\\\\\ /g'`
+	adjqmakespec=`echo "$QMAKESPEC" | sed 's/ /\\\\\\\\ /g'`
+        sed -e "s,@SOURCE_PATH@,$adjrelpath,g" -e "s,@BUILD_PATH@,$adjoutpath,g" \
+            -e "s,@QMAKE_CFLAGS@,$EXTRA_CFLAGS,g" -e "s,@QMAKE_LFLAGS@,$EXTRA_LFLAGS,g" \
+            -e "s,@QMAKE_CXXFLAGS@,$EXTRA_CXXFLAGS,g" \
+            -e "s,@QT_INSTALL_BINS@,\$(INSTALL_ROOT)$QMAKE_BIN_DIR,g" \
+            -e "s,@QT_INSTALL_DATA@,\$(INSTALL_ROOT)$QMAKE_DATA_DIR,g" \
+            -e "s,@QMAKE_QTOBJS@,$EXTRA_OBJS,g" -e "s,@QMAKE_QTSRCS@,$EXTRA_SRCS,g" \
+	    -e "s,@QMAKESPEC@,$adjqmakespec,g" "$in_mkfile" >>"$mkfile"
+
+        if "$WHICH" makedepend >/dev/null 2>&1 && grep 'depend:' "$mkfile" >/dev/null 2>&1; then
+            (cd "$outpath/qmake" && "$MAKE" -f "$mkfile" depend) >/dev/null 2>&1
+	    sed "s,^.*/\([^/]*.o\):,\1:,g" "$mkfile" >"$mkfile.tmp"
+	    sed "s,$outpath,$adjoutpath,g" "$mkfile.tmp" >"$mkfile"
+	    rm "$mkfile.tmp"
+        fi
+    done
+
+    QMAKE_BUILD_ERROR=no
+    (cd "$outpath/qmake"; "$MAKE") || QMAKE_BUILD_ERROR=yes
+    [ '!' -z "$QCONFIG_H" ] && mv -f "$QCONFIG_H" "$QMAKE_QCONFIG_H" #move qmake's qconfig.h to qconfig.h.qmake
+    [ '!' -z "$OLD_QCONFIG_H" ] && mv -f "${OLD_QCONFIG_H}.old" "$OLD_QCONFIG_H" #put back qconfig.h
+    [ "$QMAKE_BUILD_ERROR" = "yes" ] && exit 2
+fi # Build qmake
+
+#-------------------------------------------------------------------------------
+# write out device config before we run the test.
+#-------------------------------------------------------------------------------
+DEVICE_VARS_OUTFILE="$outpath/mkspecs/qdevice.pri"
+if cmp -s "$DEVICE_VARS_FILE" "$DEVICE_VARS_OUTFILE"; then
+    rm -f "$DEVICE_VARS_FILE"
+else
+    mv -f $DEVICE_VARS_FILE "$DEVICE_VARS_OUTFILE"
+    DEVICE_VARS_FILE="$DEVICE_VARS_OUTFILE"
+fi
+
+if [ -z "$PKG_CONFIG" ]; then
+    # See if PKG_CONFIG is set in the mkspec or device options
+    (echo TEMPLATE = subdirs
+     echo 'message($$PKG_CONFIG)') > "$outpath/dummy.pro"
+    echo "QT_BUILD_TREE = $outpath" > "$outpath/.qmake.cache.pkgconfig"
+    PKG_CONFIG=`"$outpath/bin/qmake" -cache "$outpath/.qmake.cache.pkgconfig" -spec "$XQMAKESPEC" "$outpath/dummy.pro" -o /dev/null 2>&1 > /dev/null | sed -n -e 's,Project MESSAGE: \(.*\),\1,p'`
+    rm "$outpath/.qmake.cache.pkgconfig" "$outpath/dummy.pro"
+fi
+if [ -z "$PKG_CONFIG" ]; then
+    PKG_CONFIG=`"$WHICH" pkg-config 2>/dev/null`
+fi
+
+# Work out if we can use pkg-config
+if [ "$QT_CROSS_COMPILE" = "yes" ]; then
+    if [ "$QT_FORCE_PKGCONFIG" = "yes" ]; then
+        echo >&2 ""
+        echo >&2 "You have asked to use pkg-config and are cross-compiling."
+        echo >&2 "Please make sure you have a correctly set-up pkg-config"
+        echo >&2 "environment!"
+        echo >&2 ""
+        if [ -z "$PKG_CONFIG_PATH" ]; then
+            echo >&2 ""
+            echo >&2 "Warning: PKG_CONFIG_PATH has not been set.  This could mean"
+            echo >&2 "the host compiler's .pc files will be used. This is probably"
+            echo >&2 "not what you want."
+            echo >&2 ""
+        elif [ -z "$PKG_CONFIG_SYSROOT" ] && [ -z "$PKG_CONFIG_SYSROOT_DIR" ]; then
+            echo >&2 ""
+            echo >&2 "Warning: PKG_CONFIG_SYSROOT/PKG_CONFIG_SYSROOT_DIR has not"
+            echo >&2 "been set. This means your toolchain's .pc files must contain"
+            echo >&2 "the paths to the toolchain's libraries & headers. If configure"
+            echo >&2 "tests are failing, please check these files."
+            echo >&2 ""
+        fi
+    else
+        echo >&2 ""
+        echo >&2 "You have not explicitly asked to use pkg-config and are cross-compiling."
+        echo >&2 "pkg-config will not be used to automatically query cflag/lib parameters for"
+        echo >&2 "dependencies"
+        echo >&2 ""
+        PKG_CONFIG=""
+    fi
+fi
+
+if [ ! -n "$PKG_CONFIG" ]; then
+    QT_CONFIG="$QT_CONFIG no-pkg-config"
+fi
+
+#-------------------------------------------------------------------------------
+# tests that need qmake
+#-------------------------------------------------------------------------------
+
+# parameters: path, name, extra args
+compileTest()
+{
+    path=config.tests/$1
+    name=$2
+    shift 2
+    "$unixtests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" "$path" "$name" $I_FLAGS $L_FLAGS $l_FLAGS $MAC_CONFIG_TEST_COMMANDLINE "$@"
+}
+
+# detect availability of float math.h functions
+if compileTest unix/floatmath "floatmath"; then
+    CFG_USE_FLOATMATH=yes
+else
+    CFG_USE_FLOATMATH=no
+fi
+
+# detect mmx support
+if [ "${CFG_MMX}" = "auto" ]; then
+    if compileTest unix/mmx "mmx" "-mmmx"; then
+	CFG_MMX=yes
+    else
+	CFG_MMX=no
+    fi
+fi
+
+# detect 3dnow support
+if [ "${CFG_3DNOW}" = "auto" ]; then
+    if compileTest unix/3dnow "3dnow" "-m3dnow"; then
+	CFG_3DNOW=yes
+    else
+	CFG_3DNOW=no
+    fi
+fi
+
+# detect sse support
+if [ "${CFG_SSE}" = "auto" ]; then
+    if compileTest unix/sse "sse" "-msse"; then
+	CFG_SSE=yes
+    else
+	CFG_SSE=no
+    fi
+fi
+
+# detect sse2 support
+if [ "${CFG_SSE2}" = "auto" ]; then
+    if compileTest unix/sse2 "sse2" "-msse2"; then
+       CFG_SSE2=yes
+    else
+       CFG_SSE2=no
+    fi
+fi
+
+# detect sse3 support
+if [ "${CFG_SSE3}" = "auto" ]; then
+    if compileTest unix/sse3 "sse3" "-msse3"; then
+       CFG_SSE3=yes
+    else
+       CFG_SSE3=no
+    fi
+fi
+
+# detect ssse3 support
+if [ "${CFG_SSSE3}" = "auto" ]; then
+    if compileTest unix/ssse3 "ssse3" "-mssse3"; then
+       CFG_SSSE3=yes
+    else
+       CFG_SSSE3=no
+    fi
+fi
+
+# detect sse4.1 support
+if [ "${CFG_SSE4_1}" = "auto" ]; then
+    if compileTest unix/sse4_1 "sse4_1" "-msse4.1"; then
+       CFG_SSE4_1=yes
+    else
+       CFG_SSE4_1=no
+    fi
+fi
+
+# detect sse4.2 support
+if [ "${CFG_SSE4_2}" = "auto" ]; then
+    if compileTest unix/sse4_2 "sse4_2" "-msse4.2"; then
+       CFG_SSE4_2=yes
+    else
+       CFG_SSE4_2=no
+    fi
+fi
+
+# detect avx support
+if [ "${CFG_AVX}" = "auto" ]; then
+    if compileTest unix/avx "avx" "-mavx"; then
+       CFG_AVX=yes
+    else
+       CFG_AVX=no
+    fi
+fi
+
+# check iWMMXt support
+if [ "$CFG_IWMMXT" = "yes" ]; then
+    compileTest unix/iwmmxt "iwmmxt" "-mcpu=iwmmxt"
+    if [ $? != "0" ]; then
+        echo "The iWMMXt functionality test failed!"
+	echo " Please make sure your compiler supports iWMMXt intrinsics!"
+	exit 1
+    fi
+fi
+
+# detect neon support
+if [ "$CFG_ARCH" = "arm" ] && [ "${CFG_NEON}" = "auto" ]; then
+    if compileTest unix/neon "neon" "-mfpu=neon"; then
+	CFG_NEON=yes
+    else
+	CFG_NEON=no
+    fi
+fi
+
+[ "$XPLATFORM_MINGW" = "yes" ] && QMakeVar add styles "windowsxp windowsvista"
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    QMakeVar set styles "windows s60"   #overwrite previous default
+    CFG_LIBFREETYPE=no
+    CFG_ZLIB=yes
+
+    if [ "$CFG_LARGEFILE" = auto ]; then
+        CFG_LARGEFILE=no
+    fi
+    if [ "$CFG_PHONON" = auto ]; then
+        CFG_PHONON=yes
+    fi
+
+    if test -z "$EPOCROOT"; then
+        echo "Please export EPOCROOT. It should point to the sdk install dir"
+        exit 1
+    fi
+    if test ! -d "$EPOCROOT/epoc32"; then
+        echo "Could not find the 'epoc32' dir in your EPOCROOT."
+        exit 1
+    fi
+
+    if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+        # Raptor does not support configure tests.
+
+        # the main commands needed to compile;
+        (mkdir -p config.tests/symbian/rcomp
+            cd config.tests/symbian/rcomp
+            rm -f rcomp_test.rsg
+            touch rcomp_test.rpp rcomp_test.rsc rcomp_test.rss
+            rcomp -u -m045,046,047 -s./rcomp_test.rpp -o./rcomp_test.rsc -h./rcomp_test.rsg -i./rcomp_test.rss 2>&1 > /dev/null
+            if test ! -f rcomp_test.rsg; then
+                echo "Finding a working rcomp in your PATH failed."
+                echo "Fatal error. Make sure you have the epoc tools working and in your PATH";
+                exit 1;
+            fi
+        )
+
+        # compile a simple main that uses printf
+        if ! "$symbiantests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/symbian/simple "simple" $L_FLAGS $I_FLAGS $l_FLAGS
+        then
+            echo "Testing your compiler failed. Could not compile a simple application."
+            echo "Fatal error; Rerun configure with -verbose to get more details."
+            exit 1;
+        fi
+    fi
+fi
+# Adjust all variables for INTEGRITY
+if [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    QMakeVar set gfx-drivers "integrityfb"
+    QMakeVar set kbd-drivers "integrity"
+    QMakeVar set mouse-drivers "integrity"
+    CFG_TIFF="no"
+    CFG_KBD_ON="integrity"
+    CFG_MOUSE_ON="integrity"
+    CFG_GFX_ON="integrityfb"
+    CFG_LARGEFILE="no"
+    CFG_STL="yes"
+    CFG_OPENSSL="no"
+    CFG_GLIB="no"
+    CFG_SHARED="no"
+    if [ "$CFG_SCRIPT" != "yes" ]; then
+      CFG_SCRIPT="no"
+    fi
+    CFG_BUILD_PARTS="libs examples demos"
+    CFG_GIF="no"
+fi
+
+# check IPC support
+if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    # Raptor does not support configure tests.
+    if ! compileTest unix/ipc_sysv "ipc_sysv" ; then
+        # SYSV IPC is not supported - check POSIX IPC
+        if compileTest unix/ipc_posix "ipc_posix" ; then
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_POSIX_IPC"
+        else
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SYSTEMSEMAPHORE QT_NO_SHAREDMEMORY"
+            if [ "$PLATFORM_QWS" = "yes" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SEMAPHORE QT_NO_QWS_MULTIPROCESS QT_NO_QWS_SHARE_FONTS"
+            fi
+        fi
+    fi
+fi
+
+# detect zlib
+if [ "$CFG_ZLIB" = "no" ]; then
+    # Note: Qt no longer support builds without zlib
+    # So we force a "no" to be "auto" here.
+    # If you REALLY really need no zlib support, you can still disable
+    # it by doing the following:
+    #   add "no-zlib" to mkspecs/qconfig.pri
+    #   #define QT_NO_COMPRESS (probably by adding to src/corelib/global/qconfig.h)
+    #
+    # There's no guarantee that Qt will build under those conditions
+
+    CFG_ZLIB=auto
+    ZLIB_FORCED=yes
+fi
+if [ "$CFG_ZLIB" = "auto" ]; then
+    if compileTest unix/zlib "zlib"; then
+       CFG_ZLIB=system
+    else
+       CFG_ZLIB=yes
+    fi
+fi
+
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    if [ "$CFG_SLOG2" != "no" ]; then
+        if compileTest unix/slog2 "slog2"; then
+            CFG_SLOG2=yes
+            QMAKE_CONFIG="$QMAKE_CONFIG slog2"
+        else
+            CFG_SLOG2=no
+        fi
+    fi
+fi
+
+if [ "$CFG_LARGEFILE" = "auto" ]; then
+    #Large files should be enabled for all Linux systems
+    CFG_LARGEFILE=yes
+fi
+
+
+if [ "$CFG_S60" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        CFG_S60=yes
+    else
+        CFG_S60=no
+    fi
+fi
+
+if [ "$CFG_QS60STYLE" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        CFG_QS60STYLE=qt
+    else
+        CFG_QS60STYLE=no
+    fi
+fi
+
+if [ "$CFG_SYMBIAN_DEFFILES" = "auto" ]; then
+    # elf2e32 crashes when using def files together with gcce.
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ] && [ "$CFG_DEV" = "no" ] && [ "$XPLATFORM" != "symbian-gcce" ]; then
+        CFG_SYMBIAN_DEFFILES=yes
+    else
+        CFG_SYMBIAN_DEFFILES=no
+    fi
+fi
+
+# detect how jpeg should be built
+if [ "$CFG_JPEG" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_JPEG=plugin
+    else
+        CFG_JPEG=yes
+    fi
+fi
+# detect jpeg
+if [ "$CFG_LIBJPEG" = "auto" ]; then
+    if compileTest unix/libjpeg "libjpeg"; then
+       CFG_LIBJPEG=system
+    else
+       CFG_LIBJPEG=qt
+    fi
+fi
+
+# detect how gif should be built
+if [ "$CFG_GIF" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_GIF=plugin
+    else
+        CFG_GIF=yes
+    fi
+fi
+
+# detect how tiff should be built
+if [ "$CFG_TIFF" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_TIFF=plugin
+    else
+        CFG_TIFF=yes
+    fi
+fi
+
+# detect tiff
+if [ "$CFG_LIBTIFF" = "auto" ]; then
+    if compileTest unix/libtiff "libtiff"; then
+        CFG_LIBTIFF=system
+    else
+        CFG_LIBTIFF=qt
+    fi
+fi
+
+# detect how mng should be built
+if [ "$CFG_MNG" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_MNG=plugin
+    else
+        CFG_MNG=yes
+    fi
+fi
+# detect mng
+if [ "$CFG_LIBMNG" = "auto" ]; then
+    if compileTest unix/libmng "libmng"; then
+       CFG_LIBMNG=system
+    else
+       CFG_LIBMNG=qt
+    fi
+fi
+
+# detect png
+if [ "$CFG_LIBPNG" = "auto" ]; then
+    if compileTest unix/libpng "libpng"; then
+       CFG_LIBPNG=system
+    else
+       CFG_LIBPNG=qt
+    fi
+fi
+
+# detect accessibility
+if [ "$CFG_ACCESSIBILITY" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        # accessibility is currently unsupported
+        CFG_ACCESSIBILITY=no
+    else
+        CFG_ACCESSIBILITY=yes
+    fi
+fi
+
+# auto-detect SQL-modules support
+for _SQLDR in $CFG_SQL_AVAILABLE; do
+        case $_SQLDR in
+        mysql)
+            if [ "$CFG_SQL_mysql" != "no" ]; then
+		[ -z "$CFG_MYSQL_CONFIG" ] && CFG_MYSQL_CONFIG=`"$WHICH" mysql_config`
+                if [ -x "$CFG_MYSQL_CONFIG" ]; then
+                    QT_CFLAGS_MYSQL=`$CFG_MYSQL_CONFIG --include 2>/dev/null`
+                    QT_LFLAGS_MYSQL_R=`$CFG_MYSQL_CONFIG --libs_r 2>/dev/null`
+                    QT_LFLAGS_MYSQL=`$CFG_MYSQL_CONFIG --libs 2>/dev/null`
+		    QT_MYSQL_VERSION=`$CFG_MYSQL_CONFIG --version 2>/dev/null`
+                    QT_MYSQL_VERSION_MAJOR=`echo $QT_MYSQL_VERSION | cut -d . -f 1`
+                fi
+                if [ -n "$QT_MYSQL_VERSION" ] && [ "$QT_MYSQL_VERSION_MAJOR" -lt 4 ]; then
+                    if [ "$CFG_SQL_mysql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "This version of MySql is not supported ($QT_MYSQL_VERSION)."
+                        echo " You need MySql 4 or higher."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_mysql="no"
+			QT_LFLAGS_MYSQL=""
+			QT_LFLAGS_MYSQL_R=""
+			QT_CFLAGS_MYSQL=""
+                    fi
+                else
+                    if compileTest unix/mysql_r "MySQL (thread-safe)" $QT_LFLAGS_MYSQL_R $QT_CFLAGS_MYSQL; then
+                        QMakeVar add CONFIG use_libmysqlclient_r
+                        if [ "$CFG_SQL_mysql" = "auto" ]; then
+                            CFG_SQL_mysql=plugin
+                        fi
+                        QT_LFLAGS_MYSQL="$QT_LFLAGS_MYSQL_R"
+                    elif compileTest unix/mysql "MySQL (thread-unsafe)" $QT_LFLAGS_MYSQL $QT_CFLAGS_MYSQL; then
+                        if [ "$CFG_SQL_mysql" = "auto" ]; then
+                            CFG_SQL_mysql=plugin
+                        fi
+                    else
+                        if [ "$CFG_SQL_mysql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                            echo "MySQL support cannot be enabled due to functionality tests!"
+                            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                            echo " If you believe this message is in error you may use the continue"
+                            echo " switch (-continue) to $0 to continue."
+                            exit 101
+                        else
+                            CFG_SQL_mysql=no
+			    QT_LFLAGS_MYSQL=""
+			    QT_LFLAGS_MYSQL_R=""
+			    QT_CFLAGS_MYSQL=""
+                        fi
+                    fi
+                fi
+            fi
+            ;;
+        psql)
+            if [ "$CFG_SQL_psql" != "no" ]; then
+                # Be careful not to use native pg_config when cross building.
+                if [ "$XPLATFORM_MINGW" != "yes" ] && "$WHICH" pg_config >/dev/null 2>&1; then
+                    QT_CFLAGS_PSQL=`pg_config --includedir 2>/dev/null`
+                    QT_LFLAGS_PSQL=`pg_config --libdir 2>/dev/null`
+                fi
+                [ -z "$QT_CFLAGS_PSQL" ] || QT_CFLAGS_PSQL="-I$QT_CFLAGS_PSQL"
+                [ -z "$QT_LFLAGS_PSQL" ] || QT_LFLAGS_PSQL="-L$QT_LFLAGS_PSQL"
+                # But, respect PSQL_LIBS if set
+                [ -z "$PSQL_LIBS" ] || QT_LFLAGS_PSQL="$PSQL_LIBS"
+                if compileTest unix/psql "PostgreSQL" $QT_LFLAGS_PSQL $QT_CFLAGS_PSQL; then
+                    if [ "$CFG_SQL_psql" = "auto" ]; then
+                        CFG_SQL_psql=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_psql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "PostgreSQL support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_psql=no
+                        QT_CFLAGS_PSQL=""
+                        QT_LFLAGS_PSQL=""
+                    fi
+                fi
+            fi
+        ;;
+        odbc)
+            if [ "$CFG_SQL_odbc" != "no" ]; then
+                if ( [ "$PLATFORM_MAC" != "yes" ] || [ "$XPLATFORM_MINGW" = "yes" ] ) && compileTest unix/odbc "ODBC"; then
+                    if [ "$CFG_SQL_odbc" = "auto" ]; then
+                        CFG_SQL_odbc=plugin
+                    fi
+                else
+                    if compileTest unix/iodbc "iODBC"; then
+                        QT_LFLAGS_ODBC="-liodbc"
+                        if [ "$CFG_SQL_odbc" = "auto" ]; then
+                            CFG_SQL_odbc=plugin
+                        fi
+                    else
+                        if [ "$CFG_SQL_odbc" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                            echo "ODBC support cannot be enabled due to functionality tests!"
+                            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                            echo " If you believe this message is in error you may use the continue"
+                            echo " switch (-continue) to $0 to continue."
+                            exit 101
+                        else
+                            CFG_SQL_odbc=no
+                        fi
+                    fi
+                fi
+            fi
+            ;;
+        oci)
+            if [ "$CFG_SQL_oci" != "no" ]; then
+                if compileTest unix/oci "OCI"; then
+                    if [ "$CFG_SQL_oci" = "auto" ]; then
+                        CFG_SQL_oci=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_oci" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "Oracle (OCI) support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_oci=no
+                    fi
+                fi
+            fi
+            ;;
+        tds)
+            if [ "$CFG_SQL_tds" != "no" ]; then
+                [ -z "$SYBASE" ] || QT_LFLAGS_TDS="-L$SYBASE/lib"
+                [ -z "$SYBASE_LIBS" ] || QT_LFLAGS_TDS="$QT_LFLAGS_TDS $SYBASE_LIBS"
+                if compileTest unix/tds "TDS" $QT_LFLAGS_TDS; then
+                    if [ "$CFG_SQL_tds" = "auto" ]; then
+                        CFG_SQL_tds=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_tds" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "TDS support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_tds=no
+                    fi
+                fi
+            fi
+            ;;
+        db2)
+            if [ "$CFG_SQL_db2" != "no" ]; then
+                if compileTest unix/db2 "DB2"; then
+                    if [ "$CFG_SQL_db2" = "auto" ]; then
+                        CFG_SQL_db2=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_db2" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "ODBC support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_db2=no
+                    fi
+                fi
+            fi
+            ;;
+        ibase)
+            if [ "$CFG_SQL_ibase" != "no" ]; then
+                if compileTest unix/ibase "InterBase"; then
+                    if [ "$CFG_SQL_ibase" = "auto" ]; then
+                        CFG_SQL_ibase=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_ibase" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "InterBase support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_ibase=no
+                    fi
+                fi
+            fi
+            ;;
+        sqlite2)
+            if [ "$CFG_SQL_sqlite2" != "no" ]; then
+                if compileTest unix/sqlite2 "SQLite2"; then
+                    if [ "$CFG_SQL_sqlite2" = "auto" ]; then
+                        CFG_SQL_sqlite2=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_sqlite2" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "SQLite2 support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_sqlite2=no
+                    fi
+                fi
+            fi
+            ;;
+        sqlite)
+            if [ "$CFG_SQL_sqlite" = "auto" ]; then # the default
+                if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+                    # sqlite on symbian is typically not build in Qt but deployed as a pre-existing sis file and should be marked as driver.
+                    # Configuration parameters should be set
+                    CFG_SQL_sqlite=qt
+                    QT_LFLAGS_SQLITE=-lsqlite3
+                    QMAKE_CONFIG="$QMAKE_CONFIG system-sqlite"
+                fi
+            fi
+            if [ "$CFG_SQL_sqlite" != "no" ]; then
+                SQLITE_AUTODETECT_FAILED="no"
+                if [ "$CFG_SQLITE" = "system" ]; then
+                    if [ -n "$PKG_CONFIG" ]; then
+                        QT_CFLAGS_SQLITE=`$PKG_CONFIG --cflags sqlite3 2>/dev/null`
+                        QT_LFLAGS_SQLITE=`$PKG_CONFIG --libs sqlite3 2>/dev/null`
+                    else
+                        QT_CFLAGS_SQLITE=
+                        QT_LFLAGS_SQLITE="-lsqlite3 -lz"
+                    fi
+                    if compileTest unix/sqlite "SQLite" $QT_LFLAGS_SQLITE $QT_CFLAGS_SQLITE; then
+                        if [ "$CFG_SQL_sqlite" = "auto" ]; then
+                            CFG_SQL_sqlite=plugin
+                        fi
+                        QMAKE_CONFIG="$QMAKE_CONFIG system-sqlite"
+                    else
+                        SQLITE_AUTODETECT_FAILED="yes"
+                        CFG_SQL_sqlite=no
+                    fi
+                elif [ -f "$relpath/src/3rdparty/sqlite/sqlite3.h" ]; then
+                    if [ "$CFG_SQL_sqlite" = "auto" ]; then
+                            CFG_SQL_sqlite=plugin
+                    fi
+                else
+                    SQLITE_AUTODETECT_FAILED="yes"
+                    CFG_SQL_sqlite=no
+                fi
+
+                if [ "$SQLITE_AUTODETECT_FAILED" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "SQLite support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                fi
+            fi
+            ;;
+        *)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "unknown SQL driver: $_SQLDR"
+            fi
+            ;;
+        esac
+done
+
+# auto-detect NIS support
+if [ "$CFG_NIS" != "no" ]; then
+    if compileTest unix/nis "NIS"; then
+        CFG_NIS=yes
+    else
+        if [ "$CFG_NIS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "NIS support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_NIS=no
+        fi
+    fi
+fi
+
+# auto-detect CUPS support
+if [ "$CFG_CUPS" != "no" ]; then
+    if compileTest unix/cups "Cups"; then
+        CFG_CUPS=yes
+    else
+        if [ "$CFG_CUPS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "Cups support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_CUPS=no
+        fi
+    fi
+fi
+
+# auto-detect iconv(3) support
+if [ "$CFG_ICONV" != "no" ]; then
+    if [ "$PLATFORM_QWS" = "yes" ] || [ "$PLATFORM_QPA" = "yes" -a "$CFG_ICONV" = "auto" ]; then
+        CFG_ICONV=no
+    elif compileTest "unix/iconv" "POSIX iconv"; then
+        CFG_ICONV=yes
+    elif compileTest "unix/sun-libiconv" "SUN libiconv"; then
+        CFG_ICONV=sun
+    elif compileTest "unix/gnu-libiconv" "GNU libiconv"; then
+        CFG_ICONV=gnu
+    else
+        if [ "$CFG_ICONV" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "Iconv support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_ICONV=no
+        fi
+    fi
+fi
+
+# auto-detect libdbus-1 support
+if [ "$CFG_DBUS" != "no" ]; then
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --atleast-version="$MIN_DBUS_1_VERSION" dbus-1 2>/dev/null; then
+        QT_CFLAGS_DBUS=`$PKG_CONFIG --cflags dbus-1 2>/dev/null`
+        QT_LIBS_DBUS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
+    fi
+    if compileTest unix/dbus "D-Bus" $QT_CFLAGS_DBUS $QT_LIBS_DBUS; then
+        [ "$CFG_DBUS" = "auto" ] && CFG_DBUS=yes
+        QMakeVar set QT_CFLAGS_DBUS "$QT_CFLAGS_DBUS"
+        QMakeVar set QT_LIBS_DBUS "$QT_LIBS_DBUS"
+    else
+        if [ "$CFG_DBUS" = "auto" ]; then
+            CFG_DBUS=no
+        elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            # CFG_DBUS is "yes" or "linked" here
+
+            echo "The QtDBus module cannot be enabled because libdbus-1 version $MIN_DBUS_1_VERSION was not found."
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_MULTIMEDIA" = "auto" ]; then
+    CFG_MULTIMEDIA="$CFG_GUI"
+fi
+
+if [ "$CFG_MULTIMEDIA" = "yes" ] && [ "$CFG_GUI" = "no" ]; then
+    echo "QtMultimedia requested, but it can't be built without QtGui"
+    exit 1
+fi
+
+# Generate a CRC of the namespace for using in constants for the Carbon port.
+# This should mean that you really *can* load two Qt's and have our custom
+# Carbon events work.
+if [ "$PLATFORM_MAC" = "yes" -a ! -z "$QT_NAMESPACE" ]; then
+    QT_NAMESPACE_MAC_CRC=`"$mactests/crc.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/mac/crc $QT_NAMESPACE $L_FLAGS $I_FLAGS $l_FLAGS $MAC_CONFIG_TEST_COMMANDLINE`
+fi
+
+# X11/QWS/Lighthouse
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+
+    # auto-detect Glib support
+    if [ "$CFG_GLIB" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_GLIB=`$PKG_CONFIG --cflags glib-2.0 gthread-2.0 2>/dev/null`
+            QT_LIBS_GLIB=`$PKG_CONFIG --libs glib-2.0 gthread-2.0 2>/dev/null`
+        fi
+        if compileTest unix/glib "Glib" $QT_CFLAGS_GLIB $QT_LIBS_GLIB $X11TESTS_FLAGS ; then
+            CFG_GLIB=yes
+            QMakeVar set QT_CFLAGS_GLIB "$QT_CFLAGS_GLIB"
+            QMakeVar set QT_LIBS_GLIB "$QT_LIBS_GLIB"
+        else
+            if [ "$CFG_GLIB" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Glib support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_GLIB=no
+            fi
+        fi
+    fi
+
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_PHONON" = "auto" ]; then
+            CFG_PHONON=no
+        fi
+        if [ "$CFG_PHONON" != "no" ]; then
+            echo "Phonon enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable Phonon"
+            exit 1
+        fi
+    fi
+
+    # Auto-detect GStreamer support (needed for Phonon)
+    if [ "$CFG_PHONON" != "no" ]; then
+        if [ "$CFG_GLIB" = "yes" -a "$CFG_GSTREAMER" != "no" ]; then
+            if [ -n "$PKG_CONFIG" ]; then
+                QT_CFLAGS_GSTREAMER=`$PKG_CONFIG --cflags gstreamer-0.10 gstreamer-plugins-base-0.10 2>/dev/null`
+                QT_LIBS_GSTREAMER=`$PKG_CONFIG --libs gstreamer-0.10 gstreamer-plugins-base-0.10 2>/dev/null`
+            fi
+            if compileTest unix/gstreamer "GStreamer" $QT_CFLAGS_GSTREAMER $QT_LIBS_GSTREAMER $X11TESTS_FLAGS; then
+                CFG_GSTREAMER=yes
+                QMakeVar set QT_CFLAGS_GSTREAMER "$QT_CFLAGS_GSTREAMER"
+                QMakeVar set QT_LIBS_GSTREAMER "$QT_LIBS_GSTREAMER"
+            else
+                if [ "$CFG_GSTREAMER" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "Gstreamer support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                else
+                    CFG_GSTREAMER=no
+                fi
+            fi
+        elif [ "$CFG_GLIB" = "no" ]; then
+            CFG_GSTREAMER=no
+        fi
+    else
+        CFG_GSTREAMER=no
+    fi
+
+    if [ "$CFG_PHONON" != "no" ]; then
+        if [ "$CFG_PHONON_BACKEND" != "no" ]; then
+            if [ "$CFG_GSTREAMER" = "yes" ]; then
+                CFG_PHONON=yes
+            else
+                if [ "$CFG_PHONON" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "Phonon support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                else
+                    CFG_PHONON=no
+                fi
+            fi
+        else
+            CFG_PHONON=yes
+        fi
+    fi
+
+    # auto-detect icd support
+    if [ "$CFG_GLIB" = "yes" -a "$CFG_ICD" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_CONNSETTINGS=`$PKG_CONFIG --cflags connsettings icd2 2>/dev/null`
+            QT_LIBS_CONNSETTINGS=`$PKG_CONFIG --libs connsettings icd2 2>/dev/null`
+        fi
+        if compileTest unix/icd "ICD" $QT_CFLAGS_CONNSETTINGS $QT_LIBS_CONNSETTINGS; then
+            [ "$CFG_ICD" = "auto" ] && CFG_ICD=yes
+            QMakeVar set QT_CFLAGS_CONNSETTINGS "$QT_CFLAGS_CONNSETTINGS"
+            QMakeVar set QT_LIBS_CONNSETTINGS "$QT_LIBS_CONNSETTINGS"
+        else
+            if [ "$CFG_ICD" = "auto" ]; then
+                CFG_ICD=no
+            elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                # CFG_ICD is "yes"
+
+                echo "The ICD Bearer Management plugin cannot be enabled because connsettings was not found."
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            fi
+        fi
+    elif [ "$CFG_GLIB" = "no" ]; then
+        CFG_ICD=no
+    fi
+
+    # auto-detect libicu support
+    if [ "$CFG_ICU" != "no" ]; then
+        if compileTest unix/icu "ICU"; then
+            [ "$CFG_ICU" = "auto" ] && CFG_ICU=yes
+        else
+            if [ "$CFG_ICU" = "auto" ]; then
+                CFG_ICU=no
+            elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                # CFG_ICU is "yes"
+
+                echo "The ICU library support cannot be enabled."
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            fi
+        fi
+    fi
+
+    # Auto-detect PulseAudio support
+    if [ "$CFG_PULSEAUDIO" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_PULSEAUDIO=`$PKG_CONFIG --cflags libpulse '>=' 0.9.10 libpulse-mainloop-glib 2>/dev/null`
+            QT_LIBS_PULSEAUDIO=`$PKG_CONFIG --libs libpulse '>=' 0.9.10 libpulse-mainloop-glib 2>/dev/null`
+        fi
+        if compileTest unix/pulseaudio "PulseAudio" $QT_CFLAGS_PULSEAUDIO $QT_LIBS_PULSEAUDIO $X11TESTS_FLAGS; then
+            CFG_PULSEAUDIO=yes
+            QMakeVar set QT_CFLAGS_PULSEAUDIO "$QT_CFLAGS_PULSEAUDIO"
+            QMakeVar set QT_LIBS_PULSEAUDIO "$QT_LIBS_PULSEAUDIO"
+        else
+            if [ "$CFG_PULSEAUDIO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "PulseAudio support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+		CFG_PULSEAUDIO=no
+            fi
+        fi
+    fi
+fi # X11/QWS/Lighthouse
+
+# X11
+if [ "$PLATFORM_X11" = "yes" -a "$CFG_GUI" != "no" ]; then
+    x11tests="$relpath/config.tests/x11"
+    X11TESTS_FLAGS=
+
+    # work around broken X11 headers when using GCC 2.95 or later
+    NOTYPE=no
+    "$x11tests/notype.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath" && NOTYPE=yes
+    if [ $NOTYPE = "yes" ]; then
+	QMakeVar add QMAKE_CXXFLAGS -fpermissive
+        X11TESTS_FLAGS="$X11TESTS_FLAGS -fpermissive"
+    fi
+
+    # Check we actually have X11 :-)
+    compileTest x11/xlib "XLib" $X11TESTS_FLAGS
+    if [ $? != "0" ]; then
+        echo "Basic XLib functionality test failed!"
+        echo " You might need to modify the include and library search paths by editing"
+        echo " QMAKE_INCDIR_X11 and QMAKE_LIBDIR_X11 in ${XQMAKESPEC}."
+        exit 1
+    fi
+fi
+
+# X11/MINGW/SYMBIAN OpenGL
+if [ "$PLATFORM_X11" = "yes" -o "$XPLATFORM_MINGW" = "yes" -o "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL=no
+        fi
+        if [ "$CFG_OPENGL" != "no" ]; then
+            echo "OpenGL enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable OpenGL"
+            exit 1
+        fi
+    fi
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        if compileTest x11/opengl "OpenGL" $X11TESTS_FLAGS; then
+            CFG_OPENGL=desktop
+        elif compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+            if [ "$CFG_EGL" = "no" ]; then
+                CFG_EGL=auto
+            fi
+        elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+            if [ "$CFG_EGL" = "no" ]; then
+                CFG_EGL=auto
+            fi
+        else
+            if [ "$CFG_OPENGL" = "yes" ]; then
+                echo "All the OpenGL functionality tests failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_OPENGL=no
+        fi
+        case "$PLATFORM" in
+        hpux*)
+            # HP-UX have buggy glx headers; check if we really need to define the GLXFBConfig struct.
+            if [ "$CFG_OPENGL" = "desktop" ]; then
+                compileTest x11/glxfbconfig "OpenGL" $X11TESTS_FLAGS
+                if [ $? != "0" ]; then
+                    QMakeVar add DEFINES QT_DEFINE_GLXFBCONFIG_STRUCT
+                fi
+            fi
+            ;;
+        *)
+            ;;
+        esac
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES1, QMAKE_LIBDIR_OPENGL_ES1 and QMAKE_LIBS_OPENGL_ES1 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+            # Raptor does not support configure tests.
+            compileTest unix/opengles2 "OpenGL ES 2.x"
+            if [ $? != "0" ]; then
+                echo "The OpenGL ES 2.0 functionality test failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL_ES2, QMAKE_LIBDIR_OPENGL_ES2 and QMAKE_LIBS_OPENGL_ES2 in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+        fi
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        compileTest x11/opengl "OpenGL" $X11TESTS_FLAGS
+        if [ $? != "0" ]; then
+            echo "The OpenGL functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        case "$PLATFORM" in
+        hpux*)
+            # HP-UX have buggy glx headers; check if we really need to define the GLXFBConfig struct.
+            compileTest x11/glxfbconfig "OpenGL" $X11TESTS_FLAGS
+            if [ $? != "0" ]; then
+                QMakeVar add DEFINES QT_DEFINE_GLXFBCONFIG_STRUCT
+            fi
+            ;;
+        *)
+            ;;
+        esac
+    fi
+
+    # if opengl is disabled and the user specified graphicssystem gl, disable it...
+    if [ "$CFG_GRAPHICS_SYSTEM" = "opengl" ] && [ "$CFG_OPENGL" = "no" ]; then
+	echo "OpenGL Graphics System is disabled due to missing OpenGL support..."
+	CFG_GRAPHICS_SYSTEM=default
+    fi
+fi # X11/MINGW OpenGL
+
+# X11
+if [ "$PLATFORM_X11" = "yes" ]; then
+    # auto-detect Xcursor support
+    if [ "$CFG_XCURSOR" != "no" ]; then
+        if compileTest x11/xcursor "Xcursor" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XCURSOR" != "runtime" ]; then
+		CFG_XCURSOR=yes;
+	    fi
+	else
+	    if [ "$CFG_XCURSOR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xcursor support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XCURSOR=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xfixes support
+    if [ "$CFG_XFIXES" != "no" ]; then
+        if compileTest x11/xfixes "Xfixes" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XFIXES" != "runtime" ]; then
+		CFG_XFIXES=yes;
+	    fi
+	else
+	    if [ "$CFG_XFIXES" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xfixes support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XFIXES=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xrandr support (resize and rotate extension)
+    if [ "$CFG_XRANDR" != "no" ]; then
+        if compileTest x11/xrandr "Xrandr" $X11TESTS_FLAGS; then
+            if [ "$CFG_XRANDR" != "runtime" ]; then
+	    CFG_XRANDR=yes
+            fi
+	else
+	    if [ "$CFG_XRANDR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xrandr support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRANDR=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xrender support
+    if [ "$CFG_XRENDER" != "no" ]; then
+        if compileTest x11/xrender "Xrender" $X11TESTS_FLAGS; then
+	    CFG_XRENDER=yes
+	else
+	    if [ "$CFG_XRENDER" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xrender support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRENDER=no
+	    fi
+	fi
+    fi
+
+    # Additional check to decide if WebKit support will be included
+    if [ "$CFG_XRENDER" = "no" ] && [ "$CFG_WEBKIT" != "no" ]; then
+        echo "Warning: -no-xrender will disable the QtWebkit module."
+        CFG_WEBKIT="no"
+    fi
+
+    # auto-detect MIT-SHM support
+    if [ "$CFG_MITSHM" != "no" ]; then
+        if compileTest x11/mitshm "mitshm" $X11TESTS_FLAGS; then
+	    CFG_MITSHM=yes
+	else
+	    if [ "$CFG_MITSHM" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "MITSHM support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_MITSHM=no
+	    fi
+	fi
+    fi
+
+    # auto-detect FontConfig support
+    if [ "$CFG_FONTCONFIG" != "no" ]; then
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists fontconfig --exists freetype2 2>/dev/null; then
+        QT_CFLAGS_FONTCONFIG=`$PKG_CONFIG --cflags fontconfig --cflags freetype2 2>/dev/null`
+        QT_LIBS_FONTCONFIG=`$PKG_CONFIG --libs fontconfig --libs freetype2 2>/dev/null`
+    else
+        QT_CFLAGS_FONTCONFIG=
+        QT_LIBS_FONTCONFIG="-lfreetype -lfontconfig"
+    fi
+    if compileTest x11/fontconfig "FontConfig" $X11TESTS_FLAGS $QT_CFLAGS_FONTCONFIG $QT_LIBS_FONTCONFIG; then
+	    CFG_FONTCONFIG=yes
+        QMakeVar set QMAKE_CFLAGS_X11 "$QT_CFLAGS_FONTCONFIG \$\$QMAKE_CFLAGS_X11"
+        QMakeVar set QMAKE_LIBS_X11 "$QT_LIBS_FONTCONFIG \$\$QMAKE_LIBS_X11"
+	    CFG_LIBFREETYPE=system
+	else
+	    if [ "$CFG_FONTCONFIG" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "FontConfig support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_FONTCONFIG=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Session Management support
+    if [ "$CFG_SM" = "auto" ]; then
+        if compileTest x11/sm "Session Management" $X11TESTS_FLAGS; then
+	    CFG_SM=yes
+	else
+	    if [ "$CFG_SM" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Session Management support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_SM=no
+	    fi
+	fi
+    fi
+
+    # auto-detect SHAPE support
+    if [ "$CFG_XSHAPE" != "no" ]; then
+        if compileTest x11/xshape "XShape" $X11TESTS_FLAGS; then
+	    CFG_XSHAPE=yes
+	else
+	    if [ "$CFG_XSHAPE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XShape support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XSHAPE=no
+	    fi
+	fi
+    fi
+
+    # auto-detect XVideo support
+    if [ "$CFG_XVIDEO" != "no" ]; then
+        if compileTest x11/xvideo "XVideo" $X11TESTS_FLAGS; then
+	    CFG_XVIDEO=yes
+	else
+	    if [ "$CFG_XVIDEO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XVideo support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XVIDEO=no
+	    fi
+	fi
+    fi
+
+    # auto-detect XSync support
+    if [ "$CFG_XSYNC" != "no" ]; then
+        if compileTest x11/xsync "XSync" $X11TESTS_FLAGS; then
+	    CFG_XSYNC=yes
+	else
+	    if [ "$CFG_XSYNC" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XSync support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XSYNC=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xinerama support
+    if [ "$CFG_XINERAMA" != "no" ]; then
+        if compileTest x11/xinerama "Xinerama" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XINERAMA" != "runtime" ]; then
+		CFG_XINERAMA=yes
+	    fi
+	else
+	    if [ "$CFG_XINERAMA" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xinerama support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XINERAMA=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xinput support
+    if [ "$CFG_XINPUT" != "no" ]; then
+        if compileTest x11/xinput "XInput" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XINPUT" != "runtime" ]; then
+		CFG_XINPUT=yes
+	    fi
+        else
+            if [ "$CFG_XINPUT" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Tablet and Xinput support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_XINPUT=no
+            fi
+        fi
+    fi
+
+    # auto-detect XKB support
+    if [ "$CFG_XKB" != "no" ]; then
+        if compileTest x11/xkb "XKB" $X11TESTS_FLAGS; then
+            CFG_XKB=yes
+        else
+            if [ "$CFG_XKB" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "XKB support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_XKB=no
+            fi
+        fi
+    fi
+
+    if [ "$CFG_GLIB" = "yes" -a "$CFG_QGTKSTYLE" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_QGTKSTYLE=`$PKG_CONFIG --cflags gtk+-2.0 ">=" 2.10 atk 2>/dev/null`
+            QT_LIBS_QGTKSTYLE=`$PKG_CONFIG --libs gobject-2.0 2>/dev/null`
+        fi
+        if [ -n "$QT_CFLAGS_QGTKSTYLE" ] ; then
+            CFG_QGTKSTYLE=yes
+            QMakeVar set QT_CFLAGS_QGTKSTYLE "$QT_CFLAGS_QGTKSTYLE"
+            QMakeVar set QT_LIBS_QGTKSTYLE "$QT_LIBS_QGTKSTYLE"
+        else
+            if [ "$CFG_QGTKSTYLE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Gtk theme support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_QGTKSTYLE=no
+            fi
+        fi
+    elif [ "$CFG_GLIB" = "no" ]; then
+        CFG_QGTKSTYLE=no
+    fi
+fi # X11
+
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_PHONON" != "no" ]; then
+        # Always enable Phonon (unless it was explicitly disabled)
+        CFG_PHONON=yes
+    fi
+
+    if [ "$CFG_COREWLAN" = "auto" ]; then
+        if compileTest mac/corewlan "CoreWlan"; then
+            CFG_COREWLAN=yes
+        else
+            CFG_COREWLAN=no
+        fi
+    fi
+fi
+
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        if compileTest unix/opengldesktop "OpenGL" $X11TESTS_FLAGS; then
+            CFG_OPENGL=desktop
+        elif compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+        elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+        else
+            if [ "$CFG_OPENGL" = "yes" ]; then
+                echo "All the OpenGL functionality tests failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_OPENGL=no
+        fi
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES1, QMAKE_LIBDIR_OPENGL_ES1 and QMAKE_LIBS_OPENGL_ES1 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists glesv2 2>/dev/null; then
+            QMAKE_INCDIR_OPENGL_ES2=`$PKG_CONFIG --variable=includedir glesv2 2>/dev/null`
+            QMAKE_LIBDIR_OPENGL_ES2=`$PKG_CONFIG --variable=libdir glesv2 2>/dev/null`
+            QMAKE_LIBS_OPENGL_ES2=`$PKG_CONFIG --libs glesv2 2>/dev/null`
+            QMAKE_CFLAGS_OPENGL_ES2=`$PKG_CONFIG --cflags glesv2 2>/dev/null`
+            QMakeVar set QMAKE_INCDIR_OPENGL_ES2 "$QMAKE_INCDIR_OPENGL_ES2"
+            QMakeVar set QMAKE_LIBDIR_OPENGL_ES2 "$QMAKE_LIBDIR_OPENGL_ES2"
+            QMakeVar set QMAKE_LIBS_OPENGL_ES2 "$QMAKE_LIBS_OPENGL_ES2"
+        fi
+
+        compileTest unix/opengles2 "OpenGL ES 2.x" $QMAKE_LIBS_OPENGL_ES2 $QMAKE_CFLAGS_OPENGL_ES2
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 2.0 functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES2, QMAKE_LIBDIR_OPENGL_ES2 and QMAKE_LIBS_OPENGL_ES2 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        compileTest unix/opengldesktop "OpenGL" $X11TESTS_FLAGS
+        if [ $? != "0" ]; then
+            echo "The OpenGL functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    fi
+
+    # auto-detect FontConfig support
+    if [ "$CFG_FONTCONFIG" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists fontconfig --exists freetype2 2>/dev/null; then
+            QT_CFLAGS_FONTCONFIG=`$PKG_CONFIG --cflags fontconfig --cflags freetype2 2>/dev/null`
+            QT_LIBS_FONTCONFIG=`$PKG_CONFIG --libs fontconfig --libs freetype2 2>/dev/null`
+        else
+            QT_CFLAGS_FONTCONFIG=
+            QT_LIBS_FONTCONFIG="-lfreetype -lfontconfig"
+        fi
+        if compileTest x11/fontconfig "FontConfig" $X11TESTS_FLAGS $QT_CFLAGS_FONTCONFIG $QT_LIBS_FONTCONFIG; then
+                QT_CONFIG="$QT_CONFIG fontconfig"
+                QMakeVar set QMAKE_CFLAGS_FONTCONFIG "$QT_CFLAGS_FONTCONFIG"
+                QMakeVar set QMAKE_LIBS_FONTCONFIG "$QT_LIBS_FONTCONFIG"
+                CFG_LIBFREETYPE=system
+        fi
+
+    fi
+
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists wayland-client 2>/dev/null; then
+        QMAKE_CFLAGS_WAYLAND=`$PKG_CONFIG --cflags wayland-client 2>/dev/null`
+        QMAKE_LIBS_WAYLAND=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+        QMAKE_INCDIR_WAYLAND=`$PKG_CONFIG --variable=includedir wayland-client 2>/dev/null`
+        QMAKE_LIBDIR_WAYLAND=`$PKG_CONFIG --variable=libdir wayland-client 2>/dev/null`
+
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists xkbcommon 2>/dev/null; then
+            QMAKE_CFLAGS_WAYLAND="$QMAKE_CFLAGS_WAYLAND `$PKG_CONFIG --cflags xkbcommon 2>/dev/null`"
+            QMAKE_LIBS_WAYLAND="$QMAKE_LIBS_WAYLAND `$PKG_CONFIG --libs xkbcommon 2>/dev/null`"
+        else
+            QMAKE_DEFINES_WAYLAND=QT_NO_WAYLAND_XKB
+        fi
+    fi
+
+    # QMake variables set here override those in the mkspec. Therefore we only set the variables here if they are not zero.
+    if [ -n "$QMAKE_CFLAGS_WAYLAND" ] || [ -n "$QMAKE_LIBS_WAYLAND" ]; then
+        QMakeVar set QMAKE_CFLAGS_WAYLAND "$QMAKE_CFLAGS_WAYLAND"
+        QMakeVar set QMAKE_INCDIR_WAYLAND "$QMAKE_INCDIR_WAYLAND"
+        QMakeVar set QMAKE_LIBS_WAYLAND "$QMAKE_LIBS_WAYLAND"
+        QMakeVar set QMAKE_LIBDIR_WAYLAND "$QMAKE_LIBDIR_WAYLAND"
+        QMakeVar set QMAKE_DEFINES_WAYLAND " $QMAKE_DEFINES_WAYLAND"
+    fi
+
+    if compileTest qpa/wayland "Wayland" $QMAKE_CFLAGS_WAYLAND $QMAKE_LIBS_WAYLAND; then
+        QT_CONFIG="$QT_CONFIG wayland"
+    fi
+
+fi
+
+
+# QWS
+if [ "$PLATFORM_QWS" = "yes" ]; then
+
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL=no
+        fi
+        if [ "$CFG_OPENGL" != "no" ]; then
+            echo "OpenGL enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable OpenGL"
+            exit 1
+        fi
+    fi
+    if [ "$CFG_OPENGL" = "yes" ]; then
+        CFG_EGL=auto
+        if compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+    elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+        else
+            echo "All the OpenGL ES functionality tests failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        CFG_EGL=yes
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        compileTest unix/opengles2 "OpenGL ES 2.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 2.0 functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        CFG_EGL=yes
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        echo "Desktop OpenGL support is not avaliable on Qt for Embedded Linux"
+        exit 1
+    fi
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+
+    # screen drivers
+    for screen in ${CFG_GFX_ON} ${CFG_GFX_PLUGIN}; do
+       if [ "${screen}" = "ahi" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           compileTest qws/ahi "Ahi"
+           if [ $? != "0" ]; then
+               echo "The Ahi screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+       if [ "${screen}" = "svgalib" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           compileTest qws/svgalib "SVGAlib"
+           if [ $? != "0" ]; then
+               echo "The SVGAlib screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+       if [ "${screen}" = "directfb" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           if test -n "$PKG_CONFIG" && "$PKG_CONFIG" --exists directfb 2>/dev/null; then
+               QT_CFLAGS_DIRECTFB=`$PKG_CONFIG --cflags directfb 2>/dev/null`
+               QT_LIBS_DIRECTFB=`$PKG_CONFIG --libs directfb 2>/dev/null`
+           elif directfb-config --version >/dev/null 2>&1; then
+               QT_CFLAGS_DIRECTFB=`directfb-config --cflags 2>/dev/null`
+               QT_LIBS_DIRECTFB=`directfb-config --libs 2>/dev/null`
+           fi
+
+           # QMake variables set here override those in the mkspec. Therefore we only set the variables here if they are not zero.
+           if [ -n "$QT_CFLAGS_DIRECTFB" ] || [ -n "$QT_LIBS_DIRECTFB" ]; then
+               QMakeVar set QT_CFLAGS_DIRECTFB "$QT_CFLAGS_DIRECTFB"
+               QMakeVar set QT_LIBS_DIRECTFB "$QT_LIBS_DIRECTFB"
+           fi
+           if [ "$CFG_QT3SUPPORT" = "yes" ]; then
+               QMakeVar set QT_DEFINES_DIRECTFB "QT3_SUPPORT"
+           fi
+
+           compileTest qws/directfb "DirectFB" $QT_CFLAGS_DIRECTFB $QT_LIBS_DIRECTFB
+           if [ $? != "0" ]; then
+               echo "The DirectFB screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QT_CFLAGS_DIRECTFB and QT_LIBS_DIRECTFB in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+    done
+
+    # mouse drivers
+    for mouse in ${CFG_MOUSE_ON} ${CFG_MOUSE_PLUGIN}; do
+	if [ "${mouse}" = "tslib" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+            compileTest unix/tslib "tslib"
+            if [ $? != "0" ]; then
+               echo "The tslib functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+		exit 1
+	    fi
+	fi
+    done
+
+    CFG_QGTKSTYLE=no
+
+    # sound
+    compileTest qws/sound "sound"
+    if [ $? != "0" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SOUND"
+    fi
+
+fi # QWS
+
+EGL_VARIANT=none
+# EGL Support
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" ]; then
+    if [ "$CFG_EGL" != "no" ]; then
+        # detect EGL support
+        if compileTest "unix/egl" "EGL (EGL/egl.h)"; then
+            # EGL specified by QMAKE_*_EGL, included with <EGL/egl.h>
+            EGL_VARIANT=regular
+            CFG_EGL=yes
+        fi
+
+        # Prefer this variant for ES1
+        if [ "$CFG_OPENGL" = "es1" -o "$EGL_VARIANT" = "none" ]; then
+            if compileTest "unix/egl4gles1" "EGL (GLES/egl.h)"; then
+                # EGL specified by QMAKE_*_EGL, included with <GLES/egl.h>
+                EGL_VARIANT=gles
+                CFG_EGL=yes
+                CFG_EGL_GLES_INCLUDES=yes
+            fi
+        fi
+
+        if [ "$EGL_VARIANT" = "none" ]; then
+            if [ "$CFG_EGL" = "yes" ]; then
+                echo "The EGL functionality test failed!"
+                echo " EGL is required for OpenGL ES to manage contexts & surfaces."
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_EGL, QMAKE_LIBDIR_EGL and QMAKE_LIBS_EGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_EGL=no
+            # If QtOpenGL would be built against OpenGL ES, disable it as we can't to that if EGL is missing
+            if [ "$CFG_OPENGL" = "es1" -o "$CFG_OPENGL" = "es2" ]; then
+                CFG_OPENGL=no
+            fi
+        fi
+    fi
+fi
+
+[ "$XPLATFORM_MINGW" = "yes" ] && [ "$CFG_PHONON" != "no" ] && CFG_PHONON="yes"
+
+# freetype support
+[ "x$CFG_EMBEDDED" != "xno" ] && CFG_LIBFREETYPE="$CFG_QWS_FREETYPE"
+[ "x$PLATFORM_MAC" = "xyes" ] && CFG_LIBFREETYPE=no
+[ "$XPLATFORM_MINGW" = "yes" ] && [ "$CFG_LIBFREETYPE" = "auto" ] && CFG_LIBFREETYPE=no
+if [ "$CFG_LIBFREETYPE" = "auto" ]; then
+    if compileTest unix/freetype "FreeType"; then
+        CFG_LIBFREETYPE=system
+    else
+        CFG_LIBFREETYPE=yes
+    fi
+fi
+
+if [ "$CFG_ENDIAN" = "auto" ]; then
+    if [ "$XPLATFORM_MINGW" = "yes" ]; then
+        CFG_ENDIAN="Q_LITTLE_ENDIAN"
+    elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+        CFG_ENDIAN="Q_LITTLE_ENDIAN"
+    elif [ "$PLATFORM_MAC" = "yes" ] && [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+        true #leave as auto
+    else
+        "$unixtests/endian.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath" "$SYSROOT_FLAG"
+	F="$?"
+        if [ "$F" -eq 0 ]; then
+            CFG_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$F" -eq 1 ]; then
+            CFG_ENDIAN="Q_BIG_ENDIAN"
+        else
+            echo
+	    echo "The target system byte order could not be detected!"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    echo "You can use the -little-endian or -big-endian switch to"
+	    echo "$0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ]; then
+	true #leave as auto
+    else
+        "$unixtests/endian.test" "$QMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+	F="$?"
+        if [ "$F" -eq 0 ]; then
+            CFG_HOST_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$F" -eq 1 ]; then
+            CFG_HOST_ENDIAN="Q_BIG_ENDIAN"
+        else
+            echo
+	    echo "The host system byte order could not be detected!"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    echo "You can use the -host-little-endian or -host-big-endian switch to"
+	    echo "$0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_ARMFPA" != "auto" ]; then
+    if [ "$CFG_ARMFPA" = "yes" ]; then
+        if [ "$CFG_ENDIAN" = "Q_LITTLE_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE_SWAPPED"
+        else
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG_SWAPPED"
+        fi
+    else
+        CFG_DOUBLEFORMAT="normal"
+    fi
+fi
+
+
+if [ "$CFG_DOUBLEFORMAT" = "auto" ]; then
+    if [ "$PLATFORM_QWS" != "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+        CFG_DOUBLEFORMAT=normal
+    else
+        "$unixtests/doubleformat.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+	F="$?"
+        if [ "$F" -eq 10 ] && [ "$CFG_ENDIAN" = "Q_LITTLE_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT=normal
+        elif [ "$F" -eq 11 ] && [ "$CFG_ENDIAN" = "Q_BIG_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT=normal
+        elif [ "$F" -eq 10 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE"
+        elif [ "$F" -eq 11 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG"
+        elif [ "$F" -eq 12 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE_SWAPPED"
+            CFG_ARMFPA="yes"
+        elif [ "$F" -eq 13 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG_SWAPPED"
+            CFG_ARMFPA="yes"
+        else
+            echo
+	    echo "The system floating point format could not be detected."
+	    echo "This may cause data to be generated in a wrong format"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    # we do not fail on this since this is a new test, and if it fails,
+	    # the old behavior should be correct in most cases
+            CFG_DOUBLEFORMAT=normal
+        fi
+    fi
+fi
+
+HAVE_STL=no
+if [ "$XPLATFORM_SYMBIAN" = "yes" ] || [ "$XPLATFORM_INTEGRITY" = "yes" ] || compileTest unix/stl "STL"; then
+    HAVE_STL=yes
+fi
+
+if [ "$CFG_STL" != "no" ]; then
+    if [ "$HAVE_STL" = "yes" ]; then
+        CFG_STL=yes
+    else
+        if [ "$CFG_STL" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "STL support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_STL=no
+        fi
+    fi
+fi
+
+# find if the platform supports IPv6
+if [ "$CFG_IPV6" != "no" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        #IPV6 should always be enabled for Symbian release
+        CFG_IPV6=yes
+    elif compileTest unix/ipv6 "IPv6"; then
+        CFG_IPV6=yes
+    else
+        if [ "$CFG_IPV6" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "IPv6 support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_IPV6=no
+        fi
+    fi
+fi
+
+# detect POSIX clock_gettime()
+if [ "$CFG_CLOCK_GETTIME" = "auto" ]; then
+    if compileTest unix/clock-gettime "POSIX clock_gettime()"; then
+	CFG_CLOCK_GETTIME=yes
+    else
+	CFG_CLOCK_GETTIME=no
+    fi
+fi
+
+# detect POSIX monotonic clocks
+if [ "$CFG_CLOCK_GETTIME" = "yes" ] && [ "$CFG_CLOCK_MONOTONIC" = "auto" ]; then
+    if compileTest unix/clock-monotonic "POSIX Monotonic Clock"; then
+	CFG_CLOCK_MONOTONIC=yes
+    else
+	CFG_CLOCK_MONOTONIC=no
+    fi
+elif [ "$CFG_CLOCK_GETTIME" = "no" ]; then
+    CFG_CLOCK_MONOTONIC=no
+fi
+
+# detect mremap
+if [ "$CFG_MREMAP" = "auto" ]; then
+    if compileTest unix/mremap "mremap"; then
+	CFG_MREMAP=yes
+    else
+	CFG_MREMAP=no
+    fi
+fi
+
+# find if the platform provides getaddrinfo (ipv6 dns lookups)
+if [ "$CFG_GETADDRINFO" != "no" ]; then
+    if compileTest unix/getaddrinfo "getaddrinfo"; then
+        CFG_GETADDRINFO=yes
+    else
+	if [ "$CFG_GETADDRINFO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "getaddrinfo support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+	else
+	    CFG_GETADDRINFO=no
+	fi
+    fi
+fi
+
+# find if the platform provides inotify
+if [ "$CFG_INOTIFY" != "no" ]; then
+    if compileTest unix/inotify "inotify"; then
+        CFG_INOTIFY=yes
+    else
+	if [ "$CFG_INOTIFY" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "inotify support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+	else
+	    CFG_INOTIFY=no
+	fi
+    fi
+fi
+
+# find if the platform provides if_nametoindex (ipv6 interface name support)
+if [ "$CFG_IPV6IFNAME" != "no" ]; then
+    if compileTest unix/ipv6ifname "IPv6 interface name"; then
+        CFG_IPV6IFNAME=yes
+    else
+        if [ "$CFG_IPV6IFNAME" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "IPv6 interface name support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+	    CFG_IPV6IFNAME=no
+	fi
+    fi
+fi
+
+# find if the platform provides getifaddrs (network interface enumeration)
+if [ "$CFG_GETIFADDRS" != "no" ]; then
+    if compileTest unix/getifaddrs "getifaddrs"; then
+        CFG_GETIFADDRS=yes
+    else
+        if [ "$CFG_GETIFADDRS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "getifaddrs support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+	    CFG_GETIFADDRS=no
+	fi
+    fi
+fi
+
+# detect OpenSSL
+if [ "$CFG_OPENSSL" != "no" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest unix/openssl "OpenSSL"; then
+        if [ "$CFG_OPENSSL" = "auto" ]; then
+            CFG_OPENSSL=yes
+        fi
+    else
+        if ( [ "$CFG_OPENSSL" = "yes" ] || [ "$CFG_OPENSSL" = "linked" ] ) && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "OpenSSL support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_OPENSSL=no
+        fi
+    fi
+else
+    if [ "$CFG_OPENSSL" = "auto" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+        #OpenSSl should be enabled for Symbian release
+        CFG_OPENSSL=yes
+    fi
+fi
+
+# detect OpenVG support
+if [ "$CFG_OPENVG" != "no" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest "unix/openvg" "OpenVG"; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+    elif compileTest unix/openvg "OpenVG" -config openvg_on_opengl; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_ON_OPENGL=yes
+    elif compileTest unix/openvg "OpenVG (lc includes)" -config lower_case_includes; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_LC_INCLUDES=yes
+    elif compileTest unix/openvg "OpenVG (lc includes)" -config "openvg_on_opengl lower_case_includes"; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_LC_INCLUDES=yes
+        CFG_OPENVG_ON_OPENGL=yes
+    else
+        if [ "$CFG_OPENVG" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "$CFG_OPENVG was specified for OpenVG but cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_OPENVG=no
+        fi
+    fi
+    if [ "$CFG_OPENVG" = "yes" ] && compileTest "unix/shivavg" "ShivaVG" $CONFIG_ARG; then
+        CFG_OPENVG_SHIVA=yes
+    fi
+fi
+
+# if openvg is disabled and the user specified graphicssystem vg, disable it...
+if [ "$CFG_GRAPHICS_SYSTEM" = "openvg" ] && [ "$CFG_OPENVG" = "no" ]; then
+    echo "OpenVG Graphics System is disabled due to missing OpenVG support..."
+    CFG_GRAPHICS_SYSTEM=default
+fi
+
+if [ -n "$CFG_RUNTIME_SYSTEM" -a "$CFG_GRAPHICS_SYSTEM" != "runtime" ] || [ "$CFG_RUNTIME_SYSTEM" = "runtime" ]; then
+    echo "Argument to -runtimegraphicssystem is invalid so ignoring..."
+    CFG_RUNTIME_SYSTEM=
+fi
+
+if [ "$CFG_PTMALLOC" != "no" ]; then
+    # build ptmalloc, copy .a file to lib/
+    echo "Building ptmalloc. Please wait..."
+    (cd "$relpath/src/3rdparty/ptmalloc/"; "$MAKE" "clean" ; "$MAKE" "posix"
+     mkdir "$outpath/lib/" ; cp "libptmalloc3.a" "$outpath/lib/")
+
+    QMakeVar add QMAKE_LFLAGS "$outpath/lib/libptmalloc3.a"
+fi
+
+if [ "$CFG_ALSA" = "auto" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest unix/alsa "alsa"; then
+        CFG_ALSA=yes
+    else
+        CFG_ALSA=no
+    fi
+elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+    # Disabled for Symbian release
+    CFG_ALSA=no
+fi
+
+if [ "$CFG_JAVASCRIPTCORE_JIT" = "yes" ] || [ "$CFG_JAVASCRIPTCORE_JIT" = "auto" ]; then 
+    if [ "$CFG_ARCH" = "arm" ]; then
+       compileTest unix/javascriptcore-jit "javascriptcore-jit"
+        if [ $? != "0" ]; then
+           CFG_JAVASCRIPTCORE_JIT=no
+        fi
+    else
+	case "$XPLATFORM" in
+	    symbian-gcce)
+		CFG_JAVASCRIPTCORE_JIT=no
+		;;
+	    linux-icc*)
+		CFG_JAVASCRIPTCORE_JIT=no
+		;;
+	esac
+    fi
+fi
+
+if [ "$CFG_JAVASCRIPTCORE_JIT" = "yes" ]; then
+    QMakeVar set JAVASCRIPTCORE_JIT yes
+elif [ "$CFG_JAVASCRIPTCORE_JIT" = "no" ]; then
+    QMakeVar set JAVASCRIPTCORE_JIT no
+fi
+
+if [ "$CFG_AUDIO_BACKEND" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+         if "$symbiantests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/symbian/audio "audio" $L_FLAGS $I_FLAGS $l_FLAGS ; then
+            CFG_AUDIO_BACKEND=yes
+         fi
+    else
+        CFG_AUDIO_BACKEND=yes
+    fi
+fi
+
+if [ "$CFG_LARGEFILE" != "yes" ] && [ "$XPLATFORM_MINGW" = "yes" ]; then
+    echo "Warning: largefile support cannot be disabled for win32."
+    CFG_LARGEFILE="yes"
+elif [ "$CFG_LARGEFILE" != "no" ] && [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    echo "Warning: largefile support cannot be enabled for symbian."
+    CFG_LARGEFILE="no"
+fi
+
+#-------------------------------------------------------------------------------
+# ask for all that hasn't been auto-detected or specified in the arguments
+#-------------------------------------------------------------------------------
+
+### fix this: user input should be validated in a loop
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    PROMPT_FOR_DEPTHS="yes"
+else
+    PROMPT_FOR_DEPTHS="no"
+fi
+if [ "$CFG_QWS_DEPTHS" = "prompted" -a "$PROMPT_FOR_DEPTHS" = "yes" ]; then
+    echo
+    echo "Choose pixel-depths to support:"
+    echo
+    echo "   1. 1bpp, black/white"
+    echo "   4. 4bpp, grayscale"
+    echo "   8. 8bpp, paletted"
+    echo "  12. 12bpp, rgb 4-4-4"
+    echo "  15. 15bpp, rgb 5-5-5"
+    echo "  16. 16bpp, rgb 5-6-5"
+    echo "  18. 18bpp, rgb 6-6-6"
+    echo "  24. 24bpp, rgb 8-8-8"
+    echo "  32. 32bpp, argb 8-8-8-8 and rgb 8-8-8"
+    echo " all. All supported depths"
+    echo
+    echo "Your choices (default 8,16,32):"
+    read CFG_QWS_DEPTHS
+    if [ -z "$CFG_QWS_DEPTHS" ] || [ "$CFG_QWS_DEPTHS" = "yes" ]; then
+        CFG_QWS_DEPTHS=8,16,32
+    fi
+fi
+if [ -n "$CFG_QWS_DEPTHS" -a "$PLATFORM_QWS" = "yes" ]; then
+    if [ "$CFG_QWS_DEPTHS" = "all" ]; then
+        CFG_QWS_DEPTHS="1 4 8 12 15 16 18 24 32 generic"
+    fi
+    for D in `echo "$CFG_QWS_DEPTHS" | sed -e 's/,/ /g'`; do
+	case $D in
+	    1|4|8|12|15|16|18|24|32) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_$D";;
+	    generic) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_GENERIC";;
+	esac
+    done
+fi
+
+# enable dwarf2 support on Mac
+if [ "$CFG_MAC_DWARF2" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG dwarf2"
+fi
+
+# Set the default arch if there are no "-arch" arguments on the configure line
+# For "-carbon" builds: 32 bit x86/ppc.
+# For builds on snow leopard : compiler default (64-bit).
+# For builds on leopard : compiler default (32-bit).
+if [ "$PLATFORM_MAC" = "yes" ]  && [ "$CFG_MAC_ARCHS" = "" ]; then
+    source "$mactests/defaultarch.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests"
+
+	if [ "$CFG_MAC_CARBON" = "yes" ]; then
+		if [ "$QT_MAC_DEFAULT_ARCH" = "x86_64" ]; then
+			CFG_MAC_ARCHS=" x86"
+		elif [ "$QT_MAC_DEFAULT_ARCH" = "ppc64" ]; then
+			CFG_MAC_ARCHS=" ppc"
+		else
+			CFG_MAC_ARCHS=" $QT_MAC_DEFAULT_ARCH"
+		fi
+	else
+		CFG_MAC_ARCHS=" $QT_MAC_DEFAULT_ARCH"
+    fi
+
+    [ "$OPT_VERBOSE" = "yes" ] && echo "Setting Mac architechture to$CFG_MAC_ARCHS."
+fi
+
+# enable Cocoa and/or Carbon on Mac
+#  -carbon on the command line disables Cocoa, except for 64-bit archs
+if [ "$CFG_MAC_CARBON" = "yes" ]; then
+    CFG_MAC_CARBON="YES"
+    CFG_MAC_COCOA="NO"
+
+#    check which archs are in use, enable cocoa if we find a 64-bit one
+    if echo "$CFG_MAC_ARCHS" | grep 64 > /dev/null 2>&1; then
+        CFG_MAC_COCOA="yes";
+        CFG_MAC_CARBON="no";
+        if echo "$CFG_MAC_ARCHS" | grep -w ppc > /dev/null 2>&1; then
+            CFG_MAC_CARBON="yes";
+        fi
+        if echo "$CFG_MAC_ARCHS" | grep -w x86 > /dev/null 2>&1; then
+            CFG_MAC_CARBON="yes";
+        fi
+    fi
+fi
+
+# select Carbon on 10.4 Tiger.
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    VERSION=`uname -r | tr '.' ' ' | awk '{print $1}'`
+    if [ "$VERSION" == 8 ]; then
+        CFG_MAC_COCOA="no";
+        CFG_MAC_CARBON="yes";
+    fi
+fi
+
+# select Carbon when using the 10.4u SDK
+if [ "$PLATFORM_MAC" = "yes" ] && [ -n "$CFG_SDK" ]; then
+    if [ `basename "$CFG_SDK"` == "MacOSX10.4u.sdk" ]; then
+        echo "Carbon on";
+        CFG_MAC_COCOA="no";
+        CFG_MAC_CARBON="yes";
+    fi
+fi
+
+# but disable Cocoa if cross-building for mingw and symbian
+[ "$XPLATFORM_MINGW" = "yes" ] && CFG_MAC_COCOA="no"
+[ "$XPLATFORM_SYMBIAN" = "yes" ] && CFG_MAC_COCOA="no"
+
+# set the global Mac deployment target. This is overridden on an arch-by-arch basis
+# in some cases, see code further down
+case "$PLATFORM,$CFG_MAC_COCOA" in
+    macx*,yes)
+	# Cocoa
+	QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.5
+	;;
+    macx*,no)
+	# gcc, Carbon
+	QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.4
+	;;
+esac
+
+# disable Qt 3 support on VxWorks, Symbian and INTEGRITY
+case "$XPLATFORM" in
+    unsupported/vxworks*|symbian*|unsupported/integrity*)
+	CFG_QT3SUPPORT="no"
+    ;;
+esac
+
+# enable Qt 3 support functionality
+if [ "$CFG_QT3SUPPORT" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG qt3support"
+fi
+
+# enable Phonon
+if [ "$CFG_PHONON" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG phonon"
+    if [ "$CFG_PHONON_BACKEND" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG phonon-backend"
+    fi
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_PHONON"
+fi
+
+# disable accessibility
+if [ "$CFG_ACCESSIBILITY" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ACCESSIBILITY"
+else
+    QT_CONFIG="$QT_CONFIG accessibility"
+fi
+
+# egl stuff does not belong in lighthouse, but rather in plugins
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    CFG_EGL="no"
+fi
+
+# enable egl
+if [ "$CFG_EGL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_EGL"
+else
+    QT_CONFIG="$QT_CONFIG egl"
+    if [ "$CFG_EGL_GLES_INCLUDES" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GLES_EGL"
+    fi
+fi
+
+# enable openvg
+if [ "$CFG_OPENVG" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENVG"
+else
+    QT_CONFIG="$QT_CONFIG openvg"
+    if [ "$CFG_OPENVG_LC_INCLUDES" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_LOWER_CASE_VG_INCLUDES"
+    fi
+    if [ "$CFG_OPENVG_ON_OPENGL" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG openvg_on_opengl"
+    fi
+    if [ "$CFG_OPENVG_SHIVA" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG shivavg"
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_SHIVAVG"
+    fi
+fi
+
+if [ "$CFG_QS60STYLE" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_S60"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_STYLE_S60"
+fi
+
+# Just check if OpenGL is not set by command argumets for Symbian.
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL="no"
+        fi
+fi
+
+# enable opengl
+if [ "$CFG_OPENGL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENGL"
+else
+    QT_CONFIG="$QT_CONFIG opengl"
+fi
+
+if [ "$CFG_OPENGL" = "es1" ] || [ "$CFG_OPENGL" = "es2" ]; then
+    if [ "$PLATFORM_QWS" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS Q_BACKINGSTORE_SUBSURFACES"
+    fi
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES"
+fi
+
+if [ "$CFG_OPENGL" = "es1" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES_1"
+    QT_CONFIG="$QT_CONFIG opengles1"
+fi
+
+if [ "$CFG_OPENGL" = "es2" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES_2"
+    QT_CONFIG="$QT_CONFIG opengles2"
+fi
+
+# safe execution environment
+if [ "$CFG_SXE" != "no" ]; then
+    QT_CONFIG="$QT_CONFIG sxe"
+fi
+
+# build up the variables for output
+if [ "$CFG_DEBUG" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}debug"
+    QMAKE_CONFIG="$QMAKE_CONFIG debug"
+elif [ "$CFG_DEBUG" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}release"
+    QMAKE_CONFIG="$QMAKE_CONFIG release"
+fi
+if [ "$CFG_SHARED" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-shared"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG shared"
+    QT_CONFIG="$QT_CONFIG shared"
+elif [ "$CFG_SHARED" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-static"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG static"
+    QT_CONFIG="$QT_CONFIG static"
+fi
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-emb-$CFG_EMBEDDED"
+    QMAKE_CONFIG="$QMAKE_CONFIG embedded"
+    QT_CONFIG="$QT_CONFIG embedded"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG qpa"
+    QT_CONFIG="$QT_CONFIG qpa"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qpa"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG nacl pepper"
+    QT_CONFIG="$QT_CONFIG nacl pepper"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+
+if [ "$XPLATFORM_MINGW" != "yes" ]; then
+    # Do not set this here for Windows. Let qmake do it so
+    # debug and release precompiled headers are kept separate.
+    QMakeVar set PRECOMPILED_DIR ".pch/$QMAKE_OUTDIR"
+fi
+if [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    QMakeVar set OBJECTS_DIR "$PWD/work"
+    QMakeVar set MOC_DIR "$PWD/work"
+    QMakeVar set RCC_DIR "$PWD/work"
+    QMakeVar set UI_DIR "$PWD/work"
+else
+    QMakeVar set OBJECTS_DIR ".obj/$QMAKE_OUTDIR"
+    QMakeVar set MOC_DIR ".moc/$QMAKE_OUTDIR"
+    QMakeVar set RCC_DIR ".rcc/$QMAKE_OUTDIR"
+    QMakeVar set UI_DIR ".uic/$QMAKE_OUTDIR"
+fi
+if [ "$CFG_LARGEFILE" = "yes" ] && [ "$XPLATFORM_MINGW" != "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG largefile"
+fi
+if [ "$CFG_STL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STL"
+else
+    QMAKE_CONFIG="$QMAKE_CONFIG stl"
+fi
+if [ "$CFG_USE_GNUMAKE" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG GNUmake"
+fi
+[ "$CFG_REDUCE_EXPORTS" = "yes" ] && QT_CONFIG="$QT_CONFIG reduce_exports"
+[ "$CFG_STACK_PROTECTOR_STRONG" = "yes" ] && QT_CONFIG="$QT_CONFIG stack-protector-strong"
+[ "$CFG_REDUCE_RELOCATIONS" = "yes" ] && QT_CONFIG="$QT_CONFIG reduce_relocations"
+[ "$CFG_PRECOMPILE" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG precompile_header"
+if [ "$CFG_SEPARATE_DEBUG_INFO" = "yes" ]; then
+    QMakeVar add QMAKE_CFLAGS -g
+    QMakeVar add QMAKE_CXXFLAGS -g
+    QMAKE_CONFIG="$QMAKE_CONFIG separate_debug_info"
+fi
+if [ "$CFG_SEPARATE_DEBUG_INFO_NOCOPY" = "yes" ] ; then
+    QMAKE_CONFIG="$QMAKE_CONFIG separate_debug_info_nocopy"
+fi
+[ "$CFG_MMX" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG mmx"
+[ "$CFG_3DNOW" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG 3dnow"
+[ "$CFG_SSE" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse"
+[ "$CFG_SSE2" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse2"
+[ "$CFG_SSE3" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse3"
+[ "$CFG_SSSE3" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG ssse3"
+[ "$CFG_SSE4_1" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse4_1"
+[ "$CFG_SSE4_2" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse4_2"
+[ "$CFG_AVX" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG avx"
+[ "$CFG_IWMMXT" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG iwmmxt"
+[ "$CFG_NEON" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG neon"
+[ "$PLATFORM_MAC" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG $CFG_MAC_ARCHS"
+[ "$CFG_SYSTEM_PROXIES" = "yes" ] && QT_CONFIG="$QT_CONFIG system-proxies"
+if [ "$CFG_IPV6" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG ipv6"
+fi
+if [ "$CFG_CLOCK_GETTIME" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG clock-gettime"
+fi
+if [ "$CFG_CLOCK_MONOTONIC" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG clock-monotonic"
+fi
+if [ "$CFG_MREMAP" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG mremap"
+fi
+if [ "$CFG_GETADDRINFO" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG getaddrinfo"
+fi
+if [ "$CFG_IPV6IFNAME" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG ipv6ifname"
+fi
+if [ "$CFG_GETIFADDRS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG getifaddrs"
+fi
+if [ "$CFG_INOTIFY" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG inotify"
+fi
+if [ "$CFG_LIBJPEG" = "no" ]; then
+    CFG_JPEG="no"
+elif [ "$CFG_LIBJPEG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-jpeg"
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-jpeg"
+elif [ "$CFG_JPEG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG jpeg"
+fi
+if [ "$CFG_LIBMNG" = "no" ]; then
+    CFG_MNG="no"
+elif [ "$CFG_LIBMNG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-mng"
+fi
+if [ "$CFG_MNG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-mng"
+elif [ "$CFG_MNG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG mng"
+fi
+if [ "$CFG_LIBPNG" = "no" ]; then
+    CFG_PNG="no"
+fi
+if [ "$CFG_LIBPNG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-png"
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-png"
+elif [ "$CFG_PNG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG png"
+fi
+if [ "$CFG_GIF" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-gif"
+elif [ "$CFG_GIF" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG gif"
+fi
+if [ "$CFG_LIBTIFF" = "no" ]; then
+    CFG_TIFF="no"
+elif [ "$CFG_LIBTIFF" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-tiff"
+fi
+if [ "$CFG_TIFF" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-tiff"
+elif [ "$CFG_TIFF" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG tiff"
+fi
+if [ "$CFG_LIBFREETYPE" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-freetype"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_FREETYPE"
+elif [ "$CFG_LIBFREETYPE" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-freetype"
+else
+    QT_CONFIG="$QT_CONFIG freetype"
+fi
+if [ "$CFG_GUI" = "auto" ]; then
+    CFG_GUI="yes"
+fi
+if [ "$CFG_GUI" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-gui"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GUI"
+fi
+
+
+if [ "x$PLATFORM_MAC" = "xyes" ] && [ "$XPLATFORM_MINGW" != "yes" ] && [ "$XPLATFORM_SYMBIAN" != "yes" ]; then
+    #On Mac we implicitly link against libz, so we
+    #never use the 3rdparty stuff.
+    [ "$CFG_ZLIB" = "yes" ] && CFG_ZLIB="system"
+fi
+if [ "$CFG_ZLIB" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG zlib"
+elif [ "$CFG_ZLIB" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-zlib"
+fi
+
+if [ "$CFG_S60" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG s60"
+fi
+
+if [ "$CFG_SYMBIAN_DEFFILES" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG def_files"
+else
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG def_files_disabled"
+fi
+
+[ "$CFG_NIS" = "yes" ] && QT_CONFIG="$QT_CONFIG nis"
+[ "$CFG_CUPS" = "yes" ] && QT_CONFIG="$QT_CONFIG cups"
+[ "$CFG_ICONV" = "yes" ] && QT_CONFIG="$QT_CONFIG iconv"
+[ "$CFG_ICONV" = "sun" ] && QT_CONFIG="$QT_CONFIG sun-libiconv"
+[ "$CFG_ICONV" = "gnu" ] && QT_CONFIG="$QT_CONFIG gnu-libiconv"
+[ "$CFG_GLIB" = "yes" ] && QT_CONFIG="$QT_CONFIG glib"
+[ "$CFG_GSTREAMER" = "yes" ] && QT_CONFIG="$QT_CONFIG gstreamer"
+[ "$CFG_DBUS" = "yes" ] && QT_CONFIG="$QT_CONFIG dbus"
+[ "$CFG_DBUS" = "linked" ] && QT_CONFIG="$QT_CONFIG dbus dbus-linked"
+[ "$CFG_NAS" = "system" ] && QT_CONFIG="$QT_CONFIG nas"
+[ "$CFG_OPENSSL" = "yes" ] && QT_CONFIG="$QT_CONFIG openssl"
+[ "$CFG_OPENSSL" = "linked" ] && QT_CONFIG="$QT_CONFIG openssl-linked"
+[ "$CFG_MAC_HARFBUZZ" = "yes" ] && QT_CONFIG="$QT_CONFIG harfbuzz"
+
+if [ "$PLATFORM_X11" = "yes" ]; then
+    [ "$CFG_SM" = "yes" ] && QT_CONFIG="$QT_CONFIG x11sm"
+
+    # for some reason, the following libraries are not always built shared,
+    # so *every* program/lib (including Qt) has to link against them
+    if [ "$CFG_XSHAPE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xshape"
+    fi
+    if [ "$CFG_XVIDEO" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xvideo"
+    fi
+    if [ "$CFG_XSYNC" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xsync"
+    fi
+    if [ "$CFG_XINERAMA" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xinerama"
+	QMakeVar set QMAKE_LIBS_X11 '-lXinerama $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XCURSOR" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xcursor"
+	QMakeVar set QMAKE_LIBS_X11 '-lXcursor $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XFIXES" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xfixes"
+	QMakeVar set QMAKE_LIBS_X11 '-lXfixes $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XRANDR" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xrandr"
+        if [ "$CFG_XRENDER" != "yes" ]; then
+            # libXrandr uses 1 function from libXrender, so we always have to have it :/
+	    QMakeVar set QMAKE_LIBS_X11 '-lXrandr -lXrender $$QMAKE_LIBS_X11'
+        else
+	    QMakeVar set QMAKE_LIBS_X11 '-lXrandr $$QMAKE_LIBS_X11'
+        fi
+    fi
+    if [ "$CFG_XRENDER" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xrender"
+	QMakeVar set QMAKE_LIBS_X11 '-lXrender $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_MITSHM" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG mitshm"
+    fi
+    if [ "$CFG_FONTCONFIG" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG fontconfig"
+    fi
+    if [ "$CFG_XINPUT" = "yes" ]; then
+	QMakeVar set QMAKE_LIBS_X11 '-lXi $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XINPUT" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xinput tablet"
+    fi
+    if [ "$CFG_XKB" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xkb"
+    fi
+fi
+
+[ '!' -z "$D_FLAGS" ] && QMakeVar add DEFINES "$D_FLAGS"
+[ '!' -z "$L_FLAGS" ] && QMakeVar add QMAKE_LIBDIR_FLAGS "$L_FLAGS"
+[ '!' -z "$l_FLAGS" ] && QMakeVar add LIBS "$l_FLAGS"
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_RPATH" = "yes" ]; then
+       QMAKE_CONFIG="$QMAKE_CONFIG absolute_library_soname"
+    fi
+elif [ -z "`getXQMakeConf 'QMAKE_(LFLAGS_)?RPATH'`" ]; then
+    if [ -n "$RPATH_FLAGS" ]; then
+        echo
+        echo "ERROR: -R cannot be used on this platform as \$QMAKE_LFLAGS_RPATH is"
+        echo "       undefined."
+        echo
+        exit 1
+    elif [ "$CFG_RPATH" = "yes" ]; then
+        RPATH_MESSAGE="        NOTE: This platform does not support runtime library paths, using -no-rpath."
+        CFG_RPATH=no
+    fi
+else
+    if [ "$CFG_RPATH" = "yes" ]; then
+        # set the default rpath to the library installation directory
+        RPATH_FLAGS="\"$QT_INSTALL_LIBS\" $RPATH_FLAGS"
+    fi
+    if [ -n "$RPATH_FLAGS" ]; then
+        # add the user defined rpaths
+	QMakeVar add QMAKE_RPATHDIR "$RPATH_FLAGS"
+    fi
+fi
+
+if [ '!' -z "$I_FLAGS" ]; then
+    # add the user define include paths
+    QMakeVar add QMAKE_CFLAGS "$I_FLAGS"
+    QMakeVar add QMAKE_CXXFLAGS "$I_FLAGS"
+fi
+
+# turn off exceptions for the compilers that support it
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    COMPILER=`echo $XPLATFORM | cut -f 3- -d-`
+elif [ "$XPLATFORM" != "$PLATFORM" ]; then
+    COMPILER=`echo $XPLATFORM | cut -f 2- -d-`
+else
+    COMPILER=`echo $PLATFORM | cut -f 2- -d-`
+fi
+if [ "$CFG_EXCEPTIONS" = "unspecified" -a "$PLATFORM_QWS" = "yes" ]; then
+    CFG_EXCEPTIONS=no
+fi
+
+if [ "$CFG_EXCEPTIONS" != "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG exceptions"
+fi
+
+if [ "$XPLATFORM_MINGW" = "yes" ] || [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # mkspecs/features/win32/default_pre.prf sets "no-rtti".
+    # Follow default behavior of configure.exe by overriding with "rtti"
+    # (also on Symbian).
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG rtti"
+fi
+
+if [ "$CFG_ALSA" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG alsa"
+fi
+
+if [ "$CFG_PULSEAUDIO" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG pulseaudio"
+fi
+
+if [ "$CFG_COREWLAN" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG corewlan"
+fi
+
+if [ "$CFG_ICD" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG icd"
+fi
+
+if [ "$CFG_ICU" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG icu"
+fi
+
+#
+# Some Qt modules are too advanced in C++ for some old compilers
+# Detect here the platforms where they are known to work.
+#
+# See Qt documentation for more information on which features are
+# supported and on which compilers.
+#
+canBuildQtXmlPatterns="yes"
+canBuildWebKit="$HAVE_STL"
+canBuildQtScript="$HAVE_STL"
+canBuildQtConcurrent="yes"
+
+# WebKit and QtScript require stdint.h
+compileTest unix/stdint "Stdint"
+if [ $? != "0" ]; then
+    canBuildWebKit="no"
+    canBuildQtScript="no"
+fi
+
+case "$XPLATFORM" in
+    hpux-g++*)
+	# PA-RISC's assembly is too limited
+	# gcc 3.4 on that platform can't build QtXmlPatterns
+	# the assembly it generates cannot be compiled
+
+	# Check gcc's version
+	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
+	    4*)
+		;;
+	    3.4*)
+		canBuildQtXmlPatterns="no"
+		;;
+	    *)
+		canBuildWebKit="no"
+		canBuildQtXmlPatterns="no"
+		;;
+	esac
+	;;
+    unsupported/vxworks-*-g++*)
+	canBuildWebKit="no"
+	;;
+    unsupported/vxworks-*-dcc*)
+	canBuildWebKit="no"
+	canBuildQtXmlPatterns="no"
+	;;
+    *-g++*)
+	# Check gcc's version
+	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
+	    4*|3.4*)
+		;;
+            3.3*)
+                canBuildWebKit="no"
+                ;;
+	    *)
+		canBuildWebKit="no"
+		canBuildQtXmlPatterns="no"
+		;;
+	esac
+	;;
+    solaris-cc*)
+        # Check the compiler version
+        case `${QMAKE_CONF_COMPILER} -V 2>&1 | awk '{print $4}'` in
+            5.[012345678])
+                canBuildWebKit="no"
+                canBuildQtXmlPatterns="no"
+                canBuildQtConcurrent="no"
+                ;;
+            5.*)
+                canBuildWebKit="no"
+                canBuildQtConcurrent="no"
+                ;;
+        esac
+        ;;
+    hpux-acc*)
+	canBuildWebKit="no"
+	canBuildQtXmlPatterns="no"
+        canBuildQtConcurrent="no"
+	;;
+    hpuxi-acc*)
+	canBuildWebKit="no"
+	;;
+    aix-xlc*)
+        # Get the xlC version
+        cat > xlcver.c <<EOF
+#include <stdio.h>
+int main()
+{
+    printf("%d.%d\n", __xlC__ >> 8, __xlC__ & 0xFF);
+    return 0;
+}
+EOF
+        xlcver=
+        if ${QMAKE_CONF_COMPILER} -o xlcver xlcver.c >/dev/null 2>/dev/null; then
+            xlcver=`./xlcver 2>/dev/null`
+            rm -f ./xlcver
+        fi
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            if [ -n "$xlcver" ]; then
+                echo Found IBM xlC version: $xlcver.
+            else
+                echo Could not determine IBM xlC version, assuming oldest supported.
+            fi
+        fi
+
+        case "$xlcver" in
+            [123456].*)
+                canBuildWebKit="no"
+                canBuildQtXmlPatterns="no"
+                canBuildQtConcurrent="no"
+                ;;
+            *)
+                canBuildWebKit="no"
+                canBuildQtConcurrent="no"
+                ;;
+        esac
+        ;;
+    irix-cc*)
+        canBuildWebKit="no"
+        canBuildQtConcurrent="no"
+	;;
+    symbian-gcce)
+        ;;
+    symbian-armcc)
+        ;;
+esac
+
+if [ "$CFG_GUI" = "no" ]; then
+    # WebKit requires QtGui
+    canBuildWebKit="no"
+fi
+
+if [ "$CFG_SHARED" = "no" ]; then
+    echo
+    echo "WARNING: Using static linking will disable the WebKit module."
+    echo
+    canBuildWebKit="no"
+fi
+
+CFG_CONCURRENT="yes"
+if [ "$canBuildQtConcurrent" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CONCURRENT"
+    CFG_CONCURRENT="no"
+else
+    QT_CONFIG="$QT_CONFIG concurrent"
+fi
+
+if [ "$CFG_XMLPATTERNS" = "yes" -a "$CFG_EXCEPTIONS" = "no" ]; then
+    echo "QtXmlPatterns was requested, but it can't be built due to exceptions being disabled."
+    exit 1
+fi
+if [ "$CFG_XMLPATTERNS" = "auto" -a "$CFG_EXCEPTIONS" != "no" ]; then
+    CFG_XMLPATTERNS="$canBuildQtXmlPatterns"
+elif [ "$CFG_EXCEPTIONS" = "no" ]; then
+    CFG_XMLPATTERNS="no"
+fi
+if [ "$CFG_XMLPATTERNS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG xmlpatterns"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XMLPATTERNS"
+fi
+
+if [ "$CFG_MULTIMEDIA" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MULTIMEDIA"
+else
+    QT_CONFIG="$QT_CONFIG multimedia"
+fi
+
+if [ "$CFG_AUDIO_BACKEND" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG audio-backend"
+fi
+
+if [ "$CFG_SVG" = "auto" ]; then
+    CFG_SVG=$CFG_GUI
+fi
+
+if [ "$CFG_SVG" = "yes" ] && [ "$CFG_GUI" = "no" ]; then
+    echo "QtSvg requested, but it can't be built without QtGui"
+    exit 1
+fi
+
+if [ "$CFG_SVG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG svg"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SVG"
+fi
+
+if [ "$CFG_WEBKIT" != "no" ]; then
+    CFG_WEBKIT="$canBuildWebKit"
+fi
+
+if [ "$CFG_WEBKIT" != "no" ]; then
+    # This include takes care of adding "webkit" to QT_CONFIG.
+    cp -f "$relpath/src/3rdparty/webkit/Source/WebKit/qt/qt_webkit_version.pri" "$outpath/mkspecs/modules/qt_webkit_version.pri"
+    # The reason we set CFG_WEBKIT, is such that the printed overview of what will be enabled, shows correctly.
+    if [ "$CFG_WEBKIT" = "debug" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG webkit-debug"
+    fi
+else
+    rm -f "$outpath/mkspecs/modules/qt_webkit_version.pri"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_WEBKIT"
+fi
+
+if [ "$CFG_SCRIPT" = "yes" -a "$canBuildQtScript" = "no" ]; then
+    echo "Error: QtScript was requested, but it can't be built on this platform."
+    exit 1
+fi
+
+if [ "$CFG_SCRIPT" = "auto" ]; then
+    CFG_SCRIPT="$canBuildQtScript"
+fi
+
+if [ "$CFG_SCRIPT" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG script"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SCRIPT"
+fi
+
+if [ "$CFG_SCRIPTTOOLS" = "yes" -a "$CFG_SCRIPT" = "no" ]; then
+    echo "QtScriptTools was requested, but it can't be built due to QtScript being disabled."
+    exit 1
+fi
+if [ "$CFG_SCRIPTTOOLS" = "auto" -a "$CFG_SCRIPT" != "no" ]; then
+    case "$XPLATFORM" in
+    symbian*)
+        CFG_SCRIPTTOOLS="no"
+        ;;
+    *)
+        CFG_SCRIPTTOOLS="yes"
+        ;;
+    esac
+elif [ "$CFG_SCRIPT" = "no" ]; then
+    CFG_SCRIPTTOOLS="no"
+fi
+
+if [ "$CFG_SCRIPTTOOLS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG scripttools"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SCRIPTTOOLS"
+fi
+
+
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    if [ "$CFG_SCRIPT" = "no" -o "$CFG_GUI" = "no" ]; then
+        echo "Error: QtDeclarative was requested, but it can't be built due to QtScript or QtGui being disabled."
+        exit 1
+    fi
+fi
+if [ "$CFG_DECLARATIVE" = "auto" ]; then
+    if [ "$CFG_SCRIPT" = "no" -o "$CFG_GUI" = "no" ]; then
+            CFG_DECLARATIVE=no
+    else
+            CFG_DECLARATIVE=yes
+    fi
+fi
+
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG declarative"
+    if [ "$CFG_DECLARATIVE_DEBUG" = "no" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QDECLARATIVE_NO_DEBUG_PROTOCOL"
+    fi
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_DECLARATIVE"
+fi
+
+if [ "$CFG_EXCEPTIONS" = "no" ]; then
+    case "$COMPILER" in
+    g++*)
+	QMakeVar add QMAKE_CFLAGS -fno-exceptions
+	QMakeVar add QMAKE_CXXFLAGS -fno-exceptions
+	QMakeVar add QMAKE_LFLAGS -fno-exceptions
+        ;;
+    cc*)
+        case "$PLATFORM" in
+        irix-cc*)
+	    QMakeVar add QMAKE_CFLAGS -LANG:exceptions=off
+	    QMakeVar add QMAKE_CXXFLAGS -LANG:exceptions=off
+	    QMakeVar add QMAKE_LFLAGS -LANG:exceptions=off
+            ;;
+        *) ;;
+        esac
+        ;;
+    *) ;;
+    esac
+    QMAKE_CONFIG="$QMAKE_CONFIG exceptions_off"
+fi
+
+# On Mac, set the minimum deployment target for the different architechtures 
+# using the Xarch compiler option when supported (10.5 and up).  On 10.4 the
+# deployment version is set to 10.4 globally using the QMAKE_MACOSX_DEPLOYMENT_TARGET
+# env. variable. 
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_XARCH" != "no" ] ; then
+    if echo "$CFG_MAC_ARCHS" | grep '\<x86\>' > /dev/null 2>&1; then
+        QMakeVar add QMAKE_CFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_CXXFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_LFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86 "-arch i386 -Xarch_i386 -mmacosx-version-min=10.4"
+    fi
+    if echo "$CFG_MAC_ARCHS" | grep '\<ppc\>' > /dev/null 2>&1; then
+        QMakeVar add QMAKE_CFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_LFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+        QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC "-arch ppc -Xarch_ppc -mmacosx-version-min=10.4"
+    fi
+    if echo "$CFG_MAC_ARCHS" | grep '\<x86_64\>' > /dev/null 2>&1; then
+        QMakeVar add QMAKE_CFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_CXXFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_LFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86_64 "-arch x86_64 -Xarch_x86_64 -mmacosx-version-min=10.5"
+    fi
+    if echo "$CFG_MAC_ARCHS" | grep '\<ppc64\>' > /dev/null 2>&1; then
+        QMakeVar add QMAKE_CFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_LFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+        QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC_64 "-arch ppc64 -Xarch_ppc64 -mmacosx-version-min=10.5"
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# generate QT_BUILD_KEY
+#-------------------------------------------------------------------------------
+
+# some compilers generate binary incompatible code between different versions,
+# so we need to generate a build key that is different between these compilers
+COMPAT_COMPILER=
+case "$COMPILER" in
+g++*)
+    # GNU C++
+    COMPILER_VERSION=`${QMAKE_CONF_COMPILER} -dumpversion 2>/dev/null`
+
+    case "$COMPILER_VERSION" in
+    *.*.*)
+        QT_GCC_MAJOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\1,'`
+        QT_GCC_MINOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\2,'`
+        QT_GCC_PATCH_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\3,'`
+        ;;
+    *.*)
+        QT_GCC_MAJOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\).*,\1,'`
+        QT_GCC_MINOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\).*,\2,'`
+        QT_GCC_PATCH_VERSION=0
+        ;;
+    esac
+
+    case "$COMPILER_VERSION" in
+    2.95.*)
+        COMPILER_VERSION="2.95.*"
+        ;;
+    3.*)
+        COMPILER_VERSION="3.*"
+        ;;
+    4.*)
+        COMPILER_VERSION="4"
+        ;;
+    *)
+        ;;
+    esac
+    [ '!' -z "$COMPILER_VERSION" ] && COMPILER="g++-${COMPILER_VERSION}"
+    ;;
+icc*)
+    # The Intel CC compiler on Unix systems matches the ABI of the g++
+    # that is found on PATH
+    COMPAT_COMPILER="icc"
+    COMPILER="g++-4"
+    case "`g++ -dumpversion` 2>/dev/null" in
+    2.95.*)
+        COMPILER="g++-2.95.*"
+        ;;
+    3.*)
+a        COMPILER="g++-3.*"
+        ;;
+    *)
+        ;;
+    esac
+    ;;
+*)
+    #
+    ;;
+esac
+
+# QT_CONFIG can contain the following:
+#
+# Things that affect the Qt API/ABI:
+#
+#   Options:
+#     minimal-config small-config medium-config large-config full-config
+#
+#   Different edition modules:
+#     gui network canvas table xml opengl sql
+#
+# Things that do not affect the Qt API/ABI:
+#     stl
+#     system-jpeg no-jpeg jpeg
+#     system-mng no-mng mng
+#     system-png no-png png
+#     system-zlib no-zlib zlib
+#     system-libtiff no-libtiff
+#     no-gif gif
+#     debug release
+#     dll staticlib
+#
+#     nocrosscompiler
+#     GNUmake
+#     largefile
+#     nis
+#     nas
+#     tablet
+#     ipv6
+#
+#     X11     : x11sm xinerama xcursor xfixes xrandr xrender mitshm fontconfig xkb
+#     Embedded: embedded qpa freetype
+#
+ALL_OPTIONS=
+BUILD_CONFIG=
+BUILD_OPTIONS=
+
+# determine the build options
+for config_option in $QMAKE_CONFIG $QT_CONFIG; do
+    SKIP="yes"
+    case "$config_option" in
+    *-config)
+        # take the last *-config setting.  this is the highest config being used,
+        # and is the one that we will use for tagging plugins
+        BUILD_CONFIG="$config_option"
+        ;;
+
+    *) # skip all other options since they don't affect the Qt API/ABI.
+        ;;
+    esac
+
+    if [ "$SKIP" = "no" ]; then
+        BUILD_OPTIONS="$BUILD_OPTIONS $config_option"
+    fi
+done
+
+# put the options that we are missing into .options
+rm -f .options
+for opt in `echo $ALL_OPTIONS`; do
+    SKIP="no"
+    if echo $BUILD_OPTIONS | grep $opt >/dev/null 2>&1; then
+        SKIP="yes"
+    fi
+    if [ "$SKIP" = "no" ]; then
+        echo "$opt" >> .options
+    fi
+done
+
+# reconstruct BUILD_OPTIONS with a sorted negative feature list
+# (ie. only things that are missing are will be put into the build key)
+BUILD_OPTIONS=
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+        BUILD_OPTIONS="$BUILD_OPTIONS no-$opt"
+    done
+fi
+rm -f .options
+
+# QT_NO* defines affect the Qt API (and binary compatibility).  they need
+# to be included in the build key
+for build_option in $D_FLAGS; do
+    build_option=`echo $build_option | cut -d \" -f 2 -`
+    case "$build_option" in
+    QT_NO*)
+        echo "$build_option" >> .options
+        ;;
+    *)
+        # skip all other compiler defines
+        ;;
+    esac
+done
+
+# sort the compile time defines (helps ensure that changes in this configure
+# script don't affect the QT_BUILD_KEY generation)
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+        BUILD_OPTIONS="$BUILD_OPTIONS $opt"
+    done
+fi
+rm -f .options
+
+BUILD_OPTIONS="$BUILD_CONFIG $BUILD_OPTIONS"
+# extract the operating system from the XPLATFORM
+TARGET_OPERATING_SYSTEM=`echo $XPLATFORM | cut -f 2- -d/ | cut -f -1 -d-`
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    QT_BUILD_KEY_SYSTEM_PART="Symbian"
+else
+    QT_BUILD_KEY_SYSTEM_PART="$CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPILER"
+fi
+
+# when cross-compiling, don't include build-host information (build key is target specific)
+QT_BUILD_KEY="$CFG_USER_BUILD_KEY $QT_BUILD_KEY_SYSTEM_PART $BUILD_OPTIONS"
+if [ -n "$QT_NAMESPACE" ]; then
+    QT_BUILD_KEY="$QT_BUILD_KEY $QT_NAMESPACE"
+fi
+MAC_NEED_TWO_BUILD_KEYS="no"
+if [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" ]; then
+    QT_BUILD_KEY_CARBON=$QT_BUILD_KEY
+    TARGET_OPERATING_SYSTEM="$TARGET_OPERATING_SYSTEM-cocoa"
+    QT_BUILD_KEY_COCOA="$CFG_USER_BUILD_KEY $CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ "$CFG_MAC_CARBON" = "no" ]; then
+        QT_BUILD_KEY=$QT_BUILD_KEY_COCOA
+    else
+        MAC_NEED_TWO_BUILD_KEYS="yes"
+    fi
+fi
+# don't break loading plugins build with an older version of Qt
+QT_BUILD_KEY_COMPAT=
+if [ "$QT_CROSS_COMPILE" = "no" ]; then
+    # previous versions of Qt used a build key built from the uname
+    QT_BUILD_KEY_COMPAT="$CFG_USER_BUILD_KEY $UNAME_MACHINE $UNAME_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT="$QT_BUILD_KEY_COMPAT $QT_NAMESPACE"
+    fi
+fi
+
+# is this compiler compatible with some other "standard" build key
+QT_BUILD_KEY_COMPAT_COMPILER=
+if [ ! -z "$COMPAT_COMPILER" ]; then
+    QT_BUILD_KEY_COMPAT_COMPILER="$CFG_USER_BUILD_KEY $CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPAT_COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT_COMPILER="$QT_BUILD_KEY_COMPAT_COMPILER $QT_NAMESPACE"
+    fi
+fi
+
+# is this arch compatible with some other "standard" build key
+QT_BUILD_KEY_COMPAT_ARCH=
+if [ ! -z "$COMPAT_ARCH" ]; then
+    QT_BUILD_KEY_COMPAT_ARCH="$CFG_USER_BUILD_KEY $COMPAT_ARCH $TARGET_OPERATING_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT_COMPILER="$QT_BUILD_KEY_COMPAT_ARCH $QT_NAMESPACE"
+    fi
+fi
+
+# strip out leading/trailing/extra whitespace
+QT_BUILD_KEY=`echo $QT_BUILD_KEY | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT=`echo $QT_BUILD_KEY_COMPAT | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT_COMPILER=`echo $QT_BUILD_KEY_COMPAT_COMPILER | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT_ARCH=`echo $QT_BUILD_KEY_COMPAT_ARCH | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+
+#-------------------------------------------------------------------------------
+# part of configuration information goes into qconfig.h
+#-------------------------------------------------------------------------------
+
+case "$CFG_QCONFIG" in
+full)
+    echo "/* Everything */" >"$outpath/src/corelib/global/qconfig.h.new"
+    ;;
+*)
+    tmpconfig="$outpath/src/corelib/global/qconfig.h.new"
+    echo "#ifndef QT_BOOTSTRAPPED" >"$tmpconfig"
+    if [ -f "$relpath/src/corelib/global/qconfig-$CFG_QCONFIG.h" ]; then
+        cat "$relpath/src/corelib/global/qconfig-$CFG_QCONFIG.h" >>"$tmpconfig"
+    elif [ -f `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` ]; then
+        cat `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` >>"$tmpconfig"
+    fi
+    echo "#endif" >>"$tmpconfig"
+    ;;
+esac
+
+cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+
+/* Qt Edition */
+#ifndef QT_EDITION
+#  define QT_EDITION $QT_EDITION
+#endif
+
+/* Machine byte-order */
+#define Q_BIG_ENDIAN 4321
+#define Q_LITTLE_ENDIAN 1234
+EOF
+
+if [ "$MAC_NEED_TWO_BUILD_KEYS" = "no" ]; then
+    echo "#define QT_BUILD_KEY \"$QT_BUILD_KEY\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+else
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+
+#define QT_BUILD_KEY_CARBON "$QT_BUILD_KEY_CARBON"
+#define QT_BUILD_KEY_COCOA "$QT_BUILD_KEY_COCOA"
+EOF
+fi
+
+if [ -n "$QT_BUILD_KEY_COMPAT" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT \"$QT_BUILD_KEY_COMPAT\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+if [ -n "$QT_BUILD_KEY_COMPAT_COMPILER" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT2 \"$QT_BUILD_KEY_COMPAT_COMPILER\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+if [ -n "$QT_BUILD_KEY_COMPAT_ARCH" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT3 \"$QT_BUILD_KEY_COMPAT_ARCH\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+echo "" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+echo "#ifdef QT_BOOTSTRAPPED" >>"$outpath/src/corelib/global/qconfig.h.new"
+if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__BIG_ENDIAN__)
+# define Q_BYTE_ORDER Q_BIG_ENDIAN
+#elif defined(__LITTLE_ENDIAN__)
+# define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+# error "Unable to determine byte order!"
+#endif
+EOF
+else
+    echo "#define Q_BYTE_ORDER $CFG_HOST_ENDIAN" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+echo "#else" >>"$outpath/src/corelib/global/qconfig.h.new"
+if [ "$CFG_ENDIAN" = "auto" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__BIG_ENDIAN__)
+# define Q_BYTE_ORDER Q_BIG_ENDIAN
+#elif defined(__LITTLE_ENDIAN__)
+# define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+# error "Unable to determine byte order!"
+#endif
+EOF
+else
+    echo "#define Q_BYTE_ORDER $CFG_ENDIAN" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+echo "#endif" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_DOUBLEFORMAT" != "normal" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+/* Non-IEEE double format */
+#define Q_DOUBLE_LITTLE "01234567"
+#define Q_DOUBLE_BIG "76543210"
+#define Q_DOUBLE_LITTLE_SWAPPED "45670123"
+#define Q_DOUBLE_BIG_SWAPPED "32107654"
+#define Q_DOUBLE_FORMAT $CFG_DOUBLEFORMAT
+EOF
+fi
+if [ "$CFG_ARMFPA" = "yes" ]; then
+    if [ "$CFG_ARCH" != "$CFG_HOST_ARCH" ]; then
+	cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#ifndef QT_BOOTSTRAPPED
+# define QT_ARMFPA
+#endif
+EOF
+    else
+	echo "#define QT_ARMFPA" >>"$outpath/src/corelib/global/qconfig.h.new"
+    fi
+fi
+
+CFG_ARCH_STR=`echo $CFG_ARCH | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+CFG_HOST_ARCH_STR=`echo $CFG_HOST_ARCH | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+/* Machine Architecture */
+#ifndef QT_BOOTSTRAPPED
+# define QT_ARCH_${CFG_ARCH_STR}
+#else
+# define QT_ARCH_${CFG_HOST_ARCH_STR}
+#endif
+EOF
+
+echo '/* Compile time features */' >>"$outpath/src/corelib/global/qconfig.h.new"
+[ '!' -z "$LicenseKeyExt" ] && echo "#define QT_PRODUCT_LICENSEKEY \"$LicenseKeyExt\"" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_LARGEFILE" = "yes" ] && [ "$XPLATFORM_MINGW" != "yes" ]; then
+    echo "#define QT_LARGEFILE_SUPPORT 64" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+# if both carbon and cocoa are specified, enable the autodetection code.
+if [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" -a "$CFG_MAC_CARBON" = "yes" ]; then
+    echo "#define QT_AUTODETECT_COCOA 1" >>"$outpath/src/corelib/global/qconfig.h.new"
+elif [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" ]; then
+    echo "#define QT_MAC_USE_COCOA 1" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+if [ "$CFG_FRAMEWORK" = "yes" ]; then
+    echo "#define QT_MAC_FRAMEWORK_BUILD" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__LP64__)
+# define QT_POINTER_SIZE 8
+#else
+# define QT_POINTER_SIZE 4
+#endif
+EOF
+elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    # Raptor does not support configure tests.
+    "$unixtests/ptrsize.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+    echo "#define QT_POINTER_SIZE $?" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+
+echo "" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_DEV" = "yes" ]; then
+    echo "#define QT_BUILD_INTERNAL" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+# Embedded compile time options
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    # Add QWS to config.h
+    QCONFIG_FLAGS="$QCONFIG_FLAGS Q_WS_QWS"
+
+    # Add excluded decorations to $QCONFIG_FLAGS
+    decors=`grep '^decorations -= ' "$QMAKE_VARS_FILE" | ${AWK} '{print $3}'`
+    for decor in $decors; do
+        NODECORATION=`echo $decor | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="${QCONFIG_FLAGS} QT_NO_QWS_DECORATION_${NODECORATION}"
+    done
+
+    # Figure which embedded drivers which are turned off
+    CFG_GFX_OFF="$CFG_GFX_AVAILABLE"
+    for ADRIVER in $CFG_GFX_ON; do
+        CFG_GFX_OFF=`echo "${CFG_GFX_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    CFG_KBD_OFF="$CFG_KBD_AVAILABLE"
+    # the um driver is currently not in the available list for external builds
+    if [ "$CFG_DEV" = "no" ]; then
+	CFG_KBD_OFF="$CFG_KBD_OFF um"
+    fi
+    for ADRIVER in $CFG_KBD_ON; do
+        CFG_KBD_OFF=`echo "${CFG_KBD_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    CFG_MOUSE_OFF="$CFG_MOUSE_AVAILABLE"
+    for ADRIVER in $CFG_MOUSE_ON; do
+        CFG_MOUSE_OFF=`echo "${CFG_MOUSE_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    for DRIVER in $CFG_GFX_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_$NODRIVER"
+    done
+
+    for DRIVER in $CFG_KBD_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_KBD_$NODRIVER"
+    done
+
+    for DRIVER in $CFG_MOUSE_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_MOUSE_$NODRIVER"
+    done
+fi # QWS
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    # Add QPA to config.h
+    QCONFIG_FLAGS="$QCONFIG_FLAGS Q_WS_QPA QT_NO_QWS_QPF QT_NO_QWS_QPF2"
+fi
+
+if [ "${CFG_USE_FLOATMATH}" = "yes" ]; then
+    QCONFIG_FLAGS="${QCONFIG_FLAGS} QT_USE_MATH_H_FLOATS"
+fi
+
+# Add turned on SQL drivers
+for DRIVER in $CFG_SQL_AVAILABLE; do
+    eval "VAL=\$CFG_SQL_$DRIVER"
+    case "$VAL" in
+    qt)
+        ONDRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_SQL_$ONDRIVER"
+        SQL_DRIVERS="$SQL_DRIVERS $DRIVER"
+    ;;
+    plugin)
+        SQL_PLUGINS="$SQL_PLUGINS $DRIVER"
+    ;;
+    esac
+done
+
+
+QMakeVar set sql-drivers "$SQL_DRIVERS"
+QMakeVar set sql-plugins "$SQL_PLUGINS"
+
+# Add other configuration options to the qconfig.h file
+[ "$CFG_GIF" = "yes" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_BUILTIN_GIF_READER=1"
+[ "$CFG_TIFF" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_TIFF"
+[ "$CFG_PNG" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_PNG"
+[ "$CFG_JPEG" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_JPEG"
+[ "$CFG_MNG" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_MNG"
+[ "$CFG_ZLIB" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ZLIB"
+[ "$CFG_S60" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_S60"
+[ "$CFG_EXCEPTIONS" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_EXCEPTIONS"
+[ "$CFG_IPV6" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IPV6"
+[ "$CFG_SXE" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SXE"
+[ "$CFG_DBUS" = "no" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_DBUS"
+
+if [ "$PLATFORM_QWS" != "yes" -a "$PLATFORM_QPA" != "yes" ]; then
+    [ "$CFG_GRAPHICS_SYSTEM" = "raster" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_RASTER"
+    [ "$CFG_GRAPHICS_SYSTEM" = "opengl" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_OPENGL"
+    [ "$CFG_GRAPHICS_SYSTEM" = "openvg" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_OPENVG"
+    [ "$CFG_GRAPHICS_SYSTEM" = "runtime" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_RUNTIME"
+fi
+
+# On Windows codec plugins are used (hardcoded in .pro files)
+if [ "$XPLATFORM_MINGW" = "yes" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_CODEC_PLUGINS"
+fi
+
+# X11/Unix/Mac only configs
+[ "$CFG_ICONV" = "no" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ICONV"
+[ "$CFG_GLIB" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GLIB"
+[ "$CFG_QGTKSTYLE" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_GTK"
+if [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+    # Do not apply following negative X11/Unix/Mac only flags on Symbian, so that
+    # configuration matches with the one generated by configure executable tool
+    [ "$CFG_CUPS" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CUPS"
+    [ "$CFG_GSTREAMER" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GSTREAMER"
+    [ "$CFG_CLOCK_MONOTONIC" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CLOCK_MONOTONIC"
+    [ "$CFG_MREMAP" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MREMAP"
+    [ "$CFG_GETADDRINFO" = "no" ]&& QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GETADDRINFO"
+    [ "$CFG_IPV6IFNAME" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IPV6IFNAME"
+    [ "$CFG_GETIFADDRS" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GETIFADDRS"
+    [ "$CFG_INOTIFY" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_INOTIFY"
+    [ "$CFG_NAS" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_NAS"
+    [ "$CFG_NIS" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_NIS"
+    [ "$CFG_OPENSSL" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENSSL"
+    [ "$CFG_OPENSSL" = "linked" ]&& QCONFIG_FLAGS="$QCONFIG_FLAGS QT_LINKED_OPENSSL"
+
+    [ "$CFG_SM" = "no" ]         && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SESSIONMANAGER"
+    [ "$CFG_XCURSOR" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XCURSOR"
+    [ "$CFG_XFIXES" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XFIXES"
+    [ "$CFG_FONTCONFIG" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_FONTCONFIG"
+    [ "$CFG_XINERAMA" = "no" ]   && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINERAMA"
+    [ "$CFG_XKB" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XKB"
+    [ "$CFG_XRANDR" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XRANDR"
+    [ "$CFG_XRENDER" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XRENDER"
+    [ "$CFG_MITSHM" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MITSHM"
+    [ "$CFG_XSHAPE" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SHAPE"
+    [ "$CFG_XVIDEO" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XVIDEO"
+    [ "$CFG_XSYNC" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XSYNC"
+    [ "$CFG_XINPUT" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINPUT QT_NO_TABLET"
+
+    [ "$CFG_XCURSOR" = "runtime" ]   && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XCURSOR"
+    [ "$CFG_XINERAMA" = "runtime" ]  && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XINERAMA"
+    [ "$CFG_XFIXES" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XFIXES"
+    [ "$CFG_XRANDR" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XRANDR"
+    [ "$CFG_XINPUT" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XINPUT"
+    [ "$CFG_ALSA" = "no" ]           && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ALSA"
+    [ "$CFG_PULSEAUDIO" = "no" ]          && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_PULSEAUDIO"
+    [ "$CFG_COREWLAN" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_COREWLAN"
+    [ "$CFG_ICD" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ICD"
+fi
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # Disable styles not applicable on Symbian
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_CDE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_CLEANLOOKS"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_MOTIF"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_PLASTIQUE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSCE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSMOBILE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSVISTA"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSXP"
+fi
+
+# sort QCONFIG_FLAGS for neatness if we can
+[ '!' -z "$AWK" ] && QCONFIG_FLAGS=`echo $QCONFIG_FLAGS | $AWK '{ gsub(" ", "\n"); print }' | sort | uniq`
+QCONFIG_FLAGS=`echo $QCONFIG_FLAGS`
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # Enable Symbian DLLs and export rules.
+    # We cannot use Linux's default export rules since they export everything.
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_DLL"
+    # Disable non-working features.
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CRASHHANDLER QT_NO_PRINTER QT_NO_SYSTEMTRAYICON"
+fi
+
+if [ -n "$QCONFIG_FLAGS" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#ifndef QT_BOOTSTRAPPED
+
+EOF
+    # default QPA platform specified?
+    if [ -n "$QT_QPA_DEFAULT_PLATFORM" ] && [ "$QT_QPA_DEFAULT_PLATFORM" != "auto" ]; then
+        echo "#define QT_QPA_DEFAULT_PLATFORM_NAME \"$QT_QPA_DEFAULT_PLATFORM\"" >>"$outpath/src/corelib/global/qconfig.h.new"
+        echo >>"$outpath/src/corelib/global/qconfig.h.new"
+    fi
+
+    for cfg in $QCONFIG_FLAGS; do
+        cfgd=`echo $cfg | sed 's/=.*$//'` # trim pushed 'Foo=Bar' defines
+        cfg=`echo $cfg | sed 's/=/ /'`    # turn first '=' into a space
+        # figure out define logic, so we can output the correct
+        # ifdefs to override the global defines in a project
+        cfgdNeg=
+        if [ true ] && echo "$cfgd" | grep 'QT_NO_' >/dev/null 2>&1; then
+            # QT_NO_option can be forcefully turned on by QT_option
+            cfgdNeg=`echo $cfgd | sed "s,QT_NO_,QT_,"`
+        elif [ true ] && echo "$cfgd" | grep 'QT_' >/dev/null 2>&1; then
+            # QT_option can be forcefully turned off by QT_NO_option
+            cfgdNeg=`echo $cfgd | sed "s,QT_,QT_NO_,"`
+        fi
+
+        if [ -z $cfgdNeg ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#ifndef $cfgd
+# define $cfg
+#endif
+
+EOF
+        else
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#if defined($cfgd) && defined($cfgdNeg)
+# undef $cfgd
+#elif !defined($cfgd) && !defined($cfgdNeg)
+# define $cfg
+#endif
+
+EOF
+        fi
+    done
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#endif // QT_BOOTSTRAPPED
+
+EOF
+fi
+
+if [ "$CFG_REDUCE_EXPORTS" = "yes" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_VISIBILITY_AVAILABLE
+
+EOF
+fi
+
+if [ -n "$QT_LIBINFIX" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_LIBINFIX "$QT_LIBINFIX"
+
+EOF
+fi
+
+if [ -n "$CFG_RUNTIME_SYSTEM" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_DEFAULT_RUNTIME_SYSTEM "$CFG_RUNTIME_SYSTEM"
+
+EOF
+fi
+
+# avoid unecessary rebuilds by copying only if qconfig.h has changed
+if cmp -s "$outpath/src/corelib/global/qconfig.h" "$outpath/src/corelib/global/qconfig.h.new"; then
+    rm -f "$outpath/src/corelib/global/qconfig.h.new"
+else
+    [ -f "$outpath/src/corelib/global/qconfig.h" ] && chmod +w "$outpath/src/corelib/global/qconfig.h"
+    mv "$outpath/src/corelib/global/qconfig.h.new" "$outpath/src/corelib/global/qconfig.h"
+    chmod -w "$outpath/src/corelib/global/qconfig.h"
+    for conf in "$outpath/include/QtCore/qconfig.h" "$outpath/include/Qt/qconfig.h"; do
+        ln -s "$outpath/src/corelib/global/qconfig.h" "$conf"
+    done
+fi
+#-------------------------------------------------------------------------------
+# save configuration into qconfig.pri
+#-------------------------------------------------------------------------------
+
+QTCONFIG="$outpath/mkspecs/qconfig.pri"
+QTCONFIG_CONFIG="$QTCONFIG_CONFIG no_mocdepend"
+[ -f "$QTCONFIG.tmp" ] && rm -f "$QTCONFIG.tmp"
+if [ "$CFG_DEBUG" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG debug"
+    if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG release"
+    fi
+    QT_CONFIG="$QT_CONFIG debug"
+elif [ "$CFG_DEBUG" = "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG release"
+    if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG debug"
+    fi
+    QT_CONFIG="$QT_CONFIG release"
+fi
+if [ "$CFG_STL" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG stl"
+fi
+if [ "$CFG_FRAMEWORK" = "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_no_framework"
+else
+    QT_CONFIG="$QT_CONFIG qt_framework"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_framework"
+fi
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG $CFG_MAC_ARCHS"
+fi
+if [ "$CFG_DEV" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG private_tests"
+fi
+
+if [ -z "$QT_CFLAGS_FPU" ]; then
+    if echo "$XPLATFORM" | grep "symbian-sbsv2" > /dev/null 2>&1; then
+        QT_CFLAGS_FPU=softvfp
+    fi
+fi
+
+# Make the application arch follow the Qt arch for single arch builds.
+# (for multiple-arch builds, set CONFIG manually in the application .pro file)
+if [ `echo "$CFG_MAC_ARCHS" | wc -w` -eq 1 ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG $CFG_MAC_ARCHS"
+fi
+
+cat >>"$QTCONFIG.tmp" <<EOF
+#configuration
+CONFIG += $QTCONFIG_CONFIG
+QT_ARCH = $CFG_ARCH
+QT_EDITION = $Edition
+QT_CONFIG += $QT_CONFIG
+
+#versioning
+QT_VERSION = $QT_VERSION
+QT_MAJOR_VERSION = $QT_MAJOR_VERSION
+QT_MINOR_VERSION = $QT_MINOR_VERSION
+QT_PATCH_VERSION = $QT_PATCH_VERSION
+
+#namespaces
+QT_LIBINFIX = $QT_LIBINFIX
+QT_NAMESPACE = $QT_NAMESPACE
+QT_NAMESPACE_MAC_CRC = $QT_NAMESPACE_MAC_CRC
+
+EOF
+if [ -n "$CFG_SYSROOT" ]; then
+    echo "# sysroot" >>"$QTCONFIG.tmp"
+    echo `basename "$XQMAKESPEC"` \{ >>"$QTCONFIG.tmp"
+    echo "  QT_SYSROOT      += \$\$quote($CFG_SYSROOT)" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_CFLAGS    += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_CXXFLAGS  += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_LFLAGS    += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "}" >> "$QTCONFIG.tmp"
+    echo >> "$QTCONFIG.tmp"
+fi
+if [ "$CFG_RPATH" = "yes" ]; then
+    echo "QMAKE_RPATHDIR += \"$QT_INSTALL_LIBS\"" >> "$QTCONFIG.tmp"
+fi
+if [ -n "$QT_GCC_MAJOR_VERSION" ]; then
+    echo "QT_GCC_MAJOR_VERSION = $QT_GCC_MAJOR_VERSION" >> "$QTCONFIG.tmp"
+    echo "QT_GCC_MINOR_VERSION = $QT_GCC_MINOR_VERSION" >> "$QTCONFIG.tmp"
+    echo "QT_GCC_PATCH_VERSION = $QT_GCC_PATCH_VERSION" >> "$QTCONFIG.tmp"
+fi
+if [ -n "$QT_CFLAGS_FPU" ]; then
+    echo "#Qt for symbian FPU settings" >> "$QTCONFIG.tmp"
+    echo "MMP_RULES += \"ARMFPU $QT_CFLAGS_FPU\"" >> "$QTCONFIG.tmp"
+fi
+
+if [ -n "$QMAKE_INCDIR_OPENGL_ES2" ]; then
+    echo "#Qt opengl include path" >> "$QTCONFIG.tmp"
+    echo "QMAKE_INCDIR_OPENGL_ES2 = \"$QMAKE_INCDIR_OPENGL_ES2\"" >> "$QTCONFIG.tmp"
+fi
+
+# replace qconfig.pri if it differs from the newly created temp file
+if cmp -s "$QTCONFIG.tmp" "$QTCONFIG"; then
+    rm -f "$QTCONFIG.tmp"
+else
+    mv -f "$QTCONFIG.tmp" "$QTCONFIG"
+fi
+
+#-------------------------------------------------------------------------------
+# save configuration into .qmake.cache
+#-------------------------------------------------------------------------------
+
+CACHEFILE="$outpath/.qmake.cache"
+[ -f "$CACHEFILE.tmp" ] && rm -f "$CACHEFILE.tmp"
+cat >>"$CACHEFILE.tmp" <<EOF
+CONFIG += $QMAKE_CONFIG dylib create_prl link_prl depend_includepath fix_output_dirs QTDIR_build
+QT_SOURCE_TREE = \$\$quote($relpath)
+QT_BUILD_TREE = \$\$quote($outpath)
+QT_BUILD_PARTS = $CFG_BUILD_PARTS
+QMAKE_ABSOLUTE_SOURCE_ROOT = \$\$QT_SOURCE_TREE
+QMAKE_MOC_SRC    = \$\$QT_BUILD_TREE/src/moc
+
+#local paths that cannot be queried from the QT_INSTALL_* properties while building QTDIR
+QMAKE_MOC        = \$\$QT_BUILD_TREE/bin/moc
+QMAKE_UIC        = \$\$QT_BUILD_TREE/bin/uic
+QMAKE_UIC3       = \$\$QT_BUILD_TREE/bin/uic3
+QMAKE_RCC        = \$\$QT_BUILD_TREE/bin/rcc
+QMAKE_QDBUSXML2CPP = \$\$QT_BUILD_TREE/bin/qdbusxml2cpp
+QMAKE_INCDIR_QT  = \$\$QT_BUILD_TREE/include
+QMAKE_LIBDIR_QT  = \$\$QT_BUILD_TREE/lib
+
+EOF
+
+# Ensure we can link to uninistalled libraries
+QMAKE_COMPILER="`getQMakeConf QMAKE_CXX`"
+if [ "$XPLATFORM_MINGW" != "yes" ] && [ "$CFG_EMBEDDED" != "nacl" ] && linkerSupportsFlag "$QMAKE_COMPILER" -rpath-link "$outpath/lib"; then
+    echo "QMAKE_LFLAGS    = -Wl,-rpath-link,\$\$QT_BUILD_TREE/lib \$\$QMAKE_LFLAGS" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_PSQL" ]; then
+    echo "QT_CFLAGS_PSQL   = $QT_CFLAGS_PSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_PSQL" ]; then
+    echo "QT_LFLAGS_PSQL   = $QT_LFLAGS_PSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_MYSQL" ]; then
+    echo "QT_CFLAGS_MYSQL   = $QT_CFLAGS_MYSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_MYSQL" ]; then
+    echo "QT_LFLAGS_MYSQL   = $QT_LFLAGS_MYSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_SQLITE" ]; then
+    echo "QT_CFLAGS_SQLITE   = $QT_CFLAGS_SQLITE" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_SQLITE" ]; then
+    echo "QT_LFLAGS_SQLITE   = $QT_LFLAGS_SQLITE" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_ODBC" ]; then
+    echo "QT_LFLAGS_ODBC   = $QT_LFLAGS_ODBC" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_TDS" ]; then
+    echo "QT_LFLAGS_TDS   = $QT_LFLAGS_TDS" >> "$CACHEFILE.tmp"
+fi
+
+if [ "$QT_EDITION" != "QT_EDITION_OPENSOURCE" ]; then
+    echo "DEFINES *= QT_EDITION=QT_EDITION_DESKTOP" >> "$CACHEFILE.tmp"
+fi
+
+#dump in the OPENSSL_LIBS info
+if [ '!' -z "$OPENSSL_LIBS" ]; then
+    echo "OPENSSL_LIBS = $OPENSSL_LIBS" >> "$CACHEFILE.tmp"
+elif [ "$CFG_OPENSSL" = "linked" ]; then
+    echo "OPENSSL_LIBS = -lssl -lcrypto" >> "$CACHEFILE.tmp"
+fi
+
+#dump in the SDK info
+if [ '!' -z "$CFG_SDK" ]; then
+   echo "QMAKE_MAC_SDK = $CFG_SDK" >> "$CACHEFILE.tmp"
+fi
+
+# mac gcc -Xarch support
+if [ "$CFG_MAC_XARCH" = "no" ]; then
+   echo "QMAKE_MAC_XARCH = no" >> "$CACHEFILE.tmp"
+fi
+
+#dump the qmake spec
+if [ -d "$outpath/mkspecs/$XPLATFORM" ]; then
+   echo "QMAKESPEC = \$\$QT_BUILD_TREE/mkspecs/$XPLATFORM" >> "$CACHEFILE.tmp"
+else
+   echo "QMAKESPEC = $XPLATFORM" >> "$CACHEFILE.tmp"
+fi
+
+# cmdline args
+cat "$QMAKE_VARS_FILE" >> "$CACHEFILE.tmp"
+rm -f "$QMAKE_VARS_FILE" 2>/dev/null
+
+# incrementals
+INCREMENTAL=""
+[ "$CFG_INCREMENTAL" = "auto" ] && "$WHICH" p4 >/dev/null 2>&1 && [ "$CFG_DEV" = "yes" ] && CFG_INCREMENTAL="yes"
+if [ "$CFG_INCREMENTAL" = "yes" ]; then
+    find "$relpath" -perm u+w -mtime -3 | grep 'cpp$' | while read f; do
+        # don't need to worry about generated files
+        [ -r `echo $f | sed "s,cpp$,ui,"` ] && continue
+        basename "$f" | grep '^moc_' >/dev/null 2>&1 && continue
+        # done
+        INCREMENTAL="$INCREMENTAL `basename \"$f\" | sed 's,.cpp,.o,'`"
+    done
+    [ '!' -z "$INCREMENTAL" ] && echo "QMAKE_INCREMENTAL += $INCREMENTAL" >> "$CACHEFILE.tmp"
+    [ -r "$outpath/.qmake.incremental" ] && echo "include($outpath/.qmake.incremental)" >> "$CACHEFILE.tmp"
+fi
+
+# replace .qmake.cache if it differs from the newly created temp file
+if cmp -s "$CACHEFILE.tmp" "$CACHEFILE"; then
+    rm -f "$CACHEFILE.tmp"
+else
+    mv -f "$CACHEFILE.tmp" "$CACHEFILE"
+fi
+
+#-------------------------------------------------------------------------------
+# give feedback on configuration
+#-------------------------------------------------------------------------------
+
+case "$COMPILER" in
+g++*)
+    if [ "$CFG_EXCEPTIONS" != "no" ]; then
+        cat <<EOF
+
+        This target is using the GNU C++ compiler ($PLATFORM).
+
+        Recent versions of this compiler automatically include code for
+        exceptions, which increase both the size of the Qt libraries and
+        the amount of memory taken by your applications.
+
+        You may choose to re-run `basename $0` with the -no-exceptions
+        option to compile Qt without exceptions. This is completely binary
+        compatible, and existing applications will continue to work.
+
+EOF
+    fi
+    ;;
+cc*)
+    case "$PLATFORM" in
+    irix-cc*)
+        if [ "$CFG_EXCEPTIONS" != "no" ]; then
+            cat <<EOF
+
+        This target is using the MIPSpro C++ compiler ($PLATFORM).
+
+        You may choose to re-run `basename $0` with the -no-exceptions
+        option to compile Qt without exceptions. This will make the
+        size of the Qt library smaller and reduce the amount of memory
+        taken by your applications.
+
+EOF
+        fi
+        ;;
+    *) ;;
+    esac
+    ;;
+*) ;;
+esac
+
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_DWARF2" = "no" ]  && [ "$CFG_WEBKIT" != "no" ] && [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    cat <<EOF
+        WARNING: DWARF2 debug symbols are not enabled. Linking webkit
+        in debug mode will run out of memory on systems with 2GB or less.
+        Install Xcode 2.4.1 or higher to enable DWARF2, or configure with
+         -no-webkit or -release to skip webkit debug.
+EOF
+fi
+
+echo
+if [ "$XPLATFORM" = "$PLATFORM" ]; then
+    echo "Build type:    $PLATFORM"
+else
+    echo "Building on:   $PLATFORM"
+    echo "Building for:  $XPLATFORM"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    echo "Architecture:  $CFG_ARCH ($CFG_MAC_ARCHS )"
+else
+    echo "Architecture:  $CFG_ARCH"
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    echo "Host architecture: $CFG_HOST_ARCH"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_MAC_COCOA" = "yes" ]; then
+        if [ "$CFG_MAC_CARBON" = "yes" ]; then
+            echo "Using framework: Carbon for 32-bit, Cocoa for 64-bit"
+        else
+            echo "Using framework: Cocoa"
+        fi
+    else
+        echo "Using framework: Carbon"
+    fi
+fi
+
+if [ -n "$PLATFORM_NOTES" ]; then
+    echo "Platform notes:"
+    echo "$PLATFORM_NOTES"
+else
+    echo
+fi
+
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo $ECHO_N "qmake vars .......... $ECHO_C"
+    cat "$QMAKE_VARS_FILE" | tr '\n' ' '
+    echo "qmake switches ......... $QMAKE_SWITCHES"
+fi
+
+[ "$CFG_INCREMENTAL" = "yes" ] && [ '!' -z "$INCREMENTAL" ] && echo "Incremental ............ $INCREMENTAL"
+echo "Build .................. $CFG_BUILD_PARTS"
+echo "Configuration .......... $QMAKE_CONFIG $QT_CONFIG"
+if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+   echo "Debug .................. yes (combined)"
+   if [ "$CFG_DEBUG" = "yes" ]; then
+       echo "Default Link ........... debug"
+   else
+       echo "Default Link ........... release"
+   fi
+else
+   echo "Debug .................. $CFG_DEBUG"
+fi
+echo "Qt 3 compatibility ..... $CFG_QT3SUPPORT"
+[ "$CFG_DBUS" = "no" ]     && echo "QtDBus module .......... no"
+[ "$CFG_DBUS" = "yes" ]    && echo "QtDBus module .......... yes (run-time)"
+[ "$CFG_DBUS" = "linked" ] && echo "QtDBus module .......... yes (linked)"
+echo "QtConcurrent code ...... $CFG_CONCURRENT"
+echo "QtGui module ........... $CFG_GUI"
+echo "QtScript module ........ $CFG_SCRIPT"
+echo "QtScriptTools module ... $CFG_SCRIPTTOOLS"
+echo "QtXmlPatterns module ... $CFG_XMLPATTERNS"
+echo "Phonon module .......... $CFG_PHONON"
+echo "Multimedia module ...... $CFG_MULTIMEDIA"
+echo "SVG module ............. $CFG_SVG"
+case "$CFG_WEBKIT" in
+    yes)   echo "WebKit module .......... yes" ;;
+    debug) echo "WebKit module .......... yes (debug)" ;;
+    no)    echo "WebKit module .......... no" ;;
+esac
+if [ "$CFG_WEBKIT" != "no" ] || [ "$CFG_SCRIPT" != "no" ]; then
+    if [ "$CFG_JAVASCRIPTCORE_JIT" = "auto" ]; then
+        echo "JavaScriptCore JIT ..... To be decided by JavaScriptCore"
+    else
+        echo "JavaScriptCore JIT ..... $CFG_JAVASCRIPTCORE_JIT"
+    fi
+fi
+echo "Declarative module ..... $CFG_DECLARATIVE"
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    echo "Declarative debugging ...$CFG_DECLARATIVE_DEBUG"
+fi
+echo "Support for S60 ........ $CFG_S60"
+echo "Symbian DEF files ...... $CFG_SYMBIAN_DEFFILES"
+echo "STL support ............ $CFG_STL"
+echo "PCH support ............ $CFG_PRECOMPILE"
+echo "MMX/3DNOW/SSE/SSE2/SSE3. ${CFG_MMX}/${CFG_3DNOW}/${CFG_SSE}/${CFG_SSE2}/${CFG_SSE3}"
+echo "SSSE3/SSE4.1/SSE4.2..... ${CFG_SSSE3}/${CFG_SSE4_1}/${CFG_SSE4_2}"
+echo "AVX..................... ${CFG_AVX}"
+if [ "$CFG_ARCH" = "arm" ] || [ "$CFG_ARCH" = "armv6" ]; then
+    echo "iWMMXt support ......... ${CFG_IWMMXT}"
+    echo "NEON support ........... ${CFG_NEON}"
+fi
+[ "${PLATFORM_QWS}" != "yes" -a "${PLATFORM_QPA}" != "yes" ] && echo "Graphics System ........ $CFG_GRAPHICS_SYSTEM"
+echo "IPv6 support ........... $CFG_IPV6"
+echo "IPv6 ifname support .... $CFG_IPV6IFNAME"
+echo "getaddrinfo support .... $CFG_GETADDRINFO"
+echo "getifaddrs support ..... $CFG_GETIFADDRS"
+echo "Accessibility .......... $CFG_ACCESSIBILITY"
+echo "NIS support ............ $CFG_NIS"
+echo "CUPS support ........... $CFG_CUPS"
+echo "Iconv support .......... $CFG_ICONV"
+echo "Glib support ........... $CFG_GLIB"
+echo "GStreamer support ...... $CFG_GSTREAMER"
+echo "PulseAudio support ..... $CFG_PULSEAUDIO"
+echo "Large File support ..... $CFG_LARGEFILE"
+echo "GIF support ............ $CFG_GIF"
+if [ "$CFG_TIFF" = "no" ]; then
+    echo "TIFF support ........... $CFG_TIFF"
+else
+    echo "TIFF support ........... $CFG_TIFF ($CFG_LIBTIFF)"
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    echo "JPEG support ........... $CFG_JPEG"
+else
+    echo "JPEG support ........... $CFG_JPEG ($CFG_LIBJPEG)"
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    echo "PNG support ............ $CFG_PNG"
+else
+    echo "PNG support ............ $CFG_PNG ($CFG_LIBPNG)"
+fi
+if [ "$CFG_MNG" = "no" ]; then
+    echo "MNG support ............ $CFG_MNG"
+else
+    echo "MNG support ............ $CFG_MNG ($CFG_LIBMNG)"
+fi
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    echo "SLOG2 support .......... $CFG_SLOG2"
+fi
+echo "zlib support ........... $CFG_ZLIB"
+echo "Session management ..... $CFG_SM"
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    echo "Embedded support ....... $CFG_EMBEDDED"
+    if [ "$CFG_QWS_FREETYPE" = "auto" ]; then
+	echo "Freetype2 support ...... $CFG_QWS_FREETYPE ($CFG_LIBFREETYPE)"
+    else
+	echo "Freetype2 support ...... $CFG_QWS_FREETYPE"
+    fi
+    # Normalize the decoration output first
+    CFG_GFX_ON=`echo ${CFG_GFX_ON}`
+    CFG_GFX_PLUGIN=`echo ${CFG_GFX_PLUGIN}`
+    echo "Graphics (qt) .......... ${CFG_GFX_ON}"
+    echo "Graphics (plugin) ...... ${CFG_GFX_PLUGIN}"
+    CFG_DECORATION_ON=`echo ${CFG_DECORATION_ON}`
+    CFG_DECORATION_PLUGIN=`echo ${CFG_DECORATION_PLUGIN}`
+    echo "Decorations (qt) ....... $CFG_DECORATION_ON"
+    echo "Decorations (plugin) ... $CFG_DECORATION_PLUGIN"
+    CFG_KBD_ON=`echo ${CFG_KBD_ON}`
+    CFG_KBD_PLUGIN=`echo ${CFG_KBD_PLUGIN}`
+    echo "Keyboard driver (qt) ... ${CFG_KBD_ON}"
+    echo "Keyboard driver (plugin) .. ${CFG_KBD_PLUGIN}"
+    CFG_MOUSE_ON=`echo ${CFG_MOUSE_ON}`
+    CFG_MOUSE_PLUGIN=`echo ${CFG_MOUSE_PLUGIN}`
+    echo "Mouse driver (qt) ...... $CFG_MOUSE_ON"
+    echo "Mouse driver (plugin) .. $CFG_MOUSE_PLUGIN"
+fi
+if [ "$CFG_OPENGL" = "desktop" ]; then
+    echo "OpenGL support ......... yes (Desktop OpenGL)"
+elif [ "$CFG_OPENGL" = "es1" ]; then
+    echo "OpenGL support ......... yes (OpenGL ES 1.x Common profile)"
+elif [ "$CFG_OPENGL" = "es2" ]; then
+    echo "OpenGL support ......... yes (OpenGL ES 2.x)"
+else
+    echo "OpenGL support ......... no"
+fi
+if [ "$CFG_EGL" != "no" ]; then
+    if [ "$CFG_EGL_GLES_INCLUDES" = "yes" ]; then
+        echo "EGL support ............ yes <GLES/egl.h>"
+    else
+        echo "EGL support ............ yes <EGL/egl.h>"
+    fi
+fi
+if [ "$CFG_OPENVG" ]; then
+    if [ "$CFG_OPENVG_SHIVA" = "yes" ]; then
+        echo "OpenVG support ......... ShivaVG"
+    else
+        echo "OpenVG support ......... $CFG_OPENVG"
+    fi
+fi
+if [ "$PLATFORM_X11" = "yes" ]; then
+    echo "NAS sound support ...... $CFG_NAS"
+    echo "XShape support ......... $CFG_XSHAPE"
+    echo "XVideo support ......... $CFG_XVIDEO"
+    echo "XSync support .......... $CFG_XSYNC"
+    echo "Xinerama support ....... $CFG_XINERAMA"
+    echo "Xcursor support ........ $CFG_XCURSOR"
+    echo "Xfixes support ......... $CFG_XFIXES"
+    echo "Xrandr support ......... $CFG_XRANDR"
+    echo "Xrender support ........ $CFG_XRENDER"
+    echo "Xi support ............. $CFG_XINPUT"
+    echo "MIT-SHM support ........ $CFG_MITSHM"
+    echo "FontConfig support ..... $CFG_FONTCONFIG"
+    echo "XKB Support ............ $CFG_XKB"
+    echo "immodule support ....... $CFG_IM"
+    echo "GTK theme support ...... $CFG_QGTKSTYLE"
+fi
+[ "$CFG_SQL_mysql" != "no" ] && echo "MySQL support .......... $CFG_SQL_mysql"
+[ "$CFG_SQL_psql" != "no" ] && echo "PostgreSQL support ..... $CFG_SQL_psql"
+[ "$CFG_SQL_odbc" != "no" ] && echo "ODBC support ........... $CFG_SQL_odbc"
+[ "$CFG_SQL_oci" != "no" ] && echo "OCI support ............ $CFG_SQL_oci"
+[ "$CFG_SQL_tds" != "no" ] && echo "TDS support ............ $CFG_SQL_tds"
+[ "$CFG_SQL_db2" != "no" ] && echo "DB2 support ............ $CFG_SQL_db2"
+[ "$CFG_SQL_ibase" != "no" ] && echo "InterBase support ...... $CFG_SQL_ibase"
+[ "$CFG_SQL_sqlite2" != "no" ] && echo "SQLite 2 support ....... $CFG_SQL_sqlite2"
+[ "$CFG_SQL_sqlite" != "no" ] && echo "SQLite support ......... $CFG_SQL_sqlite ($CFG_SQLITE)"
+
+OPENSSL_LINKAGE=""
+if [ "$CFG_OPENSSL" = "yes" ]; then
+    OPENSSL_LINKAGE="(run-time)"
+elif [ "$CFG_OPENSSL" = "linked" ]; then
+    OPENSSL_LINKAGE="(linked)"
+fi
+echo "OpenSSL support ........ $CFG_OPENSSL $OPENSSL_LINKAGE"
+echo "Alsa support ........... $CFG_ALSA"
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    echo "CoreWlan support ....... $CFG_COREWLAN"
+fi
+echo "ICD support ............ $CFG_ICD"
+echo "libICU support ......... $CFG_ICU"
+echo "Use system proxies ..... $CFG_SYSTEM_PROXIES"
+echo
+
+[ "$CFG_PTMALLOC" != "no" ] && echo "Use ptmalloc ........... $CFG_PTMALLOC"
+
+# complain about not being able to use dynamic plugins if we are using a static build
+if [ "$CFG_SHARED" = "no" ]; then
+    echo
+    echo "WARNING: Using static linking will disable the use of dynamically"
+    echo "loaded plugins. Make sure to import all needed static plugins,"
+    echo "or compile needed modules into the library."
+    echo
+fi
+if [ "$CFG_OPENSSL" = "linked" ] && [ "$OPENSSL_LIBS" = "" ]; then
+    echo
+    echo "NOTE: When linking against OpenSSL, you can override the default"
+    echo "library names through OPENSSL_LIBS."
+    echo "For example:"
+    echo "    OPENSSL_LIBS='-L/opt/ssl/lib -lssl -lcrypto' ./configure -openssl-linked"
+    echo
+fi
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_DEBUG" = "yes" ] && [ "$CFG_DEBUG_RELEASE" = "no" ]; then
+    echo
+    echo "Error: debug-only framework builds are not supported. Configure with -no-framework"
+    echo "if you want a pure debug build."
+    echo
+    exit 1
+fi
+
+sepath=`echo "$relpath" | sed -e 's/\\./\\\\./g'`
+PROCS=1
+EXEC=""
+
+
+#-------------------------------------------------------------------------------
+# build makefiles based on the configuration
+#-------------------------------------------------------------------------------
+
+echo "Finding project files. Please wait..."
+if [ "$CFG_NOPROCESS" != "yes" ]; then
+    "$outpath/bin/qmake" -prl -r "${relpath}/projects.pro"
+    if [ -f "${relpath}/projects.pro" ]; then
+        mkfile="${outpath}/Makefile"
+        [ -f "$mkfile" ] && chmod +w "$mkfile"
+        QTDIR="$outpath" "$outpath/bin/qmake" -spec "$XQMAKESPEC" "${relpath}/projects.pro" -o "$mkfile"
+    fi
+fi
+
+# .projects      -> projects to process
+# .projects.1    -> qt and moc
+# .projects.2    -> subdirs and libs
+# .projects.3    -> the rest
+rm -f .projects .projects.1 .projects.2 .projects.3
+
+QMAKE_PROJECTS=`find "$relpath/." -name '*.pro' -print | sed 's-/\./-/-'`
+if [ -z "$AWK" ]; then
+    for p in `echo $QMAKE_PROJECTS`; do
+        echo "$p" >> .projects
+    done
+else
+    cat >projects.awk <<EOF
+BEGIN {
+    files = 0
+    target_file = ""
+    input_file = ""
+
+    first = "./.projects.1.tmp"
+    second = "./.projects.2.tmp"
+    third = "./.projects.3.tmp"
+}
+
+FNR == 1 {
+    if ( input_file ) {
+        if ( ! target_file )
+            target_file = third
+        print input_file >target_file
+    }
+
+    matched_target = 0
+    template_lib = 0
+    input_file = FILENAME
+    target_file = ""
+}
+
+/^(TARGET.*=)/ {
+    if ( \$3 == "moc" || \$3 ~ /^Qt/ ) {
+        target_file = first
+        matched_target = 1
+    } else if ( \$3 == "lrelease" || \$3 == "qm_phony_target" ) {
+        target_file = second
+        matched_target = 1
+    }
+}
+
+matched_target == 0 && /^(TEMPLATE.*=)/ {
+    if ( \$3 == "subdirs" )
+        target_file = second
+    else if ( \$3 == "lib" )
+        template_lib = 1
+    else
+        target_file = third
+}
+
+matched_target == 0 && template_lib == 1 && /^(CONFIG.*=)/ {
+    if ( \$0 ~ /plugin/ )
+        target_file = third
+    else
+        target_file = second
+}
+
+END {
+    if ( input_file ) {
+        if ( ! target_file )
+            target_file = third
+        print input_file >>target_file
+    }
+}
+
+EOF
+
+    rm -f .projects.all
+    for p in `echo $QMAKE_PROJECTS`; do
+       echo "$p" >> .projects.all
+    done
+
+    # if you get errors about the length of the command line to awk, change the -l arg
+    # to split below
+    split -l 100 .projects.all .projects.all.
+    for p in .projects.all.*; do
+       "$AWK" -f projects.awk `cat $p`
+       [ -f .projects.1.tmp ] && cat .projects.1.tmp >> .projects.1
+       [ -f .projects.2.tmp ] && cat .projects.2.tmp >> .projects.2
+       [ -f .projects.3.tmp ] && cat .projects.3.tmp >> .projects.3
+       rm -f .projects.1.tmp .projects.2.tmp .projects.3.tmp $p
+    done
+    rm -f .projects.all* projects.awk
+
+    [ -f .projects.1 ] && cat .projects.1 >>.projects
+    [ -f .projects.2 ] && cat .projects.2 >>.projects
+    rm -f .projects.1 .projects.2
+    if [ -f .projects.3 ] && [ "$OPT_FAST" = "no" ]; then
+       cat .projects.3 >>.projects
+       rm -f .projects.3
+    fi
+fi
+# don't sort Qt and MOC in with the other project files
+# also work around a segfaulting uniq(1)
+if [ -f .sorted.projects.2 ]; then
+    sort .sorted.projects.2 > .sorted.projects.2.new
+    mv -f .sorted.projects.2.new .sorted.projects.2
+    cat .sorted.projects.2 >> .sorted.projects.1
+fi
+[ -f .sorted.projects.1 ] && sort .sorted.projects.1 >> .sorted.projects
+rm -f .sorted.projects.2 .sorted.projects.1
+
+NORM_PROJECTS=0
+FAST_PROJECTS=0
+if [ -f .projects ]; then
+   uniq .projects >.tmp
+   mv -f .tmp .projects
+   NORM_PROJECTS=`cat .projects | wc -l | sed -e "s, ,,g"`
+fi
+if [ -f .projects.3 ]; then
+   uniq .projects.3 >.tmp
+   mv -f .tmp .projects.3
+   FAST_PROJECTS=`cat .projects.3 | wc -l | sed -e "s, ,,g"`
+fi
+echo "  `expr $NORM_PROJECTS + $FAST_PROJECTS` projects found."
+echo
+
+PART_ROOTS=
+for part in $CFG_BUILD_PARTS; do
+    case "$part" in
+    tools) PART_ROOTS="$PART_ROOTS tools" ;;
+    libs) PART_ROOTS="$PART_ROOTS src tools/linguist/lrelease" ;;
+    translations) PART_ROOTS="$PART_ROOTS translations" ;;
+    examples) PART_ROOTS="$PART_ROOTS examples demos" ;;
+    *) ;;
+    esac
+done
+
+if [ "$CFG_DEV" = "yes" ]; then
+    PART_ROOTS="$PART_ROOTS tests"
+fi
+
+echo "Creating makefiles. Please wait..."
+for file in .projects .projects.3; do
+    [ '!' -f "$file" ] && continue
+    for a in `cat $file`; do
+        IN_ROOT=no
+	for r in $PART_ROOTS; do
+	    if echo "$a" | grep "^$r" >/dev/null 2>&1 || echo "$a" | grep "^$relpath/$r" >/dev/null 2>&1; then
+		IN_ROOT=yes
+		break
+            fi
+	done
+        [ "$IN_ROOT" = "no" ] && continue
+
+        case $a in
+        *winmain/winmain.pro)
+            if [ "$CFG_NOPROCESS" = "yes" ] || [ "$XPLATFORM_MINGW" != "yes" ]; then
+                continue
+            fi
+            SPEC=$XQMAKESPEC ;;
+        *s60main/s60main.pro)
+            if [ "$CFG_NOPROCESS" = "yes" ] || [ "$XPLATFORM_SYMBIAN" != "yes" ]; then
+                continue
+            fi;;
+        *examples/activeqt/*) continue ;;
+        */qmake/qmake.pro) continue ;;
+        *tools/bootstrap*|*tools/moc*|*tools/rcc*|*tools/uic*|*linguist/lrelease*) SPEC=$QMAKESPEC ;;
+        *) if [ "$CFG_NOPROCESS" = "yes" ]; then
+              continue
+           else
+              SPEC=$XQMAKESPEC
+           fi;;
+        esac
+        dir=`dirname "$a" | sed -e "s;$sepath;.;g"`
+        test -d "$dir" || mkdir -p "$dir"
+        OUTDIR="$outpath/$dir"
+        if [ -f "${OUTDIR}/Makefile" ] && [ "$OPT_FAST" = "yes" ]; then
+            # fast configure - the makefile exists, skip it
+            # since the makefile exists, it was generated by qmake, which means we
+            # can skip it, since qmake has a rule to regenerate the makefile if the .pro
+            # file changes...
+            [ "$OPT_VERBOSE" = "yes" ] && echo "  skipping $a"
+            continue;
+        fi
+        QMAKE_SPEC_ARGS="-spec $SPEC"
+        echo $ECHO_N "  for $a$ECHO_C"
+
+        QMAKE="$outpath/bin/qmake"
+	QMAKE_ARGS="$QMAKE_SWITCHES $QMAKE_SPEC_ARGS"
+        if [ "$file" = ".projects.3" ]; then
+            echo " (fast)"
+
+            cat >"${OUTDIR}/Makefile" <<EOF
+# ${OUTDIR}/Makefile: generated by configure
+#
+# WARNING: This makefile will be replaced with a real makefile.
+# All changes made to this file will be lost.
+EOF
+            [ "$CFG_DEBUG_RELEASE" = "no" ] && echo "first_target: first" >>${OUTDIR}/Makefile
+
+            cat >>"${OUTDIR}/Makefile" <<EOF
+QMAKE = "$QMAKE"
+all clean install qmake first Makefile: FORCE
+	\$(QMAKE) $QMAKE_ARGS -o "$OUTDIR" "$a"
+	cd "$OUTDIR"
+	\$(MAKE) \$@
+
+FORCE:
+
+EOF
+        else
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo " (`basename $SPEC`)"
+                echo "$QMAKE" $QMAKE_ARGS -o "$OUTDIR" "$a"
+	    else
+		echo
+            fi
+
+            [ -f "${OUTDIR}/Makefile" ] && chmod +w "${OUTDIR}/Makefile"
+            QTDIR="$outpath" "$QMAKE" $QMAKE_ARGS -o "$OUTDIR" "$a"
+       fi
+    done
+done
+rm -f .projects .projects.3
+
+#-------------------------------------------------------------------------------
+# check for platforms that we don't yet know about
+#-------------------------------------------------------------------------------
+if [ "$CFG_ARCH" = "generic" ]; then
+cat <<EOF
+
+        NOTICE: Atomic operations are not yet supported for this
+        architecture.
+
+        Qt will use the 'generic' architecture instead, which uses a
+        single pthread_mutex_t to protect all atomic operations. This
+        implementation is the slow (but safe) fallback implementation
+        for architectures Qt does not yet support.
+EOF
+fi
+
+#-------------------------------------------------------------------------------
+# check if the user passed the -no-zlib option, which is no longer supported
+#-------------------------------------------------------------------------------
+if [ -n "$ZLIB_FORCED" ]; then
+    which_zlib="supplied"
+    if [ "$CFG_ZLIB" = "system" ]; then
+	which_zlib="system"
+    fi
+
+cat <<EOF
+
+        NOTICE: The -no-zlib option was supplied but is no longer
+        supported.
+
+        Qt now requires zlib support in all builds, so the -no-zlib
+        option was ignored. Qt will be built using the $which_zlib
+        zlib.
+EOF
+fi
+
+#-------------------------------------------------------------------------------
+# finally save the executed command to another script
+#-------------------------------------------------------------------------------
+if [ `basename $0` != "config.status" ]; then
+    CONFIG_STATUS="$relpath/$relconf $OPT_CMDLINE"
+
+    # add the system variables
+    for varname in $SYSTEM_VARIABLES; do
+        cmd=`echo \
+'if [ -n "\$'${varname}'" ]; then
+    CONFIG_STATUS="'${varname}'='"'\\\$${varname}'"' \$CONFIG_STATUS"
+fi'`
+	eval "$cmd"
+    done
+
+    echo "$CONFIG_STATUS" | grep '\-confirm\-license' >/dev/null 2>&1 || CONFIG_STATUS="$CONFIG_STATUS -confirm-license"
+
+    [ -f "$outpath/config.status" ] && rm -f "$outpath/config.status"
+    echo "#!/bin/sh" > "$outpath/config.status"
+    echo "if [ \"\$#\" -gt 0 ]; then" >> "$outpath/config.status"
+    echo "  $CONFIG_STATUS \"\$@\"" >> "$outpath/config.status"
+    echo "else" >> "$outpath/config.status"
+    echo "  $CONFIG_STATUS" >> "$outpath/config.status"
+    echo "fi" >> "$outpath/config.status"
+    chmod +x "$outpath/config.status"
+fi
+
+if [ -n "$RPATH_MESSAGE" ]; then
+    echo
+    echo "$RPATH_MESSAGE"
+fi
+
+MAKE=`basename "$MAKE"`
+echo
+echo Qt is now configured for building. Just run \'$MAKE\'.
+if [ "$relpath" = "$QT_INSTALL_PREFIX" ]; then
+    echo Once everything is built, Qt is installed.
+    echo You should not run \'$MAKE install\'.
+else
+    echo Once everything is built, you must run \'$MAKE install\'.
+    echo Qt will be installed into $QT_INSTALL_PREFIX
+fi
+echo
+echo To reconfigure, run \'$MAKE confclean\' and \'configure\'.
+echo
--- a/examples/touch/fingerpaint/scribblearea.cpp
+++ b/examples/touch/fingerpaint/scribblearea.cpp
@@ -186,7 +186,9 @@
                     QRectF rect = touchPoint.rect();
                     if (rect.isEmpty()) {
                         qreal diameter = qreal(50) * touchPoint.pressure();
+                        QPointF center = rect.center();
                         rect.setSize(QSizeF(diameter, diameter));
+                        rect.moveCenter(center);
                     }
 
                     QPainter painter(&image);
--- a/src/gui/kernel/kernel.pri
+++ b/src/gui/kernel/kernel.pri
@@ -140,6 +140,7 @@
 unix:x11 {
 	INCLUDEPATH += ../3rdparty/xorg
 	HEADERS += \
+                kernel/qt_x11_p.h \
 		kernel/qx11embed_x11.h \
 		kernel/qx11info_x11.h \
         kernel/qkde_p.h
--- a/src/gui/kernel/qapplication_p.h
+++ b/src/gui/kernel/qapplication_p.h
@@ -638,6 +638,35 @@
     bool useTranslucentEGLSurfaces;
 #endif
 
+#if defined(Q_WS_X11) && !defined(QT_NO_XINPUT2)
+    struct TouchDeviceInfo {
+        int deviceid;
+        int maxTouches;
+        bool directTouch;
+        int numValuators;
+        struct Valuator {
+            int number;
+            unsigned long label; // Atom
+            qreal min;
+            qreal max;
+            quint32 resolution;
+        };
+        Valuator xivPosX;
+        Valuator xivPosY;
+        Valuator xivTouchMajor;
+        Valuator xivTouchMinor;
+        Valuator xivOrientation;
+    };
+    QHash<int, TouchDeviceInfo> touchDevices;
+    QList<QTouchEvent::TouchPoint> appTouchPoints;
+    QTouchEvent::DeviceType activeDeviceType;
+    QMap<int, QPointF> touchedPos; // initial value of X and Y valuators for indirect touch
+    QMap<int, QSizeF> touchedSize; // major => height, minor => width
+    QMap<int, qreal> touchedOrientation; // -1 => point to left, 0 => point up, 1 => point to right
+    QTouchEvent::TouchPoint unsentAppTouchPoint; // sequence that was not delivered to a widget yet
+    void x11GetTouchDeviceInfo();
+#endif
+
 private:
 #ifdef Q_WS_QWS
     QMap<const QScreen*, QRect> maxWindowRects;
--- a/src/gui/kernel/qapplication_x11.cpp
+++ b/src/gui/kernel/qapplication_x11.cpp
@@ -86,6 +86,7 @@
 #include <private/qgraphicssystemfactory_p.h>
 #include "qguiplatformplugin_p.h"
 #include "qkde_p.h"
+#include "qmath.h"
 
 #if !defined (QT_NO_TABLET)
 extern "C" {
@@ -125,9 +126,6 @@
 
 #define XK_MISCELLANY
 #include <X11/keysymdef.h>
-#if !defined(QT_NO_XINPUT)
-#include <X11/extensions/XI.h>
-#endif
 
 #include <stdlib.h>
 #include <string.h>
@@ -326,6 +324,13 @@
     // Tablet
     "STYLUS\0"
     "ERASER\0"
+
+    // XInput 2.1 touch
+    "Abs MT Touch Major\0"
+    "Abs MT Touch Minor\0"
+    "Abs MT Orientation\0"
+    "Abs MT Position X\0"
+    "Abs MT Position Y\0"
 };
 
 Q_GUI_EXPORT QX11Data *qt_x11Data = 0;
@@ -576,6 +581,10 @@
 #endif
     bool translatePropertyEvent(const XEvent *);
 
+#if !defined(QT_NO_XINPUT2)
+    bool translateXI2Event(const XIEvent *);
+#endif
+
     void doDeferredMap()
     {
         Q_ASSERT(testAttribute(Qt::WA_WState_Created));
@@ -698,7 +707,7 @@
 
     default:
 #if !defined(QT_NO_XINPUT)
-        if (err->request_code == X11->xinput_major
+        if (err->request_code == X11->xinput_opcode
             && err->error_code == (X11->xinput_errorbase + XI_BadDevice)
             && err->minor_code == 3 /* X_OpenDevice */) {
             return 0;
@@ -729,7 +738,7 @@
             extensionName = "RENDER";
         else if (err->request_code == X11->xrandr_major)
             extensionName = "RANDR";
-        else if (err->request_code == X11->xinput_major)
+        else if (err->request_code == X11->xinput_opcode)
             extensionName = "XInputExtension";
         else if (err->request_code == X11->mitshm_major)
             extensionName = "MIT-SHM";
@@ -1687,9 +1696,14 @@
 
     // XInputExtension
     X11->use_xinput = false;
-    X11->xinput_major = 0;
+    X11->use_xinput2 = false;
+    X11->xinput_opcode = 0;
     X11->xinput_eventbase = 0;
     X11->xinput_errorbase = 0;
+#if !defined(QT_NO_XINPUT2)
+    X11->xideviceinfo = 0;
+    X11->xitouchclassinfo = 0;
+#endif
 
     X11->use_xkb = false;
     X11->xkb_major = 0;
@@ -2152,14 +2166,26 @@
 #endif // QT_RUNTIME_XINERAMA
 #endif // QT_NO_XINERAMA
 
-#ifndef QT_NO_XINPUT
+#if !defined(QT_NO_XINPUT2)
+        X11->use_xinput2 = XQueryExtension(X11->display, "XInputExtension", &X11->xinput_opcode,
+                                          &X11->xinput_eventbase, &X11->xinput_errorbase);
+        if (X11->use_xinput2) {
+            // we want XInput2
+            int ximajor = 2, ximinor = 1;
+            if (XIQueryVersion(X11->display, &ximajor, &ximinor) == BadRequest) {
+                // XInput2 not available
+                X11->use_xinput2 = false;
+            }
+        }
+#endif
+#if !defined(QT_NO_XINPUT)
         // See if Xinput is supported on the connected display
         X11->ptrXCloseDevice = 0;
         X11->ptrXListInputDevices = 0;
         X11->ptrXOpenDevice = 0;
         X11->ptrXFreeDeviceList = 0;
         X11->ptrXSelectExtensionEvent = 0;
-        X11->use_xinput = XQueryExtension(X11->display, "XInputExtension", &X11->xinput_major,
+        X11->use_xinput = XQueryExtension(X11->display, "XInputExtension", &X11->xinput_opcode,
                                           &X11->xinput_eventbase, &X11->xinput_errorbase);
         if (X11->use_xinput) {
             X11->ptrXCloseDevice = XINPUT_LOAD(XCloseDevice);
@@ -3223,6 +3249,10 @@
     Q_D(QApplication);
     QScopedLoopLevelCounter loopLevelCounter(d->threadData);
 
+#if !defined(QT_NO_XINPUT2)
+    bool isXI2Event = false;
+#endif
+
 #ifdef ALIEN_DEBUG
     //qDebug() << "QApplication::x11ProcessEvent:" << event->type;
 #endif
@@ -3253,6 +3283,16 @@
     case SelectionClear:
         X11->time = event->xselectionclear.time;
         break;
+#if !defined(QT_NO_XINPUT2)
+    case GenericEvent:
+        if (X11->use_xinput2
+                && XGetEventData(X11->display, &event->xcookie)
+                && event->xcookie.extension == X11->xinput_opcode) {
+            // remember for later
+            isXI2Event = true;
+        }
+        break;
+#endif
     default:
         break;
     }
@@ -3266,7 +3306,43 @@
     }
 #endif
 
-    QETWidget *widget = (QETWidget*)QWidget::find((WId)event->xany.window);
+    QETWidget *widget = 0;
+#if !defined(QT_NO_XINPUT2)
+    if (isXI2Event) {
+        // event->xany.window is not usable for these events
+        // look up widget based on the type of event we received
+        switch (event->xcookie.evtype) {
+        case XI_TouchBegin:
+        case XI_TouchEnd:
+        case XI_TouchUpdate:
+            // all of these events send XIDeviceEvents
+            widget = (QETWidget *) QWidget::find(((XIDeviceEvent *) event->xcookie.data)->event);
+            break;
+        default:
+            break;
+        }
+    } else
+#endif // !defined(QT_NO_XINPUT2)
+    {
+        widget = (QETWidget*)QWidget::find((WId)event->xany.window);
+    }
+
+#if !defined(QT_NO_XINPUT2)
+    // make sure XFreeEventData() is called at every return point
+    class CallXFreeEventData
+    {
+        Display *display;
+        XGenericEventCookie *cookie;
+    public:
+        CallXFreeEventData(Display *display, XGenericEventCookie *cookie)
+            : display(display), cookie(cookie)
+        { }
+        ~CallXFreeEventData()
+        {
+            XFreeEventData(display, cookie);
+        }
+    } instance(X11->display, &event->xcookie);
+#endif
 
     if (wPRmapper) {                                // just did a widget reparent?
         if (widget == 0) {                        // not in std widget mapper
@@ -3278,6 +3354,15 @@
             case XKeyRelease:
                 widget = qPRFindWidget(event->xany.window);
                 break;
+#if !defined(QT_NO_XINPUT2)
+            case GenericEvent:
+                // as above, event->xany.window is unusable for these events
+                if (isXI2Event) {
+                    widget = qPRFindWidget(((XIDeviceEvent *) event->xcookie.data)->event);
+                    break;
+                }
+                break;
+#endif
             }
         }
         else if (widget->testAttribute(Qt::WA_WState_Reparented))
@@ -3912,6 +3997,13 @@
         }
         break;
 
+#if !defined(QT_NO_XINPUT2)
+    case GenericEvent:
+        if (isXI2Event)
+            widget->translateXI2Event((XIEvent *)event->xcookie.data);
+        break;
+#endif
+
     default:
         break;
     }
@@ -5143,6 +5235,191 @@
     return true;
 }
 
+#if !defined(QT_NO_XINPUT2)
+bool QETWidget::translateXI2Event(const XIEvent *event)
+{
+    const XIDeviceEvent *dev = (const XIDeviceEvent *)event;
+    QApplicationPrivate *qAppPriv = QApplicationPrivate::instance();
+    const QApplicationPrivate::TouchDeviceInfo &tdi = qAppPriv->touchDevices[dev->sourceid];
+    const int trackingId = dev->detail;
+    QTouchEvent::TouchPoint *tp = 0;
+    Qt::TouchPointStates primary = Qt::TouchPointPrimary;
+
+    if (!(dev->flags & XIPointerEmulated))
+        primary = (Qt::TouchPointStates)0;
+
+    switch (event->evtype) {
+    case XI_TouchBegin: {
+        Q_ASSERT(qAppPriv->touchDevices.contains(dev->sourceid));
+
+        QWidget *w = childAt(QPoint(dev->event_x, dev->event_y));
+        if (!w)
+            return false;
+
+        if (tdi.directTouch) {
+            qAppPriv->appTouchPoints.append(QTouchEvent::TouchPoint(trackingId));
+            tp = &qAppPriv->appTouchPoints.last();
+        } else {
+            // touch pad
+            if (qAppPriv->appTouchPoints.isEmpty()) {
+                if (!w->testAttribute(Qt::WA_TouchPadAcceptSingleTouchEvents)) {
+                    if (qAppPriv->unsentAppTouchPoint.id() == -1) {
+                        // do not send first TouchBegin from touchpad to a widget
+                        qAppPriv->unsentAppTouchPoint = QTouchEvent::TouchPoint(trackingId);
+                        tp = &qAppPriv->unsentAppTouchPoint;
+                    } else {
+                        // second touch on a touchpad
+                        qAppPriv->unsentAppTouchPoint.setState(Qt::TouchPointPressed | primary);
+                        qAppPriv->appTouchPoints.append(qAppPriv->unsentAppTouchPoint);
+                        qAppPriv->unsentAppTouchPoint = QTouchEvent::TouchPoint();
+                    }
+                }
+            }
+        }
+        if (!tp) {
+            qAppPriv->appTouchPoints.append(QTouchEvent::TouchPoint(trackingId));
+            tp = &qAppPriv->appTouchPoints.last();
+        }
+        break;
+    }
+
+    case XI_TouchEnd:
+    case XI_TouchUpdate: {
+        Q_ASSERT(qAppPriv->touchDevices.contains(dev->sourceid));
+
+        // find the touchpoint
+        for (int i = 0; i < qAppPriv->appTouchPoints.size(); ++i) {
+            QTouchEvent::TouchPoint &touchPoint = qAppPriv->appTouchPoints[i];
+            if (touchPoint.id() == trackingId)
+                tp = &touchPoint;
+            else
+                touchPoint.setState(Qt::TouchPointStationary | primary);
+        }
+        if (!tp && qAppPriv->unsentAppTouchPoint.id() == trackingId)
+            tp = &qAppPriv->unsentAppTouchPoint;
+        if (!tp) {
+            qWarning("Got touch without getting TouchBegin for id %d", trackingId);
+            return false;
+        }
+        break;
+    }
+    default:
+        qWarning() << "translateXI2Event: unknown XI2 event:" << event->evtype;
+        return false;
+    }
+
+    double *values = dev->valuators.values;
+    for (int i = 0; i < qMin(dev->valuators.mask_len * 8, tdi.numValuators); ++i) {
+        if (XIMaskIsSet(dev->valuators.mask, i)) {
+            if (tdi.xivPosX.number == i) {
+                qreal value = (*values++ - tdi.xivPosX.min) / (tdi.xivPosX.max - tdi.xivPosX.min);
+                qreal screenValue;
+                if (tdi.directTouch) {
+                    screenValue = dev->root_x;
+                } else {
+                    if (qAppPriv->appTouchPoints.size() > 1) {
+                        // non-first touch point, make it relative to the first one
+                        const int firstId = qAppPriv->appTouchPoints.first().id();
+                        screenValue = dev->root_x + (value - qAppPriv->touchedPos[firstId].x()) * 300;
+                        if (event->evtype == XI_TouchBegin)
+                            qAppPriv->touchedPos[trackingId].rx() = qAppPriv->touchedPos[firstId].x();
+                    } else {
+                        screenValue = dev->root_x;
+                        if (event->evtype == XI_TouchBegin)
+                            qAppPriv->touchedPos[trackingId].rx() = value;
+                    }
+                }
+                tp->d->screenRect.moveCenter(QPointF(screenValue, tp->d->screenRect.center().y()));
+                tp->d->normalizedPos.setX(value);
+            } else if (tdi.xivPosY.number == i) {
+                qreal value = (*values++ - tdi.xivPosY.min) / (tdi.xivPosY.max - tdi.xivPosY.min);
+                qreal screenValue;
+                if (tdi.directTouch) {
+                    screenValue = dev->root_y;
+                } else {
+                    if (qAppPriv->appTouchPoints.size() > 1) {
+                        // non-first touch point, make it relative to the first one
+                        const int firstId = qAppPriv->appTouchPoints.first().id();
+                        screenValue = dev->root_y + (value - qAppPriv->touchedPos[firstId].y()) * 300;
+                        if (event->evtype == XI_TouchBegin)
+                            qAppPriv->touchedPos[trackingId].ry() = qAppPriv->touchedPos[firstId].y();
+                    } else {
+                        screenValue = dev->root_y;
+                        if (event->evtype == XI_TouchBegin)
+                            qAppPriv->touchedPos[trackingId].ry() = value;
+                    }
+                }
+                tp->d->screenRect.moveCenter(QPointF(tp->d->screenRect.center().x(), screenValue));
+                tp->d->normalizedPos.setY(value);
+            } else if (tdi.xivTouchMajor.number == i) {
+                qreal value = (*values++ - tdi.xivTouchMajor.min) / (tdi.xivTouchMajor.max - tdi.xivTouchMajor.min);
+                qAppPriv->touchedSize[trackingId].rheight() = value;
+            } else if (tdi.xivTouchMinor.number == i) {
+                qreal value = (*values++ - tdi.xivTouchMinor.min) / (tdi.xivTouchMinor.max - tdi.xivTouchMinor.min);
+                qAppPriv->touchedSize[trackingId].rwidth() = value;
+            } else if (tdi.xivOrientation.number == i) {
+                qreal value = (*values++ - tdi.xivOrientation.min) / (tdi.xivOrientation.max - tdi.xivOrientation.min);
+                qAppPriv->touchedOrientation[trackingId] = value * M_PI_2;
+            } else
+                ++values;
+        }
+    }
+
+    qreal angle = qAppPriv->touchedOrientation[trackingId];
+    qreal width = qAppPriv->touchedSize[trackingId].height() * qFabs(qFastSin(angle)) +
+                  qAppPriv->touchedSize[trackingId].width() * qFabs(qFastCos(angle));
+    qreal height = qAppPriv->touchedSize[trackingId].width() * qFabs(qFastSin(angle)) +
+                   qAppPriv->touchedSize[trackingId].height() * qFabs(qFastCos(angle));
+    width *= tdi.directTouch ? 500 : 25;
+    height *= tdi.directTouch ? 500 : 25;
+    QPointF center = tp->d->screenRect.center();
+    tp->d->screenRect = QRectF(center.x() - width/2, center.y() - height/2, width, height);
+
+    bool send = true;
+    QList<QTouchEvent::TouchPoint> oldTouchPoints;
+    if (event->evtype == XI_TouchBegin) {
+        tp->setState(Qt::TouchPointPressed | primary);
+        if (qAppPriv->appTouchPoints.isEmpty())
+            send = false;
+    } else if (event->evtype == XI_TouchUpdate) {
+        tp->setState(Qt::TouchPointMoved | primary);
+        QWidget *w = childAt(QPoint(dev->event_x, dev->event_y));
+        if (!w || (!tdi.directTouch && qAppPriv->appTouchPoints.size() == 1 && !w->testAttribute(Qt::WA_TouchPadAcceptSingleTouchEvents)))
+            send = false;
+    } else if (event->evtype == XI_TouchEnd) {
+        oldTouchPoints = qAppPriv->appTouchPoints;
+        for (int i = 0; i < qAppPriv->appTouchPoints.size(); ++i) {
+            if (qAppPriv->appTouchPoints[i].id() == trackingId) {
+                qAppPriv->appTouchPoints.removeAt(i);
+                break;
+            }
+        }
+
+        tp->setState(Qt::TouchPointReleased | primary);
+
+        if (oldTouchPoints.isEmpty())
+            send = false;
+
+        if (qAppPriv->unsentAppTouchPoint.id() == trackingId)
+            qAppPriv->unsentAppTouchPoint = QTouchEvent::TouchPoint();
+        if (qAppPriv->appTouchPoints.isEmpty()) {
+            qAppPriv->touchedPos.clear();
+            qAppPriv->touchedSize.clear();
+            qAppPriv->touchedOrientation.clear();
+        }
+    }
+
+    if (send) {
+        qAppPriv->activeDeviceType = tdi.directTouch ? QTouchEvent::TouchScreen : QTouchEvent::TouchPad;
+        if (event->evtype != XI_TouchEnd)
+            QApplicationPrivate::translateRawTouchEvent(0, qAppPriv->activeDeviceType, qAppPriv->appTouchPoints);
+        else
+            QApplicationPrivate::translateRawTouchEvent(0, qAppPriv->activeDeviceType, oldTouchPoints);
+    }
+
+    return true;
+}
+#endif
 
 //
 // Paint event translation
@@ -6276,11 +6553,77 @@
 
 #else // !QT_RX71_MULTITOUCH
 
+#if !defined(QT_NO_XINPUT2)
+static inline void copy(QApplicationPrivate::TouchDeviceInfo::Valuator &dst,
+                        const XIValuatorClassInfo &src)
+{
+    dst.number = src.number;
+    dst.label = src.label;
+    dst.min = src.min;
+    dst.max = src.max;
+    dst.resolution = src.resolution;
+}
+
+void QApplicationPrivate::x11GetTouchDeviceInfo()
+{
+    int count = 0;
+    XIDeviceInfo *devices = XIQueryDevice(X11->display, XIAllDevices, &count);
+    if (devices) {
+        for (int i = 0; i < count; ++i) {
+            if (!devices[i].enabled)
+                continue;
+
+            bool is_touch = false;
+            QApplicationPrivate::TouchDeviceInfo tdi;
+
+            for (int k = 0; k < devices[i].num_classes; ++k) {
+                XIAnyClassInfo *xiclassinfo = devices[i].classes[k];
+                if (xiclassinfo->type == XITouchClass) {
+                    is_touch = true;
+                    XITouchClassInfo *t = (XITouchClassInfo *)xiclassinfo;
+                    tdi.deviceid = devices[i].deviceid;
+                    tdi.directTouch = t->mode == XIDirectTouch;
+                    tdi.maxTouches = t->num_touches;
+                } else if (xiclassinfo->type == XIValuatorClass) {
+                    XIValuatorClassInfo *v = (XIValuatorClassInfo *)xiclassinfo;
+                    tdi.numValuators++;
+                    if (v->label == ATOM(XAbsMTTouchMajor))
+                        copy(tdi.xivTouchMajor, *v);
+                    else if (v->label == ATOM(XAbsMTTouchMinor))
+                        copy(tdi.xivTouchMinor, *v);
+                    else if (v->label == ATOM(XAbsMTOrientation))
+                        copy(tdi.xivOrientation, *v);
+                    else if (v->label == ATOM(XAbsMTPositionX))
+                        copy(tdi.xivPosX, *v);
+                    else if (v->label == ATOM(XAbsMTPositionY))
+                        copy(tdi.xivPosY, *v);
+                }
+            }
+
+            if (is_touch)
+                touchDevices[devices[i].deviceid] = tdi;
+        }
+        XIFreeDeviceInfo(devices);
+    }
+}
+
+void QApplicationPrivate::initializeMultitouch_sys()
+{
+    x11GetTouchDeviceInfo();
+}
+void QApplicationPrivate::cleanupMultitouch_sys()
+{
+}
+
+#else
+
 void QApplicationPrivate::initializeMultitouch_sys()
 { }
 void QApplicationPrivate::cleanupMultitouch_sys()
 { }
 
+#endif
+
 #endif // QT_RX71_MULTITOUCH
 
 QT_END_NAMESPACE
--- a/src/gui/kernel/qapplication_x11.cpp.orig
+++ b/src/gui/kernel/qapplication_x11.cpp.orig
@@ -0,0 +1,6291 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// ### 4.0: examine Q_EXPORT's below. The respective symbols had all
+// been in use (e.g. in the KDE wm) before the introduction of a version
+// map. One might want to turn some of them into proper public API and
+// provide a proper alternative for others. See also the exports in
+// qapplication_win.cpp, which suggest a unification.
+
+#include "qplatformdefs.h"
+
+#include "qcolormap.h"
+#include "qdesktopwidget.h"
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qcursor.h"
+#include "qwidget.h"
+#include "qbitarray.h"
+#include "qpainter.h"
+#include "qfile.h"
+#include "qpixmapcache.h"
+#include "qdatetime.h"
+#include "qtextcodec.h"
+#include "qdatastream.h"
+#include "qbuffer.h"
+#include "qsocketnotifier.h"
+#include "qsessionmanager.h"
+#include "qclipboard.h"
+#include "qwhatsthis.h"
+#include "qsettings.h"
+#include "qstylefactory.h"
+#include "qfileinfo.h"
+#include "qdir.h"
+#include "qhash.h"
+#include "qevent.h"
+#include "qevent_p.h"
+#include "qvarlengtharray.h"
+#include "qdebug.h"
+#include <private/qcrashhandler_p.h>
+#include <private/qcolor_p.h>
+#include <private/qcursor_p.h>
+#include <private/qiconloader_p.h>
+#include <qgtkstyle.h>
+#include "qstyle.h"
+#include "qmetaobject.h"
+#include "qtimer.h"
+#include "qlibrary.h"
+#include <private/qgraphicssystemfactory_p.h>
+#include "qguiplatformplugin_p.h"
+#include "qkde_p.h"
+#include "qmath.h"
+
+#if !defined (QT_NO_TABLET)
+extern "C" {
+#   define class c_class  //XIproto.h has a name member named 'class' which the c++ compiler doesn't like
+#   include <wacomcfg.h>
+#   undef class
+}
+#endif
+
+#ifndef QT_GUI_DOUBLE_CLICK_RADIUS
+#define QT_GUI_DOUBLE_CLICK_RADIUS 5
+#endif
+
+
+//#define ALIEN_DEBUG
+
+#if !defined(QT_NO_GLIB)
+#  include "qguieventdispatcher_glib_p.h"
+#endif
+#include "qeventdispatcher_x11_p.h"
+#include <private/qpaintengine_x11_p.h>
+
+#include <private/qkeymapper_p.h>
+
+// Input method stuff
+#ifndef QT_NO_IM
+#include "qinputcontext.h"
+#include "qinputcontextfactory.h"
+#endif // QT_NO_IM
+
+#ifndef QT_NO_XFIXES
+#include <X11/extensions/Xfixes.h>
+#endif // QT_NO_XFIXES
+
+#include "qt_x11_p.h"
+#include "qx11info_x11.h"
+
+#define XK_MISCELLANY
+#include <X11/keysymdef.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <locale.h>
+
+#include "qwidget_p.h"
+
+#include <private/qbackingstore_p.h>
+
+#ifdef QT_RX71_MULTITOUCH
+#  include <qsocketnotifier.h>
+#  include <linux/input.h>
+#  include <errno.h>
+#endif
+
+#if _POSIX_VERSION+0 < 200112L && !defined(Q_OS_BSD4)
+# define QT_NO_UNSETENV
+#endif
+
+QT_BEGIN_NAMESPACE
+
+//#define X_NOT_BROKEN
+#ifdef X_NOT_BROKEN
+// Some X libraries are built with setlocale #defined to _Xsetlocale,
+// even though library users are then built WITHOUT such a definition.
+// This creates a problem - Qt might setlocale() one value, but then
+// X looks and doesn't see the value Qt set. The solution here is to
+// implement _Xsetlocale just in case X calls it - redirecting it to
+// the real libC version.
+//
+# ifndef setlocale
+extern "C" char *_Xsetlocale(int category, const char *locale);
+char *_Xsetlocale(int category, const char *locale)
+{
+    //qDebug("_Xsetlocale(%d,%s),category,locale");
+    return setlocale(category,locale);
+}
+# endif // setlocale
+#endif // X_NOT_BROKEN
+
+/* Warning: if you modify this string, modify the list of atoms in qt_x11_p.h as well! */
+static const char * x11_atomnames = {
+    // window-manager <-> client protocols
+    "WM_PROTOCOLS\0"
+    "WM_DELETE_WINDOW\0"
+    "WM_TAKE_FOCUS\0"
+    "_NET_WM_PING\0"
+    "_NET_WM_CONTEXT_HELP\0"
+    "_NET_WM_SYNC_REQUEST\0"
+    "_NET_WM_SYNC_REQUEST_COUNTER\0"
+
+    // ICCCM window state
+    "WM_STATE\0"
+    "WM_CHANGE_STATE\0"
+
+    // Session management
+    "WM_CLIENT_LEADER\0"
+    "WM_WINDOW_ROLE\0"
+    "SM_CLIENT_ID\0"
+
+    // Clipboard
+    "CLIPBOARD\0"
+    "INCR\0"
+    "TARGETS\0"
+    "MULTIPLE\0"
+    "TIMESTAMP\0"
+    "SAVE_TARGETS\0"
+    "CLIP_TEMPORARY\0"
+    "_QT_SELECTION\0"
+    "_QT_CLIPBOARD_SENTINEL\0"
+    "_QT_SELECTION_SENTINEL\0"
+    "CLIPBOARD_MANAGER\0"
+
+    "RESOURCE_MANAGER\0"
+
+    "_XSETROOT_ID\0"
+
+    "_QT_SCROLL_DONE\0"
+    "_QT_INPUT_ENCODING\0"
+
+    "_MOTIF_WM_HINTS\0"
+
+    "DTWM_IS_RUNNING\0"
+    "ENLIGHTENMENT_DESKTOP\0"
+    "_DT_SAVE_MODE\0"
+    "_SGI_DESKS_MANAGER\0"
+
+    // EWMH (aka NETWM)
+    "_NET_SUPPORTED\0"
+    "_NET_VIRTUAL_ROOTS\0"
+    "_NET_WORKAREA\0"
+
+    "_NET_MOVERESIZE_WINDOW\0"
+    "_NET_WM_MOVERESIZE\0"
+
+    "_NET_WM_NAME\0"
+    "_NET_WM_ICON_NAME\0"
+    "_NET_WM_ICON\0"
+
+    "_NET_WM_PID\0"
+
+    "_NET_WM_WINDOW_OPACITY\0"
+
+    "_NET_WM_STATE\0"
+    "_NET_WM_STATE_ABOVE\0"
+    "_NET_WM_STATE_BELOW\0"
+    "_NET_WM_STATE_FULLSCREEN\0"
+    "_NET_WM_STATE_MAXIMIZED_HORZ\0"
+    "_NET_WM_STATE_MAXIMIZED_VERT\0"
+    "_NET_WM_STATE_MODAL\0"
+    "_NET_WM_STATE_STAYS_ON_TOP\0"
+    "_NET_WM_STATE_DEMANDS_ATTENTION\0"
+
+    "_NET_WM_USER_TIME\0"
+    "_NET_WM_USER_TIME_WINDOW\0"
+    "_NET_WM_FULL_PLACEMENT\0"
+
+    "_NET_WM_WINDOW_TYPE\0"
+    "_NET_WM_WINDOW_TYPE_DESKTOP\0"
+    "_NET_WM_WINDOW_TYPE_DOCK\0"
+    "_NET_WM_WINDOW_TYPE_TOOLBAR\0"
+    "_NET_WM_WINDOW_TYPE_MENU\0"
+    "_NET_WM_WINDOW_TYPE_UTILITY\0"
+    "_NET_WM_WINDOW_TYPE_SPLASH\0"
+    "_NET_WM_WINDOW_TYPE_DIALOG\0"
+    "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\0"
+    "_NET_WM_WINDOW_TYPE_POPUP_MENU\0"
+    "_NET_WM_WINDOW_TYPE_TOOLTIP\0"
+    "_NET_WM_WINDOW_TYPE_NOTIFICATION\0"
+    "_NET_WM_WINDOW_TYPE_COMBO\0"
+    "_NET_WM_WINDOW_TYPE_DND\0"
+    "_NET_WM_WINDOW_TYPE_NORMAL\0"
+    "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
+
+    "_KDE_NET_WM_FRAME_STRUT\0"
+
+    "_NET_STARTUP_INFO\0"
+    "_NET_STARTUP_INFO_BEGIN\0"
+
+    "_NET_SUPPORTING_WM_CHECK\0"
+
+    "_NET_WM_CM_S0\0"
+
+    "_NET_SYSTEM_TRAY_VISUAL\0"
+
+    "_NET_ACTIVE_WINDOW\0"
+
+    // Property formats
+    "COMPOUND_TEXT\0"
+    "TEXT\0"
+    "UTF8_STRING\0"
+
+    // xdnd
+    "XdndEnter\0"
+    "XdndPosition\0"
+    "XdndStatus\0"
+    "XdndLeave\0"
+    "XdndDrop\0"
+    "XdndFinished\0"
+    "XdndTypeList\0"
+    "XdndActionList\0"
+
+    "XdndSelection\0"
+
+    "XdndAware\0"
+    "XdndProxy\0"
+
+    "XdndActionCopy\0"
+    "XdndActionLink\0"
+    "XdndActionMove\0"
+    "XdndActionPrivate\0"
+
+    // Motif DND
+    "_MOTIF_DRAG_AND_DROP_MESSAGE\0"
+    "_MOTIF_DRAG_INITIATOR_INFO\0"
+    "_MOTIF_DRAG_RECEIVER_INFO\0"
+    "_MOTIF_DRAG_WINDOW\0"
+    "_MOTIF_DRAG_TARGETS\0"
+
+    "XmTRANSFER_SUCCESS\0"
+    "XmTRANSFER_FAILURE\0"
+
+    // Xkb
+    "_XKB_RULES_NAMES\0"
+
+    // XEMBED
+    "_XEMBED\0"
+    "_XEMBED_INFO\0"
+
+    // Wacom old. (before version 0.10)
+    "Wacom Stylus\0"
+    "Wacom Cursor\0"
+    "Wacom Eraser\0"
+
+    // Tablet
+    "STYLUS\0"
+    "ERASER\0"
+
+    // XInput 2.1 touch
+    "Abs MT Touch Major\0"
+    "Abs MT Touch Minor\0"
+    "Abs MT Orientation\0"
+    "Abs MT Position X\0"
+    "Abs MT Position Y\0"
+};
+
+Q_GUI_EXPORT QX11Data *qt_x11Data = 0;
+
+/*****************************************************************************
+  Internal variables and functions
+ *****************************************************************************/
+static const char *appName = 0;                        // application name
+static const char *appClass = 0;                        // application class
+static const char *appFont        = 0;                // application font
+static const char *appBGCol        = 0;                // application bg color
+static const char *appFGCol        = 0;                // application fg color
+static const char *appBTNCol        = 0;                // application btn color
+static const char *mwGeometry        = 0;                // main widget geometry
+static const char *mwTitle        = 0;                // main widget title
+char    *qt_ximServer        = 0;                // XIM Server will connect to
+static bool        appSync                = false;        // X11 synchronization
+#if defined(QT_DEBUG)
+static bool        appNoGrab        = false;        // X11 grabbing enabled
+static bool        appDoGrab        = false;        // X11 grabbing override (gdb)
+#endif
+static bool        app_save_rootinfo = false;        // save root info
+static bool        app_do_modal        = false;        // modal mode
+static Window        curWin = 0;                        // current window
+
+
+// function to update the workarea of the screen - in qdesktopwidget_x11.cpp
+extern void qt_desktopwidget_update_workarea();
+
+// Function to change the window manager state (from qwidget_x11.cpp)
+extern void qt_change_net_wm_state(const QWidget *w, bool set, Atom one, Atom two = 0);
+
+// modifier masks for alt, meta, super, hyper, and mode_switch - detected when the application starts
+// and/or keyboard layout changes
+uchar qt_alt_mask = 0;
+uchar qt_meta_mask = 0;
+uchar qt_super_mask = 0;
+uchar qt_hyper_mask = 0;
+uchar qt_mode_switch_mask = 0;
+
+// flags for extensions for special Languages, currently only for RTL languages
+bool         qt_use_rtl_extensions = false;
+
+static Window        mouseActWindow             = 0;        // window where mouse is
+static Qt::MouseButton  mouseButtonPressed   = Qt::NoButton; // last mouse button pressed
+static Qt::MouseButtons mouseButtonState     = Qt::NoButton; // mouse button state
+static Time        mouseButtonPressTime = 0;        // when was a button pressed
+static short        mouseXPos, mouseYPos;                // mouse pres position in act window
+static short        mouseGlobalXPos, mouseGlobalYPos; // global mouse press position
+
+extern QWidgetList *qt_modal_stack;                // stack of modal widgets
+
+// window where mouse buttons have been pressed
+static Window pressed_window = XNone;
+
+// popup control
+static bool replayPopupMouseEvent = false;
+static bool popupGrabOk;
+
+bool qt_sm_blockUserInput = false;                // session management
+
+Q_GUI_EXPORT int qt_xfocusout_grab_counter = 0;
+
+#if !defined (QT_NO_TABLET)
+Q_GLOBAL_STATIC(QTabletDeviceDataList, tablet_devices)
+QTabletDeviceDataList *qt_tablet_devices()
+{
+    return tablet_devices();
+}
+
+extern bool qt_tabletChokeMouse;
+#endif
+
+typedef bool(*QX11FilterFunction)(XEvent *event);
+
+Q_GLOBAL_STATIC(QList<QX11FilterFunction>, x11Filters)
+
+Q_GUI_EXPORT void qt_installX11EventFilter(QX11FilterFunction func)
+{
+    Q_ASSERT(func);
+
+    if (QList<QX11FilterFunction> *list = x11Filters())
+        list->append(func);
+}
+
+Q_GUI_EXPORT void qt_removeX11EventFilter(QX11FilterFunction func)
+{
+    Q_ASSERT(func);
+
+    if (QList<QX11FilterFunction> *list = x11Filters())
+        list->removeOne(func);
+}
+
+
+static bool qt_x11EventFilter(XEvent* ev)
+{
+    long unused;
+    if (qApp->filterEvent(ev, &unused))
+        return true;
+    if (const QList<QX11FilterFunction> *list = x11Filters()) {
+        for (QList<QX11FilterFunction>::const_iterator it = list->constBegin(); it != list->constEnd(); ++it) {
+            if ((*it)(ev))
+                return true;
+        }
+    }
+
+    return qApp->x11EventFilter(ev);
+}
+
+#if !defined(QT_NO_XIM)
+XIMStyle        qt_xim_preferred_style = 0;
+#endif
+int qt_ximComposingKeycode=0;
+QTextCodec * qt_input_mapper = 0;
+
+extern bool qt_check_clipboard_sentinel(); //def in qclipboard_x11.cpp
+extern bool qt_check_selection_sentinel(); //def in qclipboard_x11.cpp
+extern bool qt_xfixes_clipboard_changed(Window clipboardOwner, Time timestamp); //def in qclipboard_x11.cpp
+extern bool qt_xfixes_selection_changed(Window selectionOwner, Time timestamp); //def in qclipboard_x11.cpp
+
+static void        qt_save_rootinfo();
+Q_GUI_EXPORT bool qt_try_modal(QWidget *, XEvent *);
+
+QWidget *qt_button_down = 0; // last widget to be pressed with the mouse
+QPointer<QWidget> qt_last_mouse_receiver = 0;
+static QWidget *qt_popup_down = 0;  // popup that contains the pressed widget
+
+extern bool qt_xdnd_dragging;
+
+// gui or non-gui from qapplication.cpp
+extern bool qt_is_gui_used;
+
+/*!
+    \internal
+    Try to resolve a \a symbol from \a library with the version specified
+    by \a vernum.
+
+    Note that, in the case of the Xfixes library, \a vernum is not the same as
+    \c XFIXES_MAJOR - it is a part of soname and may differ from the Xfixes
+    version.
+*/
+static void* qt_load_library_runtime(const char *library, int vernum,
+                                     int highestVernum, const char *symbol)
+{
+    QList<int> versions;
+    // we try to load in the following order:
+    // explicit version -> the default one -> (from the highest (highestVernum) to the lowest (vernum) )
+    if (vernum != -1)
+        versions << vernum;
+    versions << -1;
+    if (vernum != -1) {
+        for(int i = highestVernum; i > vernum; --i)
+            versions << i;
+    }
+    Q_FOREACH(int version, versions) {
+        QLatin1String libName(library);
+        QLibrary xfixesLib(libName, version);
+        xfixesLib.setLoadHints(QLibrary::ImprovedSearchHeuristics);
+        void *ptr = xfixesLib.resolve(symbol);
+        if (ptr)
+            return ptr;
+    }
+    return 0;
+}
+
+#ifndef QT_NO_XINPUT
+# ifdef QT_RUNTIME_XINPUT
+#  define XINPUT_LOAD_RUNTIME(vernum, symbol, symbol_type) \
+    (symbol_type)qt_load_library_runtime("libXi", vernum, 6, #symbol);
+#  define XINPUT_LOAD(symbol) \
+    XINPUT_LOAD_RUNTIME(1, symbol, Ptr##symbol)
+# else // not runtime XInput
+#  define XINPUT_LOAD(symbol) symbol
+# endif // QT_RUNTIME_XINPUT
+#else // not using Xinput at all
+# define XINPUT_LOAD(symbol) 0
+#endif // QT_NO_XINPUT
+
+#ifndef QT_NO_XFIXES
+# ifdef QT_RUNTIME_XFIXES
+#  define XFIXES_LOAD_RUNTIME(vernum, symbol, symbol_type) \
+    (symbol_type)qt_load_library_runtime("libXfixes", vernum, 4, #symbol);
+#  define XFIXES_LOAD_V1(symbol) \
+    XFIXES_LOAD_RUNTIME(1, symbol, Ptr##symbol)
+#  define XFIXES_LOAD_V2(symbol) \
+    XFIXES_LOAD_RUNTIME(2, symbol, Ptr##symbol)
+
+# else // not runtime Xfixes
+
+#  if XFIXES_MAJOR >= 2
+#   define XFIXES_LOAD_V1(symbol) symbol
+#   define XFIXES_LOAD_V2(symbol) symbol
+#  elif XFIXES_MAJOR >= 1
+#   define XFIXES_LOAD_V1(symbol) symbol
+#   define XFIXES_LOAD_V2(symbol) 0
+#  else
+#   error Unsupported version of Xfixes
+#  endif
+# endif // QT_RUNTIME_XFIXES
+#else // not using Xfixes at all
+# define XFIXES_LOAD_V1(symbol) 0
+# define XFIXES_LOAD_V2(symbol) 0
+#endif // QT_NO_XFIXES
+
+#ifndef QT_NO_XFIXES
+
+struct qt_xfixes_selection_event_data
+{
+    // which selection to filter out.
+    Atom selection;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool qt_xfixes_scanner(Display*, XEvent *event, XPointer arg)
+{
+    qt_xfixes_selection_event_data *data =
+        reinterpret_cast<qt_xfixes_selection_event_data*>(arg);
+    if (event->type == X11->xfixes_eventbase + XFixesSelectionNotify) {
+        XFixesSelectionNotifyEvent *xfixes_event = reinterpret_cast<XFixesSelectionNotifyEvent*>(event);
+        if (xfixes_event->selection == data->selection)
+            return true;
+    }
+    return false;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+#endif // QT_NO_XFIXES
+
+class QETWidget : public QWidget                // event translator widget
+{
+public:
+    QWidgetPrivate* d_func() { return QWidget::d_func(); }
+    bool translateMouseEvent(const XEvent *);
+    void translatePaintEvent(const XEvent *);
+    bool translateConfigEvent(const XEvent *);
+    bool translateCloseEvent(const XEvent *);
+    bool translateScrollDoneEvent(const XEvent *);
+    bool translateWheelEvent(int global_x, int global_y, int delta, Qt::MouseButtons buttons,
+                             Qt::KeyboardModifiers modifiers, Qt::Orientation orient);
+#if !defined (QT_NO_TABLET)
+    bool translateXinputEvent(const XEvent*, QTabletDeviceData *tablet);
+#endif
+    bool translatePropertyEvent(const XEvent *);
+
+    void doDeferredMap()
+    {
+        Q_ASSERT(testAttribute(Qt::WA_WState_Created));
+        if (!testAttribute(Qt::WA_Resized)) {
+            adjustSize();
+            setAttribute(Qt::WA_Resized, false);
+        }
+
+        /*
+          workaround for WM's that throw away ConfigureRequests from the following:
+
+          window->hide();
+          window->move(x, y); // could also be resize(), move()+resize(), or setGeometry()
+          window->show();
+        */
+        QRect r = geometry();
+
+        XMoveResizeWindow(X11->display,
+                          internalWinId(),
+                          r.x(),
+                          r.y(),
+                          r.width(),
+                          r.height());
+
+        // static gravity!
+        XSizeHints sh;
+        memset(&sh, 0, sizeof(sh));
+        long unused;
+        XGetWMNormalHints(X11->display, internalWinId(), &sh, &unused);
+        sh.flags |= USPosition | PPosition | USSize | PSize | PWinGravity;
+        sh.x = r.x();
+        sh.y = r.y();
+        sh.width = r.width();
+        sh.height = r.height();
+        sh.win_gravity = StaticGravity;
+        XSetWMNormalHints(X11->display, internalWinId(), &sh);
+
+        setAttribute(Qt::WA_Mapped);
+        if (testAttribute(Qt::WA_DontShowOnScreen))
+            return;
+        d_func()->topData()->waitingForMapNotify = 1;
+        XMapWindow(X11->display, internalWinId());
+    }
+};
+
+
+void QApplicationPrivate::createEventDispatcher()
+{
+    Q_Q(QApplication);
+#if !defined(QT_NO_GLIB)
+    if (qgetenv("QT_NO_GLIB").isEmpty() && QEventDispatcherGlib::versionSupported())
+        eventDispatcher = (q->type() != QApplication::Tty
+                           ? new QGuiEventDispatcherGlib(q)
+                           : new QEventDispatcherGlib(q));
+    else
+#endif
+        eventDispatcher = (q->type() != QApplication::Tty
+                           ? new QEventDispatcherX11(q)
+                           : new QEventDispatcherUNIX(q));
+}
+
+/*****************************************************************************
+  Default X error handlers
+ *****************************************************************************/
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static int (*original_x_errhandler)(Display *dpy, XErrorEvent *);
+static int (*original_xio_errhandler)(Display *dpy);
+
+static int qt_x_errhandler(Display *dpy, XErrorEvent *err)
+{
+    if (X11->display != dpy) {
+        // only handle X errors for our display
+        return 0;
+    }
+
+    switch (err->error_code) {
+    case BadAtom:
+        if (err->request_code == 20 /* X_GetProperty */
+            && (err->resourceid == XA_RESOURCE_MANAGER
+                || err->resourceid == XA_RGB_DEFAULT_MAP
+                || err->resourceid == ATOM(_NET_SUPPORTED)
+                || err->resourceid == ATOM(_NET_SUPPORTING_WM_CHECK)
+                || err->resourceid == ATOM(XdndProxy)
+                || err->resourceid == ATOM(XdndAware))) {
+            // Perhaps we're running under SECURITY reduction? :/
+            return 0;
+        }
+        break;
+
+    case BadWindow:
+        if (err->request_code == 2 /* X_ChangeWindowAttributes */
+            || err->request_code == 38 /* X_QueryPointer */) {
+            for (int i = 0; i < ScreenCount(dpy); ++i) {
+                if (err->resourceid == RootWindow(dpy, i)) {
+                    // Perhaps we're running under SECURITY reduction? :/
+                    return 0;
+                }
+            }
+        }
+        X11->seen_badwindow = true;
+        if (err->request_code == 25 /* X_SendEvent */) {
+            for (int i = 0; i < ScreenCount(dpy); ++i) {
+                if (err->resourceid == RootWindow(dpy, i)) {
+                    // Perhaps we're running under SECURITY reduction? :/
+                    return 0;
+                }
+            }
+            if (X11->xdndHandleBadwindow()) {
+                qDebug("xdndHandleBadwindow returned true");
+                return 0;
+            }
+        }
+        if (X11->ignore_badwindow)
+            return 0;
+        break;
+
+    default:
+#if !defined(QT_NO_XINPUT)
+        if (err->request_code == X11->xinput_major
+            && err->error_code == (X11->xinput_errorbase + XI_BadDevice)
+            && err->minor_code == 3 /* X_OpenDevice */) {
+            return 0;
+        }
+#endif
+        break;
+    }
+
+    char errstr[256];
+    XGetErrorText( dpy, err->error_code, errstr, 256 );
+    char buffer[256];
+    char request_str[256];
+    qsnprintf(buffer, 256, "%d", err->request_code);
+    XGetErrorDatabaseText(dpy, "XRequest", buffer, "", request_str, 256);
+    if (err->request_code < 128) {
+        // X error for a normal protocol request
+        qWarning( "X Error: %s %d\n"
+                  "  Major opcode: %d (%s)\n"
+                  "  Resource id:  0x%lx",
+                  errstr, err->error_code,
+                  err->request_code,
+                  request_str,
+                  err->resourceid );
+    } else {
+        // X error for an extension request
+        const char *extensionName = 0;
+        if (err->request_code == X11->xrender_major)
+            extensionName = "RENDER";
+        else if (err->request_code == X11->xrandr_major)
+            extensionName = "RANDR";
+        else if (err->request_code == X11->xinput_major)
+            extensionName = "XInputExtension";
+        else if (err->request_code == X11->mitshm_major)
+            extensionName = "MIT-SHM";
+#ifndef QT_NO_XKB
+        else if(err->request_code == X11->xkb_major)
+            extensionName = "XKEYBOARD";
+#endif
+
+        char minor_str[256];
+        if (extensionName) {
+            qsnprintf(buffer, 256, "%s.%d", extensionName, err->minor_code);
+            XGetErrorDatabaseText(dpy, "XRequest", buffer, "", minor_str, 256);
+        } else {
+            extensionName = "Uknown extension";
+            qsnprintf(minor_str, 256, "Unknown request");
+        }
+        qWarning( "X Error: %s %d\n"
+                  "  Extension:    %d (%s)\n"
+                  "  Minor opcode: %d (%s)\n"
+                  "  Resource id:  0x%lx",
+                  errstr, err->error_code,
+                  err->request_code,
+                  extensionName,
+                  err->minor_code,
+                  minor_str,
+                  err->resourceid );
+    }
+
+    // ### we really should distinguish between severe, non-severe and
+    // ### application specific errors
+
+    return 0;
+}
+
+
+static int qt_xio_errhandler(Display *)
+{
+    qWarning("%s: Fatal IO error: client killed", appName);
+    QApplicationPrivate::reset_instance_pointer();
+    exit(1);
+    //### give the application a chance for a proper shutdown instead,
+    //### exit(1) doesn't help.
+    return 0;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+#ifndef QT_NO_XSYNC
+struct qt_sync_request_event_data
+{
+    WId window;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool qt_sync_request_scanner(Display*, XEvent *event, XPointer arg)
+{
+    qt_sync_request_event_data *data =
+        reinterpret_cast<qt_sync_request_event_data*>(arg);
+    if (event->type == ClientMessage &&
+        event->xany.window == data->window &&
+        event->xclient.message_type == ATOM(WM_PROTOCOLS) &&
+        (Atom)event->xclient.data.l[0] == ATOM(_NET_WM_SYNC_REQUEST)) {
+        QWidget *w = QWidget::find(event->xany.window);
+        if (QTLWExtra *tlw = ((QETWidget*)w)->d_func()->maybeTopData()) {
+            const ulong timestamp = (const ulong) event->xclient.data.l[1];
+            if (timestamp > X11->time)
+                X11->time = timestamp;
+            if (timestamp == CurrentTime || timestamp > tlw->syncRequestTimestamp) {
+                tlw->syncRequestTimestamp = timestamp;
+                tlw->newCounterValueLo = event->xclient.data.l[2];
+                tlw->newCounterValueHi = event->xclient.data.l[3];
+            }
+        }
+        return true;
+    }
+    return false;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+#endif // QT_NO_XSYNC
+
+static void qt_x11_create_intern_atoms()
+{
+    const char *names[QX11Data::NAtoms];
+    const char *ptr = x11_atomnames;
+
+    int i = 0;
+    while (*ptr) {
+        names[i++] = ptr;
+        while (*ptr)
+            ++ptr;
+        ++ptr;
+    }
+
+    Q_ASSERT(i == QX11Data::NPredefinedAtoms);
+
+    QByteArray settings_atom_name("_QT_SETTINGS_TIMESTAMP_");
+    settings_atom_name += XDisplayName(X11->displayName);
+    names[i++] = settings_atom_name;
+
+    Q_ASSERT(i == QX11Data::NAtoms);
+#if defined(XlibSpecificationRelease) && (XlibSpecificationRelease >= 6)
+    XInternAtoms(X11->display, (char **)names, i, False, X11->atoms);
+#else
+    for (i = 0; i < QX11Data::NAtoms; ++i)
+        X11->atoms[i] = XInternAtom(X11->display, (char *)names[i], False);
+#endif
+}
+
+Q_GUI_EXPORT void qt_x11_apply_settings_in_all_apps()
+{
+    QByteArray stamp;
+    QDataStream s(&stamp, QIODevice::WriteOnly);
+    s << QDateTime::currentDateTime();
+
+    XChangeProperty(QX11Info::display(), QX11Info::appRootWindow(0),
+                    ATOM(_QT_SETTINGS_TIMESTAMP), ATOM(_QT_SETTINGS_TIMESTAMP), 8,
+                    PropModeReplace, (unsigned char *)stamp.data(), stamp.size());
+}
+
+/*! \internal
+    apply the settings to the application
+*/
+bool QApplicationPrivate::x11_apply_settings()
+{
+    QSettings settings(QSettings::UserScope, QLatin1String("Trolltech"));
+
+    settings.beginGroup(QLatin1String("Qt"));
+
+    /*
+      Qt settings. This is now they are written into the datastream.
+
+      Palette / *                - QPalette
+      font                       - QFont
+      libraryPath                - QStringList
+      style                      - QString
+      doubleClickInterval        - int
+      keyboardInputInterval  - int
+      cursorFlashTime            - int
+      wheelScrollLines           - int
+      colorSpec                  - QString
+      defaultCodec               - QString
+      globalStrut/width          - int
+      globalStrut/height         - int
+      GUIEffects                 - QStringList
+      Font Substitutions/ *      - QStringList
+      Font Substitutions/...     - QStringList
+    */
+
+    QStringList strlist;
+    int i;
+    QPalette pal(Qt::black);
+    int groupCount = 0;
+    strlist = settings.value(QLatin1String("Palette/active")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Active, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+    strlist = settings.value(QLatin1String("Palette/inactive")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Inactive, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+    strlist = settings.value(QLatin1String("Palette/disabled")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Disabled, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+
+    // ### Fix properly for 4.6
+    bool usingGtkSettings = QApplicationPrivate::app_style && QApplicationPrivate::app_style->inherits("QGtkStyle");
+    if (!usingGtkSettings) {
+        if (groupCount == QPalette::NColorGroups)
+            QApplicationPrivate::setSystemPalette(pal);
+    }
+
+    if (!appFont) {
+        // ### Fix properly for 4.6
+        if (!usingGtkSettings) {
+            QFont font(QApplication::font());
+            QString fontDescription;
+            // Override Qt font if KDE4 settings can be used
+            if (X11->desktopVersion == 4) {
+                QSettings kdeSettings(QKde::kdeHome() + QLatin1String("/share/config/kdeglobals"), QSettings::IniFormat);
+                fontDescription = kdeSettings.value(QLatin1String("font")).toString();
+                if (fontDescription.isEmpty()) {
+                    // KDE stores fonts without quotes
+                    fontDescription = kdeSettings.value(QLatin1String("font")).toStringList().join(QLatin1String(","));
+                }
+            }
+            if (fontDescription.isEmpty())
+                fontDescription = settings.value(QLatin1String("font")).toString();
+            if (!fontDescription .isEmpty()) {
+                font.fromString(fontDescription );
+                QApplicationPrivate::setSystemFont(font);
+            }
+        }
+    }
+
+    // read library (ie. plugin) path list
+    QString libpathkey =
+        QString::fromLatin1("%1.%2/libraryPath")
+        .arg(QT_VERSION >> 16)
+        .arg((QT_VERSION & 0xff00) >> 8);
+    QStringList pathlist = settings.value(libpathkey).toString().split(QLatin1Char(':'));
+    if (! pathlist.isEmpty()) {
+        QStringList::ConstIterator it = pathlist.constBegin();
+        while (it != pathlist.constEnd())
+            QApplication::addLibraryPath(*it++);
+    }
+
+    // read new QStyle
+    QString stylename = settings.value(QLatin1String("style")).toString();
+
+    if (stylename.isEmpty() && QApplicationPrivate::styleOverride.isNull() && X11->use_xrender) {
+        stylename = qt_guiPlatformPlugin()->styleName();
+    }
+
+    static QString currentStyleName = stylename;
+    if (QCoreApplication::startingUp()) {
+        if (!stylename.isEmpty() && QApplicationPrivate::styleOverride.isNull())
+            QApplicationPrivate::styleOverride = stylename;
+    } else {
+        if (currentStyleName != stylename) {
+            currentStyleName = stylename;
+            QApplication::setStyle(stylename);
+        }
+    }
+
+    int num =
+        settings.value(QLatin1String("doubleClickInterval"),
+                       QApplication::doubleClickInterval()).toInt();
+    QApplication::setDoubleClickInterval(num);
+
+    num =
+        settings.value(QLatin1String("cursorFlashTime"),
+                       QApplication::cursorFlashTime()).toInt();
+    QApplication::setCursorFlashTime(num);
+
+#ifndef QT_NO_WHEELEVENT
+    num =
+        settings.value(QLatin1String("wheelScrollLines"),
+                       QApplication::wheelScrollLines()).toInt();
+    QApplication::setWheelScrollLines(num);
+#endif
+
+    QString colorspec = settings.value(QLatin1String("colorSpec"),
+                                       QVariant(QLatin1String("default"))).toString();
+    if (colorspec == QLatin1String("normal"))
+        QApplication::setColorSpec(QApplication::NormalColor);
+    else if (colorspec == QLatin1String("custom"))
+        QApplication::setColorSpec(QApplication::CustomColor);
+    else if (colorspec == QLatin1String("many"))
+        QApplication::setColorSpec(QApplication::ManyColor);
+    else if (colorspec != QLatin1String("default"))
+        colorspec = QLatin1String("default");
+
+    QString defaultcodec = settings.value(QLatin1String("defaultCodec"),
+                                          QVariant(QLatin1String("none"))).toString();
+    if (defaultcodec != QLatin1String("none")) {
+        QTextCodec *codec = QTextCodec::codecForName(defaultcodec.toLatin1());
+        if (codec)
+            QTextCodec::setCodecForTr(codec);
+    }
+
+    int w = settings.value(QLatin1String("globalStrut/width")).toInt();
+    int h = settings.value(QLatin1String("globalStrut/height")).toInt();
+    QSize strut(w, h);
+    if (strut.isValid())
+        QApplication::setGlobalStrut(strut);
+
+    QStringList effects = settings.value(QLatin1String("GUIEffects")).toStringList();
+    QApplication::setEffectEnabled(Qt::UI_General,
+                                   effects.contains(QLatin1String("general")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateMenu,
+                                   effects.contains(QLatin1String("animatemenu")));
+    QApplication::setEffectEnabled(Qt::UI_FadeMenu,
+                                   effects.contains(QLatin1String("fademenu")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateCombo,
+                                   effects.contains(QLatin1String("animatecombo")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateTooltip,
+                                   effects.contains(QLatin1String("animatetooltip")));
+    QApplication::setEffectEnabled(Qt::UI_FadeTooltip,
+                                   effects.contains(QLatin1String("fadetooltip")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateToolBox,
+                                   effects.contains(QLatin1String("animatetoolbox")));
+
+    if (!X11->has_fontconfig) {
+        settings.beginGroup(QLatin1String("Font Substitutions"));
+        QStringList fontsubs = settings.childKeys();
+        if (!fontsubs.isEmpty()) {
+            QStringList::Iterator it = fontsubs.begin();
+            for (; it != fontsubs.end(); ++it) {
+                QString fam = *it;
+                QStringList subs = settings.value(fam).toStringList();
+                QFont::insertSubstitutions(fam, subs);
+            }
+        }
+        settings.endGroup();
+    }
+
+    qt_use_rtl_extensions =
+        settings.value(QLatin1String("useRtlExtensions"), false).toBool();
+
+#ifndef QT_NO_IM
+#ifndef QT_NO_XIM
+    if (qt_xim_preferred_style == 0) {
+        QString ximInputStyle = settings.value(QLatin1String("XIMInputStyle"),
+                                               QVariant(QLatin1String("on the spot"))).toString().toLower();
+        if (ximInputStyle == QLatin1String("on the spot"))
+            qt_xim_preferred_style = XIMPreeditCallbacks | XIMStatusNothing;
+        else if (ximInputStyle == QLatin1String("over the spot"))
+            qt_xim_preferred_style = XIMPreeditPosition | XIMStatusNothing;
+        else if (ximInputStyle == QLatin1String("off the spot"))
+            qt_xim_preferred_style = XIMPreeditArea | XIMStatusArea;
+        else if (ximInputStyle == QLatin1String("root"))
+            qt_xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
+    }
+#endif // QT_NO_XIM
+    QStringList inputMethods = QInputContextFactory::keys();
+    if (inputMethods.size() > 2 && inputMethods.contains(QLatin1String("imsw-multi"))) {
+        X11->default_im = QLatin1String("imsw-multi");
+    } else {
+        X11->default_im = settings.value(QLatin1String("DefaultInputMethod"),
+                                         QLatin1String("xim")).toString();
+    }
+#endif //QT_NO_IM
+    settings.endGroup(); // Qt
+
+    return true;
+}
+
+
+/*! \internal
+    Resets the QApplication::instance() pointer to zero
+*/
+void QApplicationPrivate::reset_instance_pointer()
+{ QApplication::self = 0; }
+
+
+// read the _QT_INPUT_ENCODING property and apply the settings to
+// the application
+static void qt_set_input_encoding()
+{
+    Atom type;
+    int format;
+    ulong  nitems, after = 1;
+    unsigned char *data = 0;
+
+    int e = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                                ATOM(_QT_INPUT_ENCODING), 0, 1024,
+                                False, XA_STRING, &type, &format, &nitems,
+                                &after, &data);
+    if (e != Success || !nitems || type == XNone) {
+        // Always use the locale codec, since we have no examples of non-local
+        // XIMs, and since we cannot get a sensible answer about the encoding
+        // from the XIM.
+        qt_input_mapper = QTextCodec::codecForLocale();
+
+    } else {
+        if (!qstricmp((char *)data, "locale"))
+            qt_input_mapper = QTextCodec::codecForLocale();
+        else
+            qt_input_mapper = QTextCodec::codecForName((char *)data);
+        // make sure we have an input codec
+        if(!qt_input_mapper)
+            qt_input_mapper = QTextCodec::codecForName("ISO 8859-1");
+    }
+    if (qt_input_mapper && qt_input_mapper->mibEnum() == 11) // 8859-8
+        qt_input_mapper = QTextCodec::codecForName("ISO 8859-8-I");
+    if(data)
+        XFree((char *)data);
+}
+
+// set font, foreground and background from x11 resources. The
+// arguments may override the resource settings.
+static void qt_set_x11_resources(const char* font = 0, const char* fg = 0,
+                                 const char* bg = 0, const char* button = 0)
+{
+
+    QString resFont, resFG, resBG, resButton, resEF, sysFont, selectBackground, selectForeground;
+
+    QApplication::setEffectEnabled(Qt::UI_General, false);
+    QApplication::setEffectEnabled(Qt::UI_AnimateMenu, false);
+    QApplication::setEffectEnabled(Qt::UI_FadeMenu, false);
+    QApplication::setEffectEnabled(Qt::UI_AnimateCombo, false);
+    QApplication::setEffectEnabled(Qt::UI_AnimateTooltip, false);
+    QApplication::setEffectEnabled(Qt::UI_FadeTooltip, false);
+    QApplication::setEffectEnabled(Qt::UI_AnimateToolBox, false);
+
+    bool paletteAlreadySet = false;
+    if (QApplication::desktopSettingsAware()) {
+        // first, read from settings
+        QApplicationPrivate::x11_apply_settings();
+        // the call to QApplication::style() below creates the system
+        // palette, which breaks the logic after the RESOURCE_MANAGER
+        // loop... so I have to save this value to be able to use it later
+        paletteAlreadySet = (QApplicationPrivate::sys_pal != 0);
+
+        // second, parse the RESOURCE_MANAGER property
+        int format;
+        ulong  nitems, after = 1;
+        QString res;
+        long offset = 0;
+        Atom type = XNone;
+
+        while (after > 0) {
+            uchar *data = 0;
+            if (XGetWindowProperty(X11->display, QX11Info::appRootWindow(0),
+                                   ATOM(RESOURCE_MANAGER),
+                                   offset, 8192, False, AnyPropertyType,
+                                   &type, &format, &nitems, &after,
+                                   &data) != Success) {
+                res = QString();
+                break;
+            }
+            if (type == XA_STRING)
+                res += QString::fromLatin1((char*)data);
+            else
+                res += QString::fromLocal8Bit((char*)data);
+            offset += 2048; // offset is in 32bit quantities... 8192/4 == 2048
+            if (data)
+                XFree((char *)data);
+        }
+
+        QString key, value;
+        int l = 0, r;
+        QString apn = QString::fromLocal8Bit(appName);
+        QString apc = QString::fromLocal8Bit(appClass);
+        int apnl = apn.length();
+        int apcl = apc.length();
+        int resl = res.length();
+
+        while (l < resl) {
+            r = res.indexOf(QLatin1Char('\n'), l);
+            if (r < 0)
+                r = resl;
+            while (res.at(l).isSpace())
+                l++;
+            bool mine = false;
+            QChar sc = res.at(l + 1);
+            if (res.at(l) == QLatin1Char('*') &&
+                (sc == QLatin1Char('f') || sc == QLatin1Char('b') || sc == QLatin1Char('g') ||
+                 sc == QLatin1Char('F') || sc == QLatin1Char('B') || sc == QLatin1Char('G') ||
+                 sc == QLatin1Char('s') || sc == QLatin1Char('S')
+                 // capital T only, since we're looking for "Text.selectSomething"
+                 || sc == QLatin1Char('T'))) {
+                // OPTIMIZED, since we only want "*[fbgsT].."
+                QString item = res.mid(l, r - l).simplified();
+                int i = item.indexOf(QLatin1Char(':'));
+                key = item.left(i).trimmed().mid(1).toLower();
+                value = item.right(item.length() - i - 1).trimmed();
+                mine = true;
+            } else if ((apnl && res.at(l) == apn.at(0)) || (appClass && apcl && res.at(l) == apc.at(0))) {
+                if (res.mid(l,apnl) == apn && (res.at(l+apnl) == QLatin1Char('.')
+                                               || res.at(l+apnl) == QLatin1Char('*'))) {
+                    QString item = res.mid(l, r - l).simplified();
+                    int i = item.indexOf(QLatin1Char(':'));
+                    key = item.left(i).trimmed().mid(apnl+1).toLower();
+                    value = item.right(item.length() - i - 1).trimmed();
+                    mine = true;
+                } else if (res.mid(l,apcl) == apc && (res.at(l+apcl) == QLatin1Char('.')
+                                                      || res.at(l+apcl) == QLatin1Char('*'))) {
+                    QString item = res.mid(l, r - l).simplified();
+                    int i = item.indexOf(QLatin1Char(':'));
+                    key = item.left(i).trimmed().mid(apcl+1).toLower();
+                    value = item.right(item.length() - i - 1).trimmed();
+                    mine = true;
+                }
+            }
+
+            if (mine) {
+                if (!font && key == QLatin1String("systemfont"))
+                    sysFont = value.left(value.lastIndexOf(QLatin1Char(':')));
+                if (!font && key == QLatin1String("font"))
+                    resFont = value;
+                else if (!fg && !paletteAlreadySet) {
+                    if (key == QLatin1String("foreground"))
+                        resFG = value;
+                    else if (!bg && key == QLatin1String("background"))
+                        resBG = value;
+                    else if (!bg && !button && key == QLatin1String("button.background"))
+                        resButton = value;
+                    else if (key == QLatin1String("text.selectbackground")) {
+                        selectBackground = value;
+                    } else if (key == QLatin1String("text.selectforeground")) {
+                        selectForeground = value;
+                    }
+                } else if (key == QLatin1String("guieffects"))
+                    resEF = value;
+                // NOTE: if you add more, change the [fbg] stuff above
+            }
+
+            l = r + 1;
+        }
+    }
+    if (!sysFont.isEmpty())
+        resFont = sysFont;
+    if (resFont.isEmpty())
+        resFont = QString::fromLocal8Bit(font);
+    if (resFG.isEmpty())
+        resFG = QString::fromLocal8Bit(fg);
+    if (resBG.isEmpty())
+        resBG = QString::fromLocal8Bit(bg);
+    if (resButton.isEmpty())
+        resButton = QString::fromLocal8Bit(button);
+    if (!resFont.isEmpty()
+        && !X11->has_fontconfig
+        && !QApplicationPrivate::sys_font) {
+        // set application font
+        QFont fnt;
+        fnt.setRawName(resFont);
+
+        // the font we get may actually be an alias for another font,
+        // so we reset the application font to the real font info.
+        if (! fnt.exactMatch()) {
+            QFontInfo fontinfo(fnt);
+            fnt.setFamily(fontinfo.family());
+            fnt.setRawMode(fontinfo.rawMode());
+
+            if (! fnt.rawMode()) {
+                fnt.setItalic(fontinfo.italic());
+                fnt.setWeight(fontinfo.weight());
+                fnt.setUnderline(fontinfo.underline());
+                fnt.setStrikeOut(fontinfo.strikeOut());
+                fnt.setStyleHint(fontinfo.styleHint());
+
+                if (fnt.pointSize() <= 0 && fnt.pixelSize() <= 0) {
+                    // size is all wrong... fix it
+                    qreal pointSize = fontinfo.pixelSize() * 72. / (float) QX11Info::appDpiY();
+                    if (pointSize <= 0)
+                        pointSize = 12;
+                    fnt.setPointSize(qRound(pointSize));
+                }
+            }
+        }
+
+        QApplicationPrivate::setSystemFont(fnt);
+    }
+    // QGtkStyle sets it's own system palette
+    bool gtkStyle = QApplicationPrivate::app_style && QApplicationPrivate::app_style->inherits("QGtkStyle");
+    bool kdeColors = (QApplication::desktopSettingsAware() && X11->desktopEnvironment == DE_KDE);
+    if (!gtkStyle && (kdeColors || (button || !resBG.isEmpty() || !resFG.isEmpty()))) {// set app colors
+        bool allowX11ColorNames = QColor::allowX11ColorNames();
+        QColor::setAllowX11ColorNames(true);
+
+        (void) QApplication::style();  // trigger creation of application style and system palettes
+        QColor btn;
+        QColor bg;
+        QColor fg;
+        QColor bfg;
+        QColor wfg;
+        if (!resBG.isEmpty())
+            bg = QColor(resBG);
+        if (!bg.isValid())
+            bg = QApplicationPrivate::sys_pal->color(QPalette::Active, QPalette::Window);
+
+        if (!resFG.isEmpty())
+            fg = QColor(resFG);
+        if (!fg.isValid())
+            fg = QApplicationPrivate::sys_pal->color(QPalette::Active, QPalette::WindowText);
+
+        if (!resButton.isEmpty())
+            btn = QColor(resButton);
+        else if (!resBG.isEmpty())
+            btn = bg;
+        if (!btn.isValid())
+            btn = QApplicationPrivate::sys_pal->color(QPalette::Active, QPalette::Button);
+
+        int h,s,v;
+        fg.getHsv(&h,&s,&v);
+        QColor base = Qt::white;
+        bool bright_mode = false;
+        if (v >= 255 - 50) {
+            base = btn.darker(150);
+            bright_mode = true;
+        }
+
+        QPalette pal(fg, btn, btn.lighter(125), btn.darker(130), btn.darker(120), wfg.isValid() ? wfg : fg, Qt::white, base, bg);
+        QColor disabled((fg.red()   + btn.red())  / 2,
+                        (fg.green() + btn.green())/ 2,
+                        (fg.blue()  + btn.blue()) / 2);
+        pal.setColorGroup(QPalette::Disabled, disabled, btn, btn.lighter(125),
+                          btn.darker(130), btn.darker(150), disabled, Qt::white, Qt::white, bg);
+
+        QColor highlight, highlightText;
+        if (!selectBackground.isEmpty() && !selectForeground.isEmpty()) {
+            highlight = QColor(selectBackground);
+            highlightText = QColor(selectForeground);
+        }
+
+        if (highlight.isValid() && highlightText.isValid()) {
+            pal.setColor(QPalette::Highlight, highlight);
+            pal.setColor(QPalette::HighlightedText, highlightText);
+
+            // calculate disabled colors by removing saturation
+            highlight.setHsv(highlight.hue(), 0, highlight.value(), highlight.alpha());
+            highlightText.setHsv(highlightText.hue(), 0, highlightText.value(), highlightText.alpha());
+            pal.setColor(QPalette::Disabled, QPalette::Highlight, highlight);
+            pal.setColor(QPalette::Disabled, QPalette::HighlightedText, highlightText);
+        } else if (bright_mode) {
+            pal.setColor(QPalette::HighlightedText, base);
+            pal.setColor(QPalette::Highlight, Qt::white);
+            pal.setColor(QPalette::Disabled, QPalette::HighlightedText, base);
+            pal.setColor(QPalette::Disabled, QPalette::Highlight, Qt::white);
+        } else {
+            pal.setColor(QPalette::HighlightedText, Qt::white);
+            pal.setColor(QPalette::Highlight, Qt::darkBlue);
+            pal.setColor(QPalette::Disabled, QPalette::HighlightedText, Qt::white);
+            pal.setColor(QPalette::Disabled, QPalette::Highlight, Qt::darkBlue);
+        }
+
+        pal = qt_guiPlatformPlugin()->palette().resolve(pal);
+        QApplicationPrivate::setSystemPalette(pal);
+        QColor::setAllowX11ColorNames(allowX11ColorNames);
+    }
+
+    if (!resEF.isEmpty()) {
+        QStringList effects = resEF.split(QLatin1Char(' '));
+        QApplication::setEffectEnabled(Qt::UI_General, effects.contains(QLatin1String("general")));
+        QApplication::setEffectEnabled(Qt::UI_AnimateMenu,
+                                       effects.contains(QLatin1String("animatemenu")));
+        QApplication::setEffectEnabled(Qt::UI_FadeMenu,
+                                       effects.contains(QLatin1String("fademenu")));
+        QApplication::setEffectEnabled(Qt::UI_AnimateCombo,
+                                       effects.contains(QLatin1String("animatecombo")));
+        QApplication::setEffectEnabled(Qt::UI_AnimateTooltip,
+                                       effects.contains(QLatin1String("animatetooltip")));
+        QApplication::setEffectEnabled(Qt::UI_FadeTooltip,
+                                       effects.contains(QLatin1String("fadetooltip")));
+        QApplication::setEffectEnabled(Qt::UI_AnimateToolBox,
+                                       effects.contains(QLatin1String("animatetoolbox")));
+    }
+
+    QIconLoader::instance()->updateSystemTheme();
+}
+
+
+// update the supported array
+static void qt_get_net_supported()
+{
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data = 0;
+
+    int e = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                               ATOM(_NET_SUPPORTED), 0, 0,
+                               False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+        XFree(data);
+
+    if (X11->net_supported_list)
+        delete [] X11->net_supported_list;
+    X11->net_supported_list = 0;
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+        QBuffer ts;
+        ts.open(QIODevice::WriteOnly);
+
+        while (after > 0) {
+            XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                               ATOM(_NET_SUPPORTED), offset, 1024,
+                               False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+            if (type == XA_ATOM && format == 32) {
+                ts.write(reinterpret_cast<char *>(data), nitems * sizeof(long));
+                offset += nitems;
+            } else
+                after = 0;
+            if (data)
+                XFree(data);
+        }
+
+        // compute nitems
+        QByteArray buffer(ts.buffer());
+        nitems = buffer.size() / sizeof(Atom);
+        X11->net_supported_list = new Atom[nitems + 1];
+        Atom *a = (Atom *) buffer.data();
+        uint i;
+        for (i = 0; i < nitems; i++)
+            X11->net_supported_list[i] = a[i];
+        X11->net_supported_list[nitems] = 0;
+    }
+}
+
+
+bool QX11Data::isSupportedByWM(Atom atom)
+{
+    if (!X11->net_supported_list)
+        return false;
+
+    bool supported = false;
+    int i = 0;
+    while (X11->net_supported_list[i] != 0) {
+        if (X11->net_supported_list[i++] == atom) {
+            supported = true;
+            break;
+        }
+    }
+
+    return supported;
+}
+
+
+// update the virtual roots array
+static void qt_get_net_virtual_roots()
+{
+    if (X11->net_virtual_root_list)
+        delete [] X11->net_virtual_root_list;
+    X11->net_virtual_root_list = 0;
+
+    if (!X11->isSupportedByWM(ATOM(_NET_VIRTUAL_ROOTS)))
+        return;
+
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data;
+
+    int e = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                               ATOM(_NET_VIRTUAL_ROOTS), 0, 0,
+                               False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+        XFree(data);
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+        QBuffer ts;
+        ts.open(QIODevice::WriteOnly);
+
+        while (after > 0) {
+            XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                               ATOM(_NET_VIRTUAL_ROOTS), offset, 1024,
+                               False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+            if (type == XA_ATOM && format == 32) {
+                ts.write(reinterpret_cast<char *>(data), nitems * 4);
+                offset += nitems;
+            } else
+                after = 0;
+            if (data)
+                XFree(data);
+        }
+
+        // compute nitems
+        QByteArray buffer(ts.buffer());
+        nitems = buffer.size() / sizeof(Window);
+        X11->net_virtual_root_list = new Window[nitems + 1];
+        Window *a = (Window *) buffer.data();
+        uint i;
+        for (i = 0; i < nitems; i++)
+            X11->net_virtual_root_list[i] = a[i];
+        X11->net_virtual_root_list[nitems] = 0;
+    }
+}
+
+void qt_net_remove_user_time(QWidget *tlw)
+{
+    Q_ASSERT(tlw);
+    QTLWExtra *extra = tlw->d_func()->maybeTopData();
+    if (extra && extra->userTimeWindow) {
+        Q_ASSERT(tlw->internalWinId());
+        XDeleteProperty(X11->display, tlw->internalWinId(), ATOM(_NET_WM_USER_TIME_WINDOW));
+        XDestroyWindow(X11->display, extra->userTimeWindow);
+        extra->userTimeWindow = 0;
+    }
+}
+
+void qt_net_update_user_time(QWidget *tlw, unsigned long timestamp)
+{
+    Q_ASSERT(tlw);
+    Q_ASSERT(tlw->isWindow());
+    Q_ASSERT(tlw->testAttribute(Qt::WA_WState_Created));
+    QTLWExtra *extra = tlw->d_func()->topData();
+    WId wid = tlw->internalWinId();
+    const bool isSupportedByWM = X11->isSupportedByWM(ATOM(_NET_WM_USER_TIME_WINDOW));
+    if (extra->userTimeWindow || isSupportedByWM) {
+        if (!extra->userTimeWindow) {
+            extra->userTimeWindow = XCreateSimpleWindow(X11->display,
+                                                        tlw->internalWinId(),
+                                                        -1, -1, 1, 1, 0, 0, 0);
+            wid = extra->userTimeWindow;
+            XChangeProperty(X11->display, tlw->internalWinId(), ATOM(_NET_WM_USER_TIME_WINDOW),
+                            XA_WINDOW, 32, PropModeReplace,
+                            (unsigned char *)&wid, 1);
+            XDeleteProperty(X11->display, tlw->internalWinId(), ATOM(_NET_WM_USER_TIME));
+        } else if (!isSupportedByWM) {
+            // WM no longer supports it, then we should remove the
+            // _NET_WM_USER_TIME_WINDOW atom.
+            qt_net_remove_user_time(tlw);
+        } else {
+            wid = extra->userTimeWindow;
+        }
+    }
+    XChangeProperty(X11->display, wid, ATOM(_NET_WM_USER_TIME),
+                    XA_CARDINAL, 32, PropModeReplace, (unsigned char *) &timestamp, 1);
+}
+
+static void qt_check_focus_model()
+{
+    Window fw = XNone;
+    int unused;
+    XGetInputFocus(X11->display, &fw, &unused);
+    if (fw == PointerRoot)
+        X11->focus_model = QX11Data::FM_PointerRoot;
+    else
+        X11->focus_model = QX11Data::FM_Other;
+}
+
+#ifndef QT_NO_TABLET
+
+#if !defined (Q_OS_IRIX)
+// from include/Xwacom.h
+#  define XWACOM_PARAM_TOOLID 322
+#  define XWACOM_PARAM_TOOLSERIAL 323
+
+typedef WACOMCONFIG * (*PtrWacomConfigInit) (Display*, WACOMERRORFUNC);
+typedef WACOMDEVICE * (*PtrWacomConfigOpenDevice) (WACOMCONFIG*, const char*);
+typedef int *(*PtrWacomConfigGetRawParam) (WACOMDEVICE*, int, int*, int, unsigned*);
+typedef int (*PtrWacomConfigCloseDevice) (WACOMDEVICE *);
+typedef void (*PtrWacomConfigTerm) (WACOMCONFIG *);
+
+static PtrWacomConfigInit ptrWacomConfigInit = 0;
+static PtrWacomConfigOpenDevice ptrWacomConfigOpenDevice = 0;
+static PtrWacomConfigGetRawParam ptrWacomConfigGetRawParam = 0;
+static PtrWacomConfigCloseDevice ptrWacomConfigCloseDevice = 0;
+static PtrWacomConfigTerm ptrWacomConfigTerm = 0;
+Q_GLOBAL_STATIC(QByteArray, wacomDeviceName)
+#endif
+
+#endif
+
+/*****************************************************************************
+  qt_init() - initializes Qt for X11
+ *****************************************************************************/
+
+#if !defined(QT_NO_FONTCONFIG)
+static void getXDefault(const char *group, const char *key, int *val)
+{
+    char *str = XGetDefault(X11->display, group, key);
+    if (str) {
+        char *end = 0;
+        int v = strtol(str, &end, 0);
+        if (str != end)
+            *val = v;
+        // otherwise use fontconfig to convert the string to integer
+        else
+            FcNameConstant((FcChar8 *) str, val);
+    }
+}
+
+static void getXDefault(const char *group, const char *key, double *val)
+{
+    char *str = XGetDefault(X11->display, group, key);
+    if (str) {
+        bool ok;
+        double v = QByteArray(str).toDouble(&ok);
+        if (ok)
+            *val = v;
+    }
+}
+
+static void getXDefault(const char *group, const char *key, bool *val)
+{
+    char *str = XGetDefault(X11->display, group, key);
+    if (str) {
+        char c = str[0];
+        if (isupper((int)c))
+            c = tolower(c);
+        if (c == 't' || c == 'y' || c == '1')
+            *val = true;
+        else if (c == 'f' || c == 'n' || c == '0')
+            *val = false;
+        if (c == 'o') {
+            c = str[1];
+            if (isupper((int)c))
+                c = tolower(c);
+            if (c == 'n')
+                *val = true;
+            if (c == 'f')
+                *val = false;
+        }
+    }
+}
+#endif
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+// Find out if our parent process is gdb by looking at the 'exe' symlink under /proc,.
+// or, for older Linuxes, read out 'cmdline'.
+bool runningUnderDebugger()
+{
+    const QString parentProc = QLatin1String("/proc/") + QString::number(getppid());
+    const QFileInfo parentProcExe(parentProc + QLatin1String("/exe"));
+    if (parentProcExe.isSymLink())
+        return parentProcExe.symLinkTarget().endsWith(QLatin1String("/gdb"));
+    QFile f(parentProc + QLatin1String("/cmdline"));
+    if (!f.open(QIODevice::ReadOnly))
+        return false;
+    QByteArray s;
+    char c;
+    while (f.getChar(&c) && c) {
+        if (c == '/')
+            s.clear();
+        else
+            s += c;
+    }
+    return s == "gdb";
+}
+#endif
+
+// ### This should be static but it isn't because of the friend declaration
+// ### in qpaintdevice.h which then should have a static too but can't have
+// ### it because "storage class specifiers invalid in friend function
+// ### declarations" :-) Ideas anyone?
+void qt_init(QApplicationPrivate *priv, int,
+	     Display *display, Qt::HANDLE visual, Qt::HANDLE colormap)
+{
+    X11 = new QX11Data;
+    X11->display = display;
+    X11->displayName = 0;
+    X11->foreignDisplay = (display != 0);
+    X11->focus_model = -1;
+
+    // RANDR
+    X11->use_xrandr = false;
+    X11->xrandr_major = 0;
+    X11->xrandr_eventbase = 0;
+    X11->xrandr_errorbase = 0;
+
+    // RENDER
+    X11->use_xrender = false;
+    X11->xrender_major = 0;
+    X11->xrender_version = 0;
+
+    // XFIXES
+    X11->use_xfixes = false;
+    X11->xfixes_major = 0;
+    X11->xfixes_eventbase = 0;
+    X11->xfixes_errorbase = 0;
+
+    // XInputExtension
+    X11->use_xinput = false;
+    X11->xinput_major = 0;
+    X11->xinput_eventbase = 0;
+    X11->xinput_errorbase = 0;
+
+    X11->use_xkb = false;
+    X11->xkb_major = 0;
+    X11->xkb_eventbase = 0;
+    X11->xkb_errorbase = 0;
+
+    // MIT-SHM
+    X11->use_mitshm = false;
+    X11->use_mitshm_pixmaps = false;
+    X11->mitshm_major = 0;
+
+    X11->sip_serial = 0;
+    X11->net_supported_list = 0;
+    X11->net_virtual_root_list = 0;
+    X11->wm_client_leader = 0;
+    X11->screens = 0;
+    X11->argbVisuals = 0;
+    X11->argbColormaps = 0;
+    X11->screenCount = 0;
+    X11->time = CurrentTime;
+    X11->userTime = CurrentTime;
+    X11->ignore_badwindow = false;
+    X11->seen_badwindow = false;
+
+    X11->motifdnd_active = false;
+
+    X11->default_im = QLatin1String("imsw-multi");
+    priv->inputContext = 0;
+
+    // colormap control
+    X11->visual_class = -1;
+    X11->visual_id = -1;
+    X11->color_count = 0;
+    X11->custom_cmap = false;
+
+    // outside visual/colormap
+    X11->visual = reinterpret_cast<Visual *>(visual);
+    X11->colormap = colormap;
+
+    // Fontconfig
+    X11->has_fontconfig = false;
+#if !defined(QT_NO_FONTCONFIG)
+    if (qgetenv("QT_X11_NO_FONTCONFIG").isNull())
+        X11->has_fontconfig = FcInit();
+    X11->fc_antialias = true;
+#endif
+
+#ifndef QT_NO_XRENDER
+    memset(X11->solid_fills, 0, sizeof(X11->solid_fills));
+    for (int i = 0; i < X11->solid_fill_count; ++i)
+        X11->solid_fills[i].screen = -1;
+    memset(X11->pattern_fills, 0, sizeof(X11->pattern_fills));
+    for (int i = 0; i < X11->pattern_fill_count; ++i)
+        X11->pattern_fills[i].screen = -1;
+#endif
+
+    X11->startupId = 0;
+
+    int argc = priv->argc;
+    char **argv = priv->argv;
+
+    if (X11->display) {
+        // Qt part of other application
+
+        // Set application name and class
+        appName = qstrdup("Qt-subapplication");
+        char *app_class = 0;
+        if (argv) {
+            const char* p = strrchr(argv[0], '/');
+            app_class = qstrdup(p ? p + 1 : argv[0]);
+            if (app_class[0])
+                app_class[0] = toupper(app_class[0]);
+        }
+        appClass = app_class;
+    } else {
+        // Qt controls everything (default)
+
+        if (QApplication::testAttribute(Qt::AA_X11InitThreads))
+            XInitThreads();
+
+        // Set application name and class
+        char *app_class = 0;
+        if (argv && argv[0]) {
+            const char *p = strrchr(argv[0], '/');
+            appName = p ? p + 1 : argv[0];
+            app_class = qstrdup(appName);
+            if (app_class[0])
+                app_class[0] = toupper(app_class[0]);
+        }
+        appClass = app_class;
+    }
+
+    // Install default error handlers
+    original_x_errhandler = XSetErrorHandler(qt_x_errhandler);
+    original_xio_errhandler = XSetIOErrorHandler(qt_xio_errhandler);
+
+    // Get command line params
+    int j = argc ? 1 : 0;
+    for (int i=1; i<argc; i++) {
+        if (argv[i] && *argv[i] != '-') {
+            argv[j++] = argv[i];
+            continue;
+        }
+        QByteArray arg(argv[i]);
+        if (arg == "-display") {
+            if (++i < argc && !X11->display)
+                X11->displayName = argv[i];
+        } else if (arg == "-fn" || arg == "-font") {
+            if (++i < argc)
+                appFont = argv[i];
+        } else if (arg == "-bg" || arg == "-background") {
+            if (++i < argc)
+                appBGCol = argv[i];
+        } else if (arg == "-btn" || arg == "-button") {
+            if (++i < argc)
+                appBTNCol = argv[i];
+        } else if (arg == "-fg" || arg == "-foreground") {
+            if (++i < argc)
+                appFGCol = argv[i];
+        } else if (arg == "-name") {
+            if (++i < argc)
+                appName = argv[i];
+        } else if (arg == "-title") {
+            if (++i < argc)
+                mwTitle = argv[i];
+        } else if (arg == "-geometry") {
+            if (++i < argc)
+                mwGeometry = argv[i];
+        } else if (arg == "-im") {
+            if (++i < argc)
+                qt_ximServer = argv[i];
+        } else if (arg == "-ncols") {   // xv and netscape use this name
+            if (++i < argc)
+                X11->color_count = qMax(0,atoi(argv[i]));
+        } else if (arg == "-visual") {  // xv and netscape use this name
+            if (++i < argc && !X11->visual) {
+                QString s = QString::fromLocal8Bit(argv[i]).toLower();
+                if (s == QLatin1String("staticgray"))
+                    X11->visual_class = StaticGray;
+                else if (s == QLatin1String("grayscale"))
+                    X11->visual_class = XGrayScale;
+                else if (s == QLatin1String("staticcolor"))
+                    X11->visual_class = StaticColor;
+                else if (s == QLatin1String("pseudocolor"))
+                    X11->visual_class = PseudoColor;
+                else if (s == QLatin1String("truecolor"))
+                    X11->visual_class = TrueColor;
+                else if (s == QLatin1String("directcolor"))
+                    X11->visual_class = DirectColor;
+                else
+                    X11->visual_id = static_cast<int>(strtol(argv[i], 0, 0));
+            }
+#ifndef QT_NO_XIM
+        } else if (arg == "-inputstyle") {
+            if (++i < argc) {
+                QString s = QString::fromLocal8Bit(argv[i]).toLower();
+                if (s == QLatin1String("onthespot"))
+                    qt_xim_preferred_style = XIMPreeditCallbacks |
+                                             XIMStatusNothing;
+                else if (s == QLatin1String("overthespot"))
+                    qt_xim_preferred_style = XIMPreeditPosition |
+                                             XIMStatusNothing;
+                else if (s == QLatin1String("offthespot"))
+                    qt_xim_preferred_style = XIMPreeditArea |
+                                             XIMStatusArea;
+                else if (s == QLatin1String("root"))
+                    qt_xim_preferred_style = XIMPreeditNothing |
+                                             XIMStatusNothing;
+            }
+#endif
+        } else if (arg == "-cmap") {    // xv uses this name
+            if (!X11->colormap)
+                X11->custom_cmap = true;
+        }
+        else if (arg == "-sync")
+            appSync = !appSync;
+#if defined(QT_DEBUG)
+        else if (arg == "-nograb")
+            appNoGrab = !appNoGrab;
+        else if (arg == "-dograb")
+            appDoGrab = !appDoGrab;
+#endif
+        else
+            argv[j++] = argv[i];
+    }
+
+    priv->argc = j;
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+    if (!appNoGrab && !appDoGrab && runningUnderDebugger()) {
+        appNoGrab = true;
+        qDebug("Qt: gdb: -nograb added to command-line options.\n"
+               "\t Use the -dograb option to enforce grabbing.");
+    }
+#endif
+
+    // Connect to X server
+    if (qt_is_gui_used && !X11->display) {
+        if ((X11->display = XOpenDisplay(X11->displayName)) == 0) {
+            qWarning("%s: cannot connect to X server %s", appName,
+                     XDisplayName(X11->displayName));
+            QApplicationPrivate::reset_instance_pointer();
+            exit(1);
+        }
+
+        if (appSync)                                // if "-sync" argument
+            XSynchronize(X11->display, true);
+    }
+
+    // Common code, regardless of whether display is foreign.
+
+    // Get X parameters
+
+    if (qt_is_gui_used) {
+        X11->defaultScreen = DefaultScreen(X11->display);
+        X11->screenCount = ScreenCount(X11->display);
+
+        int formatCount = 0;
+        XPixmapFormatValues *values = XListPixmapFormats(X11->display, &formatCount);
+        for (int i = 0; i < formatCount; ++i)
+            X11->bppForDepth[values[i].depth] = values[i].bits_per_pixel;
+        XFree(values);
+
+        X11->screens = new QX11InfoData[X11->screenCount];
+        X11->argbVisuals = new Visual *[X11->screenCount];
+        X11->argbColormaps = new Colormap[X11->screenCount];
+
+        for (int s = 0; s < X11->screenCount; s++) {
+            QX11InfoData *screen = X11->screens + s;
+            screen->ref = 1; // ensures it doesn't get deleted
+            screen->screen = s;
+
+            int widthMM = DisplayWidthMM(X11->display, s);
+            if (widthMM != 0) {
+                screen->dpiX = (DisplayWidth(X11->display, s) * 254 + widthMM * 5) / (widthMM * 10);
+            } else {
+                screen->dpiX = 72;
+            }
+
+            int heightMM = DisplayHeightMM(X11->display, s);
+            if (heightMM != 0) {
+                screen->dpiY = (DisplayHeight(X11->display, s) * 254 + heightMM * 5) / (heightMM * 10);
+            } else {
+                screen->dpiY = 72;
+            }
+
+            X11->argbVisuals[s] = 0;
+            X11->argbColormaps[s] = 0;
+        }
+
+
+#ifndef QT_NO_XRENDER
+        int xrender_eventbase,  xrender_errorbase;
+        // See if XRender is supported on the connected display
+        if (XQueryExtension(X11->display, "RENDER", &X11->xrender_major,
+                            &xrender_eventbase, &xrender_errorbase)
+            && XRenderQueryExtension(X11->display, &xrender_eventbase,
+                                     &xrender_errorbase)) {
+            // Check the version as well - we need v0.4 or higher
+            int major = 0;
+            int minor = 0;
+            XRenderQueryVersion(X11->display, &major, &minor);
+            if (qgetenv("QT_X11_NO_XRENDER").isNull()) {
+                X11->use_xrender = (major >= 0 && minor >= 5);
+                X11->xrender_version = major*100+minor;
+                // workaround for broken XServer on Ubuntu Breezy (6.8 compiled with 7.0
+                // protocol headers)
+                if (X11->xrender_version == 10
+                    && VendorRelease(X11->display) < 60900000
+                    && QByteArray(ServerVendor(X11->display)).contains("X.Org"))
+                    X11->xrender_version = 9;
+            }
+        }
+#endif // QT_NO_XRENDER
+
+#ifndef QT_NO_MITSHM
+        int mitshm_minor;
+        int mitshm_major;
+        int mitshm_eventbase;
+        int mitshm_errorbase;
+        int mitshm_pixmaps;
+        if (XQueryExtension(X11->display, "MIT-SHM", &X11->mitshm_major,
+                            &mitshm_eventbase, &mitshm_errorbase)
+            && XShmQueryVersion(X11->display, &mitshm_major, &mitshm_minor,
+                                &mitshm_pixmaps))
+        {
+            QString displayName = QLatin1String(XDisplayName(NULL));
+
+            // MITSHM only works for local displays, so do a quick check here
+            // to determine whether the display is local or not (not 100 % accurate).
+            // BGR server layouts are not supported either, since it requires the raster
+            // engine to work on a QImage with BGR layout.
+            bool local = displayName.isEmpty() || displayName.lastIndexOf(QLatin1Char(':')) == 0;
+            if (local && (qgetenv("QT_X11_NO_MITSHM").toInt() == 0)) {
+                Visual *defaultVisual = DefaultVisual(X11->display, DefaultScreen(X11->display));
+                X11->use_mitshm = ((defaultVisual->red_mask == 0xff0000
+                                    || defaultVisual->red_mask == 0xf800)
+                                   && (defaultVisual->green_mask == 0xff00
+                                       || defaultVisual->green_mask == 0x7e0)
+                                   && (defaultVisual->blue_mask == 0xff
+                                       || defaultVisual->blue_mask == 0x1f));
+                X11->use_mitshm_pixmaps = X11->use_mitshm && mitshm_pixmaps;
+            }
+        }
+#endif // QT_NO_MITSHM
+
+        // initialize the graphics system - order is imporant here - it must be done before
+        // the QColormap::initialize() call
+        QApplicationPrivate::graphics_system = QGraphicsSystemFactory::create(QApplicationPrivate::graphics_system_name);
+        QColormap::initialize();
+
+        // Support protocols
+        X11->xdndSetup();
+
+        // Finally create all atoms
+        qt_x11_create_intern_atoms();
+
+        // initialize NET lists
+        qt_get_net_supported();
+        qt_get_net_virtual_roots();
+
+#ifndef QT_NO_XRANDR
+        // See if XRandR is supported on the connected display
+        if (XQueryExtension(X11->display, "RANDR", &X11->xrandr_major,
+                            &X11->xrandr_eventbase, &X11->xrandr_errorbase)) {
+
+#  ifdef QT_RUNTIME_XRANDR
+            X11->ptrXRRSelectInput = 0;
+            X11->ptrXRRUpdateConfiguration = 0;
+            X11->ptrXRRRootToScreen = 0;
+            X11->ptrXRRQueryExtension = 0;
+            QLibrary xrandrLib(QLatin1String("Xrandr"), 2);
+            xrandrLib.setLoadHints(QLibrary::ImprovedSearchHeuristics);
+            if (!xrandrLib.load()) { // try without the version number
+                xrandrLib.setFileName(QLatin1String("Xrandr"));
+                xrandrLib.load();
+            }
+            if (xrandrLib.isLoaded()) {
+                X11->ptrXRRSelectInput =
+                    (PtrXRRSelectInput) xrandrLib.resolve("XRRSelectInput");
+                X11->ptrXRRUpdateConfiguration =
+                    (PtrXRRUpdateConfiguration) xrandrLib.resolve("XRRUpdateConfiguration");
+                X11->ptrXRRRootToScreen =
+                    (PtrXRRRootToScreen) xrandrLib.resolve("XRRRootToScreen");
+                X11->ptrXRRQueryExtension =
+                    (PtrXRRQueryExtension) xrandrLib.resolve("XRRQueryExtension");
+            }
+#  else
+            X11->ptrXRRSelectInput = XRRSelectInput;
+            X11->ptrXRRUpdateConfiguration = XRRUpdateConfiguration;
+            X11->ptrXRRRootToScreen = XRRRootToScreen;
+            X11->ptrXRRQueryExtension = XRRQueryExtension;
+#  endif
+
+            if (X11->ptrXRRQueryExtension
+                && X11->ptrXRRQueryExtension(X11->display, &X11->xrandr_eventbase, &X11->xrandr_errorbase)) {
+                // XRandR is supported
+                X11->use_xrandr = true;
+            }
+        }
+#endif // QT_NO_XRANDR
+
+#ifndef QT_NO_XRENDER
+        if (X11->use_xrender) {
+            // XRender is supported, let's see if we have a PictFormat for the
+            // default visual
+            XRenderPictFormat *format =
+                XRenderFindVisualFormat(X11->display,
+                                        (Visual *) QX11Info::appVisual(X11->defaultScreen));
+
+            if (!format) {
+                X11->use_xrender = false;
+            }
+        }
+#endif // QT_NO_XRENDER
+
+#ifndef QT_NO_XFIXES
+        // See if Xfixes is supported on the connected display
+        if (XQueryExtension(X11->display, "XFIXES", &X11->xfixes_major,
+                            &X11->xfixes_eventbase, &X11->xfixes_errorbase)) {
+            X11->ptrXFixesQueryExtension  = XFIXES_LOAD_V1(XFixesQueryExtension);
+            X11->ptrXFixesQueryVersion    = XFIXES_LOAD_V1(XFixesQueryVersion);
+            X11->ptrXFixesSetCursorName   = XFIXES_LOAD_V2(XFixesSetCursorName);
+            X11->ptrXFixesSelectSelectionInput = XFIXES_LOAD_V2(XFixesSelectSelectionInput);
+
+            if(X11->ptrXFixesQueryExtension && X11->ptrXFixesQueryVersion
+               && X11->ptrXFixesQueryExtension(X11->display, &X11->xfixes_eventbase,
+                                               &X11->xfixes_errorbase)) {
+                // Xfixes is supported.
+                // Note: the XFixes protocol version is negotiated using QueryVersion.
+                // We supply the highest version we support, the X server replies with
+                // the highest version it supports, but no higher than the version we
+                // asked for. The version sent back is the protocol version the X server
+                // will use to talk us. If this call is removed, the behavior of the
+                // X server when it receives an XFixes request is undefined.
+                int major = 3;
+                int minor = 0;
+                X11->ptrXFixesQueryVersion(X11->display, &major, &minor);
+                X11->use_xfixes = (major >= 1);
+                X11->xfixes_major = major;
+            }
+        } else {
+            X11->ptrXFixesQueryExtension  = 0;
+            X11->ptrXFixesQueryVersion    = 0;
+            X11->ptrXFixesSetCursorName   = 0;
+            X11->ptrXFixesSelectSelectionInput = 0;
+        }
+#endif // QT_NO_XFIXES
+
+#ifndef QT_NO_XCURSOR
+#ifdef QT_RUNTIME_XCURSOR
+        X11->ptrXcursorLibraryLoadCursor = 0;
+        QLibrary xcursorLib(QLatin1String("Xcursor"), 1);
+        xcursorLib.setLoadHints(QLibrary::ImprovedSearchHeuristics);
+        bool xcursorFound = xcursorLib.load();
+        if (!xcursorFound) { //try without the version number
+            xcursorLib.setFileName(QLatin1String("Xcursor"));
+            xcursorFound = xcursorLib.load();
+        }
+        if (xcursorFound) {
+            X11->ptrXcursorLibraryLoadCursor =
+                (PtrXcursorLibraryLoadCursor) xcursorLib.resolve("XcursorLibraryLoadCursor");
+        }
+#else
+        X11->ptrXcursorLibraryLoadCursor = XcursorLibraryLoadCursor;
+#endif // QT_RUNTIME_XCURSOR
+#endif // QT_NO_XCURSOR
+
+#ifndef QT_NO_XSYNC
+        int xsync_evbase, xsync_errbase;
+        int major, minor;
+        if (XSyncQueryExtension(X11->display, &xsync_evbase, &xsync_errbase))
+            XSyncInitialize(X11->display, &major, &minor);
+#endif // QT_NO_XSYNC
+
+#ifndef QT_NO_XINERAMA
+#ifdef QT_RUNTIME_XINERAMA
+        X11->ptrXineramaQueryExtension = 0;
+        X11->ptrXineramaIsActive = 0;
+        X11->ptrXineramaQueryScreens = 0;
+        QLibrary xineramaLib(QLatin1String("Xinerama"), 1);
+        xineramaLib.setLoadHints(QLibrary::ImprovedSearchHeuristics);
+        bool xineramaFound = xineramaLib.load();
+        if (!xineramaFound) { //try without the version number
+            xineramaLib.setFileName(QLatin1String("Xinerama"));
+            xineramaFound = xineramaLib.load();
+        }
+        if (xineramaFound) {
+            X11->ptrXineramaQueryExtension =
+                (PtrXineramaQueryExtension) xineramaLib.resolve("XineramaQueryExtension");
+            X11->ptrXineramaIsActive =
+                (PtrXineramaIsActive) xineramaLib.resolve("XineramaIsActive");
+            X11->ptrXineramaQueryScreens =
+                (PtrXineramaQueryScreens) xineramaLib.resolve("XineramaQueryScreens");
+        }
+#else
+        X11->ptrXineramaQueryScreens = XineramaQueryScreens;
+        X11->ptrXineramaIsActive = XineramaIsActive;
+        X11->ptrXineramaQueryExtension = XineramaQueryExtension;
+#endif // QT_RUNTIME_XINERAMA
+#endif // QT_NO_XINERAMA
+
+#ifndef QT_NO_XINPUT
+        // See if Xinput is supported on the connected display
+        X11->ptrXCloseDevice = 0;
+        X11->ptrXListInputDevices = 0;
+        X11->ptrXOpenDevice = 0;
+        X11->ptrXFreeDeviceList = 0;
+        X11->ptrXSelectExtensionEvent = 0;
+        X11->use_xinput = XQueryExtension(X11->display, "XInputExtension", &X11->xinput_major,
+                                          &X11->xinput_eventbase, &X11->xinput_errorbase);
+        if (X11->use_xinput) {
+            X11->ptrXCloseDevice = XINPUT_LOAD(XCloseDevice);
+            X11->ptrXListInputDevices = XINPUT_LOAD(XListInputDevices);
+            X11->ptrXOpenDevice = XINPUT_LOAD(XOpenDevice);
+            X11->ptrXFreeDeviceList = XINPUT_LOAD(XFreeDeviceList);
+            X11->ptrXSelectExtensionEvent = XINPUT_LOAD(XSelectExtensionEvent);
+        }
+#endif // QT_NO_XINPUT
+
+#ifndef QT_NO_XKB
+        int xkblibMajor = XkbMajorVersion;
+        int xkblibMinor = XkbMinorVersion;
+        X11->use_xkb = XkbQueryExtension(X11->display,
+                                         &X11->xkb_major,
+                                         &X11->xkb_eventbase,
+                                         &X11->xkb_errorbase,
+                                         &xkblibMajor,
+                                         &xkblibMinor);
+        if (X11->use_xkb) {
+            // If XKB is detected, set the GrabsUseXKBState option so input method
+            // compositions continue to work (ie. deadkeys)
+            unsigned int state = XkbPCF_GrabsUseXKBStateMask;
+            (void) XkbSetPerClientControls(X11->display, state, &state);
+
+            // select for group change events
+            XkbSelectEventDetails(X11->display,
+                                  XkbUseCoreKbd,
+                                  XkbStateNotify,
+                                  XkbAllStateComponentsMask,
+                                  XkbGroupStateMask);
+
+            // current group state is queried when creating the keymapper, no need to do it here
+        }
+#endif
+
+
+#if !defined(QT_NO_FONTCONFIG)
+        int dpi = 0;
+        getXDefault("Xft", FC_DPI, &dpi);
+        if (dpi) {
+            for (int s = 0; s < ScreenCount(X11->display); ++s) {
+                QX11Info::setAppDpiX(s, dpi);
+                QX11Info::setAppDpiY(s, dpi);
+            }
+        }
+        double fc_scale = 1.;
+        getXDefault("Xft", FC_SCALE, &fc_scale);
+        X11->fc_scale = fc_scale;
+        for (int s = 0; s < ScreenCount(X11->display); ++s) {
+            int subpixel = FC_RGBA_UNKNOWN;
+#if !defined(QT_NO_XRENDER) && (RENDER_MAJOR > 0 || RENDER_MINOR >= 6)
+            if (X11->use_xrender) {
+                int rsp = XRenderQuerySubpixelOrder(X11->display, s);
+                switch (rsp) {
+                default:
+                case SubPixelUnknown:
+                    subpixel = FC_RGBA_UNKNOWN;
+                    break;
+                case SubPixelHorizontalRGB:
+                    subpixel = FC_RGBA_RGB;
+                    break;
+                case SubPixelHorizontalBGR:
+                    subpixel = FC_RGBA_BGR;
+                    break;
+                case SubPixelVerticalRGB:
+                    subpixel = FC_RGBA_VRGB;
+                    break;
+                case SubPixelVerticalBGR:
+                    subpixel = FC_RGBA_VBGR;
+                    break;
+                case SubPixelNone:
+                    subpixel = FC_RGBA_NONE;
+                    break;
+                }
+            }
+#endif
+
+            char *rgba = XGetDefault(X11->display, "Xft", FC_RGBA);
+            if (rgba) {
+                char *end = 0;
+                int v = strtol(rgba, &end, 0);
+                if (rgba != end) {
+                    subpixel = v;
+                } else if (qstrncmp(rgba, "unknown", 7) == 0) {
+                    subpixel = FC_RGBA_UNKNOWN;
+                } else if (qstrncmp(rgba, "rgb", 3) == 0) {
+                    subpixel = FC_RGBA_RGB;
+                } else if (qstrncmp(rgba, "bgr", 3) == 0) {
+                    subpixel = FC_RGBA_BGR;
+                } else if (qstrncmp(rgba, "vrgb", 4) == 0) {
+                    subpixel = FC_RGBA_VRGB;
+                } else if (qstrncmp(rgba, "vbgr", 4) == 0) {
+                    subpixel = FC_RGBA_VBGR;
+                } else if (qstrncmp(rgba, "none", 4) == 0) {
+                    subpixel = FC_RGBA_NONE;
+                }
+            }
+            X11->screens[s].subpixel = subpixel;
+        }
+        getXDefault("Xft", FC_ANTIALIAS, &X11->fc_antialias);
+#ifdef FC_HINT_STYLE
+        X11->fc_hint_style = -1;
+        getXDefault("Xft", FC_HINT_STYLE, &X11->fc_hint_style);
+#endif
+#if 0
+        // ###### these are implemented by Xft, not sure we need them
+        getXDefault("Xft", FC_AUTOHINT, &X11->fc_autohint);
+        getXDefault("Xft", FC_HINTING, &X11->fc_autohint);
+        getXDefault("Xft", FC_MINSPACE, &X11->fc_autohint);
+#endif
+#endif // QT_NO_XRENDER
+
+        // initialize key mapper
+        QKeyMapper::changeKeyboard();
+
+        // Misc. initialization
+#if 0 //disabled for now..
+        QSegfaultHandler::initialize(priv->argv, priv->argc);
+#endif
+        QCursorData::initialize();
+    }
+    QFont::initialize();
+
+    if(qt_is_gui_used) {
+        qApp->setObjectName(QString::fromLocal8Bit(appName));
+
+        int screen;
+        for (screen = 0; screen < X11->screenCount; ++screen) {
+            XSelectInput(X11->display, QX11Info::appRootWindow(screen),
+                         KeymapStateMask | EnterWindowMask | LeaveWindowMask | PropertyChangeMask);
+
+#ifndef QT_NO_XRANDR
+            if (X11->use_xrandr)
+                X11->ptrXRRSelectInput(X11->display, QX11Info::appRootWindow(screen), True);
+#endif // QT_NO_XRANDR
+        }
+    }
+
+    if (qt_is_gui_used) {
+        // Attempt to determine the current running X11 Desktop Enviornment
+        // Use dbus if/when we can, but fall back to using windowManagerName() for now
+
+#ifndef QT_NO_XFIXES
+        if (X11->ptrXFixesSelectSelectionInput)
+            X11->ptrXFixesSelectSelectionInput(X11->display, QX11Info::appRootWindow(), ATOM(_NET_WM_CM_S0),
+                                       XFixesSetSelectionOwnerNotifyMask
+                                       | XFixesSelectionWindowDestroyNotifyMask
+                                       | XFixesSelectionClientCloseNotifyMask);
+#endif // QT_NO_XFIXES
+        X11->compositingManagerRunning = XGetSelectionOwner(X11->display,
+                                                            ATOM(_NET_WM_CM_S0));
+        X11->desktopEnvironment = DE_UNKNOWN;
+        X11->desktopVersion = 0;
+
+        Atom type;
+        int format;
+        unsigned long length, after;
+        uchar *data = 0;
+        int rc;
+
+        do {
+            if (!qgetenv("KDE_FULL_SESSION").isEmpty()) {
+                X11->desktopEnvironment = DE_KDE;
+                X11->desktopVersion = qgetenv("KDE_SESSION_VERSION").toInt();
+                break;
+            }
+
+            if (qgetenv("DESKTOP_SESSION") == "gnome") {
+                X11->desktopEnvironment = DE_GNOME;
+                break;
+            }
+
+            // GNOME_DESKTOP_SESSION_ID is deprecated for some reason, but still check it
+            if (!qgetenv("GNOME_DESKTOP_SESSION_ID").isEmpty()) {
+                X11->desktopEnvironment = DE_GNOME;
+                break;
+            }
+
+            rc = XGetWindowProperty(X11->display, QX11Info::appRootWindow(), ATOM(_DT_SAVE_MODE),
+                                    0, 2, False, XA_STRING, &type, &format, &length,
+                                    &after, &data);
+            if (rc == Success && length) {
+                if (!strcmp(reinterpret_cast<char *>(data), "xfce4")) {
+                    // Pretend that xfce4 is gnome, as it uses the same libraries.
+                    // The detection above is stolen from xdg-open.
+                    X11->desktopEnvironment = DE_GNOME;
+                    break;
+                }
+
+                // We got the property but it wasn't xfce4. Free data before it gets overwritten.
+                XFree(data);
+                data = 0;
+            }
+
+            rc = XGetWindowProperty(X11->display, QX11Info::appRootWindow(), ATOM(DTWM_IS_RUNNING),
+                                    0, 1, False, AnyPropertyType, &type, &format, &length,
+                                    &after, &data);
+            if (rc == Success && length) {
+                // DTWM is running, meaning most likely CDE is running...
+                X11->desktopEnvironment = DE_CDE;
+                break;
+            }
+
+            rc = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                                    ATOM(_SGI_DESKS_MANAGER), 0, 1, False, XA_WINDOW,
+                                    &type, &format, &length, &after, &data);
+            if (rc == Success && length) {
+                X11->desktopEnvironment = DE_4DWM;
+                break;
+            }
+
+            if (XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                               ATOM(_NET_SUPPORTING_WM_CHECK),
+                               0, 1024, False, XA_WINDOW, &type,
+                               &format, &length, &after, &data) == Success) {
+                if (type == XA_WINDOW && format == 32) {
+                    Window windowManagerWindow = *((Window*) data);
+                    XFree(data);
+                    data = 0;
+
+                    if (windowManagerWindow != XNone) {
+                        Atom utf8atom = ATOM(UTF8_STRING);
+                        if (XGetWindowProperty(QX11Info::display(), windowManagerWindow, ATOM(_NET_WM_NAME),
+                                               0, 1024, False, utf8atom, &type,
+                                               &format, &length, &after, &data) == Success) {
+                            if (type == utf8atom && format == 8) {
+                                if (qstrcmp((const char *)data, "MCompositor") == 0)
+                                    X11->desktopEnvironment = DE_MEEGO_COMPOSITOR;
+                            }
+                        }
+                    }
+                }
+            }
+
+        } while(0);
+
+        if (data)
+            XFree((char *)data);
+
+#if !defined(QT_NO_STYLE_GTK)
+        if (X11->desktopEnvironment == DE_GNOME) {
+            static bool menusHaveIcons = QGtkStyle::getGConfBool(QLatin1String("/desktop/gnome/interface/menus_have_icons"), true);
+            QApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !menusHaveIcons);
+        }
+#endif
+        qt_set_input_encoding();
+
+        qt_set_x11_resources(appFont, appFGCol, appBGCol, appBTNCol);
+
+        // be smart about the size of the default font. most X servers have helvetica
+        // 12 point available at 2 resolutions:
+        //     75dpi (12 pixels) and 100dpi (17 pixels).
+        // At 95 DPI, a 12 point font should be 16 pixels tall - in which case a 17
+        // pixel font is a closer match than a 12 pixel font
+        int ptsz = (X11->use_xrender
+                    ? 9
+                    : (int) (((QX11Info::appDpiY() >= 95 ? 17. : 12.) *
+                              72. / (float) QX11Info::appDpiY()) + 0.5));
+
+        if (!QApplicationPrivate::sys_font) {
+            // no font from settings or RESOURCE_MANAGER, provide a fallback
+            QFont f(X11->has_fontconfig ? QLatin1String("Sans Serif") : QLatin1String("Helvetica"),
+                    ptsz);
+            QApplicationPrivate::setSystemFont(f);
+        }
+
+#if !defined (QT_NO_TABLET)
+        if (X11->use_xinput) {
+            int ndev,
+                i,
+                j;
+            bool gotStylus,
+                gotEraser;
+            XDeviceInfo *devices = 0, *devs;
+            XInputClassInfo *ip;
+            XAnyClassPtr any;
+            XValuatorInfoPtr v;
+            XAxisInfoPtr a;
+            XDevice *dev = 0;
+
+            if (X11->ptrXListInputDevices) {
+                devices = X11->ptrXListInputDevices(X11->display, &ndev);
+                if (!devices)
+                    qWarning("QApplication: Failed to get list of tablet devices");
+            }
+            if (!devices)
+                ndev = -1;
+            QTabletEvent::TabletDevice deviceType;
+            for (devs = devices, i = 0; i < ndev && devs; i++, devs++) {
+                dev = 0;
+                deviceType = QTabletEvent::NoDevice;
+                gotStylus = false;
+                gotEraser = false;
+
+#if defined(Q_OS_IRIX)
+                QString devName = QString::fromLocal8Bit(devs->name).toLower();
+                if (devName == QLatin1String(WACOM_NAME)) {
+                    deviceType = QTabletEvent::Stylus;
+                    gotStylus = true;
+                }
+#else
+                if (devs->type == ATOM(XWacomStylus) || devs->type == ATOM(XTabletStylus)) {
+                    deviceType = QTabletEvent::Stylus;
+                    if (wacomDeviceName()->isEmpty())
+                        wacomDeviceName()->append(devs->name);
+                    gotStylus = true;
+                } else if (devs->type == ATOM(XWacomEraser) || devs->type == ATOM(XTabletEraser)) {
+                    deviceType = QTabletEvent::XFreeEraser;
+                    gotEraser = true;
+                }
+#endif
+                if (deviceType == QTabletEvent::NoDevice)
+                    continue;
+
+                if (gotStylus || gotEraser) {
+                    if (X11->ptrXOpenDevice)
+                        dev = X11->ptrXOpenDevice(X11->display, devs->id);
+
+                    if (!dev)
+                        continue;
+
+                    QTabletDeviceData device_data;
+                    device_data.deviceType = deviceType;
+                    device_data.eventCount = 0;
+                    device_data.device = dev;
+                    device_data.xinput_motion = -1;
+                    device_data.xinput_key_press = -1;
+                    device_data.xinput_key_release = -1;
+                    device_data.xinput_button_press = -1;
+                    device_data.xinput_button_release = -1;
+                    device_data.xinput_proximity_in = -1;
+                    device_data.xinput_proximity_out = -1;
+                    device_data.widgetToGetPress = 0;
+
+                    if (dev->num_classes > 0) {
+                        for (ip = dev->classes, j = 0; j < dev->num_classes;
+                             ip++, j++) {
+                            switch (ip->input_class) {
+                            case KeyClass:
+                                DeviceKeyPress(dev, device_data.xinput_key_press,
+                                               device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                DeviceKeyRelease(dev, device_data.xinput_key_release,
+                                                 device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                break;
+                            case ButtonClass:
+                                DeviceButtonPress(dev, device_data.xinput_button_press,
+                                                  device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                DeviceButtonRelease(dev, device_data.xinput_button_release,
+                                                    device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                break;
+                            case ValuatorClass:
+                                // I'm only going to be interested in motion when the
+                                // stylus is already down anyway!
+                                DeviceMotionNotify(dev, device_data.xinput_motion,
+                                                   device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                ProximityIn(dev, device_data.xinput_proximity_in, device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                                ProximityOut(dev, device_data.xinput_proximity_out, device_data.eventList[device_data.eventCount]);
+                                if (device_data.eventList[device_data.eventCount])
+                                    ++device_data.eventCount;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+                    // get the min/max value for pressure!
+                    any = (XAnyClassPtr) (devs->inputclassinfo);
+                    for (j = 0; j < devs->num_classes; j++) {
+                        if (any->c_class == ValuatorClass) {
+                            v = (XValuatorInfoPtr) any;
+                            a = (XAxisInfoPtr) ((char *) v +
+                                                sizeof (XValuatorInfo));
+#if defined (Q_OS_IRIX)
+                            // I'm not exaclty wild about this, but the
+                            // dimensions of the tablet are more relevant here
+                            // than the min and max values from the axis
+                            // (actually it seems to be 2/3 or what is in the
+                            // axis.  So we'll try to parse it from this
+                            // string. --tws
+                            char returnString[SGIDeviceRtrnLen];
+                            int tmp;
+                            if (XSGIMiscQueryExtension(X11->display, &tmp, &tmp)
+                                && XSGIDeviceQuery(X11->display, devs->id,
+                                                   "dimensions", returnString)) {
+                                QString str = QLatin1String(returnString);
+                                int comma = str.indexOf(',');
+                                device_data.minX = 0;
+                                device_data.minY = 0;
+                                device_data.maxX = str.left(comma).toInt();
+                                device_data.maxY = str.mid(comma + 1).toInt();
+                            } else {
+                                device_data.minX = a[WAC_XCOORD_I].min_value;
+                                device_data.maxX = a[WAC_XCOORD_I].max_value;
+                                device_data.minY = a[WAC_YCOORD_I].min_value;
+                                device_data.maxY = a[WAC_YCOORD_I].max_value;
+                            }
+                            device_data.minPressure = a[WAC_PRESSURE_I].min_value;
+                            device_data.maxPressure = a[WAC_PRESSURE_I].max_value;
+                            device_data.minTanPressure = a[WAC_TAN_PRESSURE_I].min_value;
+                            device_data.maxTanPressure = a[WAC_TAN_PRESSURE_I].max_value;
+                            device_data.minZ = a[WAC_ZCOORD_I].min_value;
+                            device_data.maxZ = a[WAC_ZCOORD_I].max_value;
+#else
+                            device_data.minX = a[0].min_value;
+                            device_data.maxX = a[0].max_value;
+                            device_data.minY = a[1].min_value;
+                            device_data.maxY = a[1].max_value;
+                            device_data.minPressure = a[2].min_value;
+                            device_data.maxPressure = a[2].max_value;
+                            device_data.minTanPressure = 0;
+                            device_data.maxTanPressure = 0;
+                            device_data.minZ = 0;
+                            device_data.maxZ = 0;
+#endif
+
+                            // got the max pressure no need to go further...
+                            break;
+                        }
+                        any = (XAnyClassPtr) ((char *) any + any->length);
+                    } // end of for loop
+
+                    tablet_devices()->append(device_data);
+                } // if (gotStylus || gotEraser)
+            }
+            if (X11->ptrXFreeDeviceList)
+                X11->ptrXFreeDeviceList(devices);
+        }
+#endif // QT_NO_TABLET
+
+        X11->startupId = getenv("DESKTOP_STARTUP_ID");
+        if (X11->startupId) {
+#ifndef QT_NO_UNSETENV
+            unsetenv("DESKTOP_STARTUP_ID");
+#else
+            // it's a small memory leak, however we won't crash if Qt is
+            // unloaded and someones tries to use the envoriment.
+            putenv(strdup("DESKTOP_STARTUP_ID="));
+#endif
+        }
+   } else {
+        // read some non-GUI settings when not using the X server...
+
+        if (QApplication::desktopSettingsAware()) {
+            QSettings settings(QSettings::UserScope, QLatin1String("Trolltech"));
+            settings.beginGroup(QLatin1String("Qt"));
+
+            // read library (ie. plugin) path list
+            QString libpathkey = QString::fromLatin1("%1.%2/libraryPath")
+                                 .arg(QT_VERSION >> 16)
+                                 .arg((QT_VERSION & 0xff00) >> 8);
+            QStringList pathlist =
+                settings.value(libpathkey).toString().split(QLatin1Char(':'));
+            if (! pathlist.isEmpty()) {
+                QStringList::ConstIterator it = pathlist.constBegin();
+                while (it != pathlist.constEnd())
+                    QApplication::addLibraryPath(*it++);
+            }
+
+            QString defaultcodec = settings.value(QLatin1String("defaultCodec"),
+                                                  QVariant(QLatin1String("none"))).toString();
+            if (defaultcodec != QLatin1String("none")) {
+                QTextCodec *codec = QTextCodec::codecForName(defaultcodec.toLatin1());
+                if (codec)
+                    QTextCodec::setCodecForTr(codec);
+            }
+
+            settings.endGroup(); // Qt
+        }
+    }
+
+#if !defined (Q_OS_IRIX) && !defined (QT_NO_TABLET)
+    QLibrary wacom(QString::fromLatin1("wacomcfg"), 0); // version 0 is the latest release at time of writing this.
+    wacom.setLoadHints(QLibrary::ImprovedSearchHeuristics);
+    // NOTE: C casts instead of reinterpret_cast for GCC 3.3.x
+    ptrWacomConfigInit = (PtrWacomConfigInit)wacom.resolve("WacomConfigInit");
+    ptrWacomConfigOpenDevice = (PtrWacomConfigOpenDevice)wacom.resolve("WacomConfigOpenDevice");
+    ptrWacomConfigGetRawParam  = (PtrWacomConfigGetRawParam)wacom.resolve("WacomConfigGetRawParam");
+    ptrWacomConfigCloseDevice = (PtrWacomConfigCloseDevice)wacom.resolve("WacomConfigCloseDevice");
+    ptrWacomConfigTerm = (PtrWacomConfigTerm)wacom.resolve("WacomConfigTerm");
+
+    if (ptrWacomConfigInit == 0 || ptrWacomConfigOpenDevice == 0 || ptrWacomConfigGetRawParam == 0
+        || ptrWacomConfigCloseDevice == 0 || ptrWacomConfigTerm == 0) { // either we have all, or we have none.
+            ptrWacomConfigInit = 0;
+            ptrWacomConfigOpenDevice = 0;
+            ptrWacomConfigGetRawParam  = 0;
+            ptrWacomConfigCloseDevice = 0;
+            ptrWacomConfigTerm = 0;
+    }
+#endif
+}
+
+void QApplicationPrivate::initializeWidgetPaletteHash()
+{
+}
+
+/*****************************************************************************
+  qt_cleanup() - cleans up when the application is finished
+ *****************************************************************************/
+
+void qt_cleanup()
+{
+    if (app_save_rootinfo)                        // root window must keep state
+        qt_save_rootinfo();
+
+    if (qt_is_gui_used) {
+        QPixmapCache::clear();
+        QCursorData::cleanup();
+        QFont::cleanup();
+        QColormap::cleanup();
+
+#if !defined (QT_NO_TABLET)
+        QTabletDeviceDataList *devices = qt_tablet_devices();
+        if (X11->ptrXCloseDevice)
+            for (int i = 0; i < devices->size(); ++i)
+                X11->ptrXCloseDevice(X11->display, (XDevice*)devices->at(i).device);
+        devices->clear();
+#endif
+    }
+
+#ifndef QT_NO_XRENDER
+    for (int i = 0; i < X11->solid_fill_count; ++i) {
+        if (X11->solid_fills[i].picture)
+            XRenderFreePicture(X11->display, X11->solid_fills[i].picture);
+    }
+    for (int i = 0; i < X11->pattern_fill_count; ++i) {
+        if (X11->pattern_fills[i].picture)
+            XRenderFreePicture(X11->display, X11->pattern_fills[i].picture);
+    }
+#endif
+
+#if !defined(QT_NO_IM)
+    delete QApplicationPrivate::inputContext;
+    QApplicationPrivate::inputContext = 0;
+#endif
+
+    // Reset the error handlers
+    if (qt_is_gui_used)
+        XSync(X11->display, False); // sync first to process all possible errors
+    XSetErrorHandler(original_x_errhandler);
+    XSetIOErrorHandler(original_xio_errhandler);
+
+    if (X11->argbColormaps) {
+        for (int s = 0; s < X11->screenCount; s++) {
+            if (X11->argbColormaps[s])
+                XFreeColormap(X11->display, X11->argbColormaps[s]);
+        }
+    }
+
+    if (qt_is_gui_used && !X11->foreignDisplay)
+        XCloseDisplay(X11->display);                // close X display
+    X11->display = 0;
+
+    delete [] X11->screens;
+    delete [] X11->argbVisuals;
+    delete [] X11->argbColormaps;
+
+    if (X11->foreignDisplay) {
+        delete [] (char *)appName;
+        appName = 0;
+    }
+
+    delete [] (char *)appClass;
+    appClass = 0;
+
+    if (X11->net_supported_list)
+        delete [] X11->net_supported_list;
+    X11->net_supported_list = 0;
+
+    if (X11->net_virtual_root_list)
+        delete [] X11->net_virtual_root_list;
+    X11->net_virtual_root_list = 0;
+
+    delete X11;
+    X11 = 0;
+}
+
+
+/*****************************************************************************
+  Platform specific global and internal functions
+ *****************************************************************************/
+
+void qt_save_rootinfo()                                // save new root info
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data = 0;
+
+    if (ATOM(_XSETROOT_ID)) {                        // kill old pixmap
+        if (XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                                 ATOM(_XSETROOT_ID), 0, 1,
+                                 True, AnyPropertyType, &type, &format,
+                                 &length, &after, &data) == Success) {
+            if (type == XA_PIXMAP && format == 32 && length == 1 &&
+                 after == 0 && data) {
+                XKillClient(X11->display, *((Pixmap*)data));
+            }
+            Pixmap dummy = XCreatePixmap(X11->display, QX11Info::appRootWindow(),
+                                          1, 1, 1);
+            XChangeProperty(X11->display, QX11Info::appRootWindow(),
+                             ATOM(_XSETROOT_ID), XA_PIXMAP, 32,
+                             PropModeReplace, (uchar *)&dummy, 1);
+            XSetCloseDownMode(X11->display, RetainPermanent);
+        }
+    }
+    if (data)
+        XFree((char *)data);
+}
+
+void qt_updated_rootinfo()
+{
+    app_save_rootinfo = true;
+}
+
+// ### Cleanup, this function is not in use!
+bool qt_wstate_iconified(WId winid)
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data = 0;
+    int r = XGetWindowProperty(X11->display, winid, ATOM(WM_STATE), 0, 2,
+                                 False, AnyPropertyType, &type, &format,
+                                 &length, &after, &data);
+    bool iconic = false;
+    if (r == Success && data && format == 32) {
+        // quint32 *wstate = (quint32*)data;
+        unsigned long *wstate = (unsigned long *) data;
+        iconic = (*wstate == IconicState);
+        XFree((char *)data);
+    }
+    return iconic;
+}
+
+QString QApplicationPrivate::appName() const
+{
+    return QString::fromLocal8Bit(QT_PREPEND_NAMESPACE(appName));
+}
+
+const char *QX11Info::appClass()                                // get application class
+{
+    return QT_PREPEND_NAMESPACE(appClass);
+}
+
+bool qt_nograb()                                // application no-grab option
+{
+#if defined(QT_DEBUG)
+    return appNoGrab;
+#else
+    return false;
+#endif
+}
+
+
+/*****************************************************************************
+  Platform specific QApplication members
+ *****************************************************************************/
+
+#ifdef QT3_SUPPORT
+void QApplication::setMainWidget(QWidget *mainWidget)
+{
+#ifndef QT_NO_DEBUG
+    if (mainWidget && mainWidget->parentWidget() && mainWidget->isWindow())
+        qWarning("QApplication::setMainWidget: New main widget (%s/%s) "
+                  "has a parent",
+                  mainWidget->metaObject()->className(), mainWidget->objectName().toLocal8Bit().constData());
+#endif
+    if (mainWidget)
+        mainWidget->d_func()->createWinId();
+    QApplicationPrivate::main_widget = mainWidget;
+    if (QApplicationPrivate::main_widget) // give WM command line
+        QApplicationPrivate::applyX11SpecificCommandLineArguments(QApplicationPrivate::main_widget);
+}
+#endif
+
+void QApplicationPrivate::applyX11SpecificCommandLineArguments(QWidget *main_widget)
+{
+    static bool beenHereDoneThat = false;
+    if (beenHereDoneThat)
+        return;
+    beenHereDoneThat = true;
+    Q_ASSERT(main_widget->testAttribute(Qt::WA_WState_Created));
+    if (mwTitle) {
+        XStoreName(X11->display, main_widget->effectiveWinId(), (char*)mwTitle);
+        QByteArray net_wm_name = QString::fromLocal8Bit(mwTitle).toUtf8();
+        XChangeProperty(X11->display, main_widget->effectiveWinId(), ATOM(_NET_WM_NAME), ATOM(UTF8_STRING), 8,
+                        PropModeReplace, (unsigned char *)net_wm_name.data(), net_wm_name.size());
+    }
+    if (mwGeometry) { // parse geometry
+        int x, y;
+        int w, h;
+        int m = XParseGeometry((char*)mwGeometry, &x, &y, (uint*)&w, (uint*)&h);
+        QSize minSize = main_widget->minimumSize();
+        QSize maxSize = main_widget->maximumSize();
+        if ((m & XValue) == 0)
+            x = main_widget->geometry().x();
+        if ((m & YValue) == 0)
+            y = main_widget->geometry().y();
+        if ((m & WidthValue) == 0)
+            w = main_widget->width();
+        if ((m & HeightValue) == 0)
+            h = main_widget->height();
+        w = qMin(w,maxSize.width());
+        h = qMin(h,maxSize.height());
+        w = qMax(w,minSize.width());
+        h = qMax(h,minSize.height());
+        if ((m & XNegative)) {
+            x = QApplication::desktop()->width()  + x - w;
+        }
+        if ((m & YNegative)) {
+            y = QApplication::desktop()->height() + y - h;
+        }
+        main_widget->setGeometry(x, y, w, h);
+    }
+}
+
+#ifndef QT_NO_CURSOR
+
+/*****************************************************************************
+  QApplication cursor stack
+ *****************************************************************************/
+
+void QApplication::setOverrideCursor(const QCursor &cursor)
+{
+    qApp->d_func()->cursor_list.prepend(cursor);
+
+    QWidgetList all = allWidgets();
+    for (QWidgetList::ConstIterator it = all.constBegin(); it != all.constEnd(); ++it) {
+        register QWidget *w = *it;
+        if ((w->testAttribute(Qt::WA_SetCursor) || w->isWindow()) && (w->windowType() != Qt::Desktop))
+            qt_x11_enforce_cursor(w);
+    }
+    XFlush(X11->display);                                // make X execute it NOW
+}
+
+void QApplication::restoreOverrideCursor()
+{
+    if (qApp->d_func()->cursor_list.isEmpty())
+        return;
+    qApp->d_func()->cursor_list.removeFirst();
+
+    if (QWidgetPrivate::mapper != 0 && !closingDown()) {
+        QWidgetList all = allWidgets();
+        for (QWidgetList::ConstIterator it = all.constBegin(); it != all.constEnd(); ++it) {
+            register QWidget *w = *it;
+            if ((w->testAttribute(Qt::WA_SetCursor) || w->isWindow()) && (w->windowType() != Qt::Desktop))
+                qt_x11_enforce_cursor(w);
+        }
+        XFlush(X11->display);
+    }
+}
+
+#endif
+
+
+/*****************************************************************************
+  Routines to find a Qt widget from a screen position
+ *****************************************************************************/
+
+Window QX11Data::findClientWindow(Window win, Atom property, bool leaf)
+{
+    Atom   type = XNone;
+    int           format, i;
+    ulong  nitems, after;
+    uchar *data = 0;
+    Window root, parent, target=0, *children=0;
+    uint   nchildren;
+    if (XGetWindowProperty(X11->display, win, property, 0, 0, false, AnyPropertyType,
+                             &type, &format, &nitems, &after, &data) == Success) {
+        if (data)
+            XFree((char *)data);
+        if (type)
+            return win;
+    }
+    if (!XQueryTree(X11->display,win,&root,&parent,&children,&nchildren)) {
+        if (children)
+            XFree((char *)children);
+        return 0;
+    }
+    for (i=nchildren-1; !target && i >= 0; i--)
+        target = X11->findClientWindow(children[i], property, leaf);
+    if (children)
+        XFree((char *)children);
+    return target;
+}
+
+QWidget *QApplication::topLevelAt(const QPoint &p)
+{
+#ifdef QT_NO_CURSOR
+    Q_UNUSED(p);
+    return 0;
+#else
+    int screen = QCursor::x11Screen();
+    int unused;
+
+    int x = p.x();
+    int y = p.y();
+    Window target;
+    if (!XTranslateCoordinates(X11->display,
+                               QX11Info::appRootWindow(screen),
+                               QX11Info::appRootWindow(screen),
+                               x, y, &unused, &unused, &target)) {
+        return 0;
+    }
+    if (!target || target == QX11Info::appRootWindow(screen))
+        return 0;
+    QWidget *w;
+    w = QWidget::find((WId)target);
+
+    if (!w) {
+        X11->ignoreBadwindow();
+        target = X11->findClientWindow(target, ATOM(WM_STATE), true);
+        if (X11->badwindow())
+            return 0;
+        w = QWidget::find((WId)target);
+        if (!w) {
+            // Perhaps the widget at (x,y) is inside a foreign application?
+            // Search all toplevel widgets to see if one is within target
+            QWidgetList list = QApplication::topLevelWidgets();
+            for (int i = 0; i < list.count(); ++i) {
+                QWidget *widget = list.at(i);
+                Window ctarget = target;
+                if (widget->isVisible() && !(widget->windowType() == Qt::Desktop)) {
+                    Q_ASSERT(widget->testAttribute(Qt::WA_WState_Created));
+                    Window wid = widget->internalWinId();
+                    while (ctarget && !w) {
+                        X11->ignoreBadwindow();
+                        if (!XTranslateCoordinates(X11->display,
+                                                   QX11Info::appRootWindow(screen),
+                                                   ctarget, x, y, &unused, &unused, &ctarget)
+                                || X11->badwindow())
+                            break;
+                        if (ctarget == wid) {
+                            // Found!
+                            w = widget;
+                            break;
+                        }
+                    }
+                }
+                if (w)
+                    break;
+            }
+        }
+    }
+    return w ? w->window() : 0;
+#endif
+}
+
+void QApplication::syncX()
+{
+    if (X11->display)
+        XSync(X11->display, False);  // don't discard events
+}
+
+
+void QApplication::beep()
+{
+    if (X11->display)
+        XBell(X11->display, 0);
+    else
+        printf("\7");
+}
+
+void QApplication::alert(QWidget *widget, int msec)
+{
+    if (!QApplicationPrivate::checkInstance("alert"))
+        return;
+
+    QWidgetList windowsToMark;
+    if (!widget) {
+        windowsToMark += topLevelWidgets();
+    } else {
+        windowsToMark.append(widget->window());
+    }
+
+    for (int i = 0; i < windowsToMark.size(); ++i) {
+        QWidget *window = windowsToMark.at(i);
+        if (!window->isActiveWindow()) {
+            qt_change_net_wm_state(window, true, ATOM(_NET_WM_STATE_DEMANDS_ATTENTION));
+            if (msec != 0) {
+                QTimer *timer = new QTimer(qApp);
+                timer->setSingleShot(true);
+                connect(timer, SIGNAL(timeout()), qApp, SLOT(_q_alertTimeOut()));
+                if (QTimer *oldTimer = qApp->d_func()->alertTimerHash.value(window)) {
+                    qApp->d_func()->alertTimerHash.remove(window);
+                    delete oldTimer;
+                }
+                qApp->d_func()->alertTimerHash.insert(window, timer);
+                timer->start(msec);
+            }
+        }
+    }
+}
+
+void QApplicationPrivate::_q_alertTimeOut()
+{
+    if (QTimer *timer = qobject_cast<QTimer *>(q_func()->sender())) {
+        QHash<QWidget *, QTimer *>::iterator it = alertTimerHash.begin();
+        while (it != alertTimerHash.end()) {
+            if (it.value() == timer) {
+                QWidget *window = it.key();
+                qt_change_net_wm_state(window, false, ATOM(_NET_WM_STATE_DEMANDS_ATTENTION));
+                alertTimerHash.erase(it);
+                timer->deleteLater();
+                break;
+            }
+            ++it;
+        }
+    }
+}
+
+Qt::KeyboardModifiers QApplication::queryKeyboardModifiers()
+{
+    Window root;
+    Window child;
+    int root_x, root_y, win_x, win_y;
+    uint keybstate;
+    for (int i = 0; i < ScreenCount(X11->display); ++i) {
+        if (XQueryPointer(X11->display, QX11Info::appRootWindow(i), &root, &child,
+                          &root_x, &root_y, &win_x, &win_y, &keybstate))
+            return X11->translateModifiers(keybstate & 0x00ff);
+    }
+    return 0;
+
+}
+
+/*****************************************************************************
+  Special lookup functions for windows that have been reparented recently
+ *****************************************************************************/
+
+static QWidgetMapper *wPRmapper = 0;                // alternative widget mapper
+
+void qPRCreate(const QWidget *widget, Window oldwin)
+{                                                // QWidget::reparent mechanism
+    if (!wPRmapper)
+        wPRmapper = new QWidgetMapper;
+
+    QETWidget *w = static_cast<QETWidget *>(const_cast<QWidget *>(widget));
+    wPRmapper->insert((int)oldwin, w);        // add old window to mapper
+    w->setAttribute(Qt::WA_WState_Reparented);        // set reparented flag
+}
+
+void qPRCleanup(QWidget *widget)
+{
+    QETWidget *etw = static_cast<QETWidget *>(const_cast<QWidget *>(widget));
+    if (!(wPRmapper && widget->testAttribute(Qt::WA_WState_Reparented)))
+        return;                                        // not a reparented widget
+    QWidgetMapper::Iterator it = wPRmapper->begin();
+    while (it != wPRmapper->constEnd()) {
+        QWidget *w = *it;
+        if (w == etw) {                       // found widget
+            etw->setAttribute(Qt::WA_WState_Reparented, false); // clear flag
+            it = wPRmapper->erase(it);// old window no longer needed
+        } else {
+            ++it;
+        }
+    }
+    if (wPRmapper->size() == 0) {        // became empty
+        delete wPRmapper;                // then reset alt mapper
+        wPRmapper = 0;
+    }
+}
+
+static QETWidget *qPRFindWidget(Window oldwin)
+{
+    return wPRmapper ? (QETWidget*)wPRmapper->value((int)oldwin, 0) : 0;
+}
+
+int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)
+{
+    if (w && !w->internalWinId())
+        return 0;
+    QETWidget *widget = (QETWidget*)w;
+    if (event->xclient.format == 32 && event->xclient.message_type) {
+        if (event->xclient.message_type == ATOM(WM_PROTOCOLS)) {
+            Atom a = event->xclient.data.l[0];
+            if (a == ATOM(WM_DELETE_WINDOW)) {
+                if (passive_only) return 0;
+                widget->translateCloseEvent(event);
+            }
+            else if (a == ATOM(WM_TAKE_FOCUS)) {
+                if ((ulong) event->xclient.data.l[1] > X11->time)
+                    X11->time = event->xclient.data.l[1];
+                QWidget *amw = activeModalWidget();
+                if (amw && amw->testAttribute(Qt::WA_X11DoNotAcceptFocus))
+                    amw = 0;
+                if (amw && !QApplicationPrivate::tryModalHelper(widget, 0)) {
+                    QWidget *p = amw->parentWidget();
+                    while (p && p != widget)
+                        p = p->parentWidget();
+                    if (!p || !X11->net_supported_list)
+                        amw->raise(); // help broken window managers
+                    amw->activateWindow();
+                }
+#ifndef QT_NO_WHATSTHIS
+            } else if (a == ATOM(_NET_WM_CONTEXT_HELP)) {
+                QWhatsThis::enterWhatsThisMode();
+#endif // QT_NO_WHATSTHIS
+            } else if (a == ATOM(_NET_WM_PING)) {
+                // avoid send/reply loops
+                Window root = RootWindow(X11->display, w->x11Info().screen());
+                if (event->xclient.window != root) {
+                    event->xclient.window = root;
+                    XSendEvent(event->xclient.display, event->xclient.window,
+                                False, SubstructureNotifyMask|SubstructureRedirectMask, event);
+                }
+#ifndef QT_NO_XSYNC
+            } else if (a == ATOM(_NET_WM_SYNC_REQUEST)) {
+                const ulong timestamp = (const ulong) event->xclient.data.l[1];
+                if (timestamp > X11->time)
+                    X11->time = timestamp;
+                if (QTLWExtra *tlw = w->d_func()->maybeTopData()) {
+                    if (timestamp == CurrentTime || timestamp > tlw->syncRequestTimestamp) {
+                        tlw->syncRequestTimestamp = timestamp;
+                        tlw->newCounterValueLo = event->xclient.data.l[2];
+                        tlw->newCounterValueHi = event->xclient.data.l[3];
+                    }
+                }
+#endif
+            }
+        } else if (event->xclient.message_type == ATOM(_QT_SCROLL_DONE)) {
+            widget->translateScrollDoneEvent(event);
+        } else if (event->xclient.message_type == ATOM(XdndPosition)) {
+            X11->xdndHandlePosition(widget, event, passive_only);
+        } else if (event->xclient.message_type == ATOM(XdndEnter)) {
+            X11->xdndHandleEnter(widget, event, passive_only);
+        } else if (event->xclient.message_type == ATOM(XdndStatus)) {
+            X11->xdndHandleStatus(widget, event, passive_only);
+        } else if (event->xclient.message_type == ATOM(XdndLeave)) {
+            X11->xdndHandleLeave(widget, event, passive_only);
+        } else if (event->xclient.message_type == ATOM(XdndDrop)) {
+            X11->xdndHandleDrop(widget, event, passive_only);
+        } else if (event->xclient.message_type == ATOM(XdndFinished)) {
+            X11->xdndHandleFinished(widget, event, passive_only);
+        } else {
+            if (passive_only) return 0;
+            // All other are interactions
+        }
+    } else {
+        X11->motifdndHandle(widget, event, passive_only);
+    }
+
+    return 0;
+}
+
+int QApplication::x11ProcessEvent(XEvent* event)
+{
+    Q_D(QApplication);
+    QScopedLoopLevelCounter loopLevelCounter(d->threadData);
+
+#ifdef ALIEN_DEBUG
+    //qDebug() << "QApplication::x11ProcessEvent:" << event->type;
+#endif
+    switch (event->type) {
+    case ButtonPress:
+        pressed_window = event->xbutton.window;
+        X11->userTime = event->xbutton.time;
+        // fallthrough intended
+    case ButtonRelease:
+        X11->time = event->xbutton.time;
+        break;
+    case MotionNotify:
+        X11->time = event->xmotion.time;
+        break;
+    case XKeyPress:
+        X11->userTime = event->xkey.time;
+        // fallthrough intended
+    case XKeyRelease:
+        X11->time = event->xkey.time;
+        break;
+    case PropertyNotify:
+        X11->time = event->xproperty.time;
+        break;
+    case EnterNotify:
+    case LeaveNotify:
+        X11->time = event->xcrossing.time;
+        break;
+    case SelectionClear:
+        X11->time = event->xselectionclear.time;
+        break;
+    default:
+        break;
+    }
+#ifndef QT_NO_XFIXES
+    if (X11->use_xfixes && event->type == (X11->xfixes_eventbase + XFixesSelectionNotify)) {
+        XFixesSelectionNotifyEvent *req =
+            reinterpret_cast<XFixesSelectionNotifyEvent *>(event);
+        X11->time = req->selection_timestamp;
+        if (req->selection == ATOM(_NET_WM_CM_S0))
+            X11->compositingManagerRunning = req->owner;
+    }
+#endif
+
+    QETWidget *widget = (QETWidget*)QWidget::find((WId)event->xany.window);
+
+    if (wPRmapper) {                                // just did a widget reparent?
+        if (widget == 0) {                        // not in std widget mapper
+            switch (event->type) {                // only for mouse/key events
+            case ButtonPress:
+            case ButtonRelease:
+            case MotionNotify:
+            case XKeyPress:
+            case XKeyRelease:
+                widget = qPRFindWidget(event->xany.window);
+                break;
+            }
+        }
+        else if (widget->testAttribute(Qt::WA_WState_Reparented))
+            qPRCleanup(widget);                // remove from alt mapper
+    }
+
+    QETWidget *keywidget=0;
+    bool grabbed=false;
+    if (event->type==XKeyPress || event->type==XKeyRelease) {
+        keywidget = (QETWidget*)QWidget::keyboardGrabber();
+        if (keywidget) {
+            grabbed = true;
+        } else if (!keywidget) {
+            if (d->inPopupMode()) // no focus widget, see if we have a popup
+                keywidget = (QETWidget*) (activePopupWidget()->focusWidget() ? activePopupWidget()->focusWidget() : activePopupWidget());
+            else if (QApplicationPrivate::focus_widget)
+                keywidget = (QETWidget*)QApplicationPrivate::focus_widget;
+            else if (widget)
+                keywidget = (QETWidget*)widget->window();
+        }
+    }
+
+#ifndef QT_NO_IM
+    // Filtering input events by the input context. It has to be taken
+    // place before any other key event consumers such as eventfilters
+    // and accelerators because some input methods require quite
+    // various key combination and sequences. It often conflicts with
+    // accelerators and so on, so we must give the input context the
+    // filtering opportunity first to ensure all input methods work
+    // properly regardless of application design.
+
+    if(keywidget && keywidget->isEnabled() && keywidget->testAttribute(Qt::WA_InputMethodEnabled)) {
+        // block user interaction during session management
+	if((event->type==XKeyPress || event->type==XKeyRelease) && qt_sm_blockUserInput)
+	    return true;
+
+        // for XIM handling
+	QInputContext *qic = keywidget->inputContext();
+	if(qic && qic->x11FilterEvent(keywidget, event))
+	    return true;
+
+	// filterEvent() accepts QEvent *event rather than preexpanded
+	// key event attribute values. This is intended to pass other
+	// QInputEvent in future. Other non IM-related events should
+	// not be forwarded to input contexts to prevent weird event
+	// handling.
+	if ((event->type == XKeyPress || event->type == XKeyRelease)) {
+	    int code = -1;
+	    int count = 0;
+	    Qt::KeyboardModifiers modifiers;
+	    QEvent::Type type;
+	    QString text;
+            KeySym keySym;
+
+            qt_keymapper_private()->translateKeyEventInternal(keywidget, event, keySym, count,
+                                                              text, modifiers, code, type, false);
+
+	    // both key press/release is required for some complex
+	    // input methods. don't eliminate anything.
+	    QKeyEventEx keyevent(type, code, modifiers, text, false, qMax(qMax(count, 1), text.length()),
+                                 event->xkey.keycode, keySym, event->xkey.state);
+	    if(qic && qic->filterEvent(&keyevent))
+		return true;
+	}
+    } else
+#endif // QT_NO_IM
+        {
+            if (XFilterEvent(event, XNone))
+                return true;
+        }
+
+    if (qt_x11EventFilter(event))                // send through app filter
+        return 1;
+
+    if (event->type == MappingNotify) {
+        // keyboard mapping changed
+        XRefreshKeyboardMapping(&event->xmapping);
+
+        QKeyMapper::changeKeyboard();
+        return 0;
+    }
+#ifndef QT_NO_XKB
+    else if (X11->use_xkb && event->type == X11->xkb_eventbase) {
+        XkbAnyEvent *xkbevent = (XkbAnyEvent *) event;
+        switch (xkbevent->xkb_type) {
+        case XkbStateNotify:
+            {
+                XkbStateNotifyEvent *xkbstateevent = (XkbStateNotifyEvent *) xkbevent;
+                if ((xkbstateevent->changed & XkbGroupStateMask) != 0) {
+                    qt_keymapper_private()->xkb_currentGroup = xkbstateevent->group;
+                    QKeyMapper::changeKeyboard();
+                }
+                break;
+            }
+        default:
+            break;
+        }
+    }
+#endif
+
+    if (!widget) {                                // don't know this windows
+        QWidget* popup = QApplication::activePopupWidget();
+        if (popup) {
+
+            /*
+              That is more than suboptimal. The real solution should
+              do some keyevent and buttonevent translation, so that
+              the popup still continues to work as the user expects.
+              Unfortunately this translation is currently only
+              possible with a known widget. I'll change that soon
+              (Matthias).
+            */
+
+            // Danger - make sure we don't lock the server
+            switch (event->type) {
+            case ButtonPress:
+            case ButtonRelease:
+            case XKeyPress:
+            case XKeyRelease:
+                do {
+                    popup->close();
+                } while ((popup = qApp->activePopupWidget()));
+                return 1;
+            }
+        }
+        return -1;
+    }
+
+    if (event->type == XKeyPress || event->type == XKeyRelease)
+        widget = keywidget; // send XKeyEvents through keywidget->x11Event()
+
+    if (app_do_modal)                                // modal event handling
+        if (!qt_try_modal(widget, event)) {
+            if (event->type == ClientMessage && !widget->x11Event(event))
+                x11ClientMessage(widget, event, true);
+            return 1;
+        }
+
+
+    if (widget->x11Event(event))                // send through widget filter
+        return 1;
+#if !defined (QT_NO_TABLET)
+    if (!qt_xdnd_dragging) {
+        QTabletDeviceDataList *tablets = qt_tablet_devices();
+        for (int i = 0; i < tablets->size(); ++i) {
+            QTabletDeviceData &tab = tablets->operator [](i);
+            if (event->type == tab.xinput_motion
+            || event->type == tab.xinput_button_release
+            || event->type == tab.xinput_button_press
+            || event->type == tab.xinput_proximity_in
+            || event->type == tab.xinput_proximity_out) {
+                widget->translateXinputEvent(event, &tab);
+                return 0;
+            }
+        }
+    }
+#endif
+
+#ifndef QT_NO_XRANDR
+    if (X11->use_xrandr && event->type == (X11->xrandr_eventbase + RRScreenChangeNotify)) {
+        // update Xlib internals with the latest screen configuration
+        X11->ptrXRRUpdateConfiguration(event);
+
+        // update the size for desktop widget
+        int scr = X11->ptrXRRRootToScreen(X11->display, event->xany.window);
+        QDesktopWidget *desktop = QApplication::desktop();
+        QWidget *w = desktop->screen(scr);
+        QSize oldSize(w->size());
+        w->data->crect.setWidth(DisplayWidth(X11->display, scr));
+        w->data->crect.setHeight(DisplayHeight(X11->display, scr));
+        QResizeEvent e(w->size(), oldSize);
+        QApplication::sendEvent(w, &e);
+        if (w != desktop)
+            QApplication::sendEvent(desktop, &e);
+    }
+#endif // QT_NO_XRANDR
+
+#ifndef QT_NO_XFIXES
+    if (X11->use_xfixes && event->type == (X11->xfixes_eventbase + XFixesSelectionNotify)) {
+        XFixesSelectionNotifyEvent *req = reinterpret_cast<XFixesSelectionNotifyEvent *>(event);
+
+        // compress all XFixes events related to this selection
+        // we don't want to handle old SelectionNotify events.
+        qt_xfixes_selection_event_data xfixes_event;
+        xfixes_event.selection = req->selection;
+        for (XEvent ev;;) {
+            if (!XCheckIfEvent(X11->display, &ev, &qt_xfixes_scanner, (XPointer)&xfixes_event))
+                break;
+        }
+
+        if (req->selection == ATOM(CLIPBOARD)) {
+            if (qt_xfixes_clipboard_changed(req->owner, req->selection_timestamp)) {
+                emit clipboard()->changed(QClipboard::Clipboard);
+                emit clipboard()->dataChanged();
+            }
+        } else if (req->selection == XA_PRIMARY) {
+            if (qt_xfixes_selection_changed(req->owner, req->selection_timestamp)) {
+                emit clipboard()->changed(QClipboard::Selection);
+                emit clipboard()->selectionChanged();
+            }
+        }
+    }
+#endif // QT_NO_XFIXES
+
+    switch (event->type) {
+
+    case ButtonRelease:                        // mouse event
+        if (!d->inPopupMode() && !QWidget::mouseGrabber() && pressed_window != widget->internalWinId()
+            && (widget = (QETWidget*) QWidget::find((WId)pressed_window)) == 0)
+            break;
+        // fall through intended
+    case ButtonPress:
+        if (event->xbutton.root != RootWindow(X11->display, widget->x11Info().screen())
+            && ! qt_xdnd_dragging) {
+            while (activePopupWidget())
+                activePopupWidget()->close();
+            return 1;
+        }
+        if (event->type == ButtonPress)
+            qt_net_update_user_time(widget->window(), X11->userTime);
+        // fall through intended
+    case MotionNotify:
+#if !defined(QT_NO_TABLET)
+        if (!qt_tabletChokeMouse) {
+#endif
+            if (widget->testAttribute(Qt::WA_TransparentForMouseEvents)) {
+                QPoint pos(event->xbutton.x, event->xbutton.y);
+                pos = widget->d_func()->mapFromWS(pos);
+                QWidget *window = widget->window();
+                pos = widget->mapTo(window, pos);
+                if (QWidget *child = window->childAt(pos)) {
+                    widget = static_cast<QETWidget *>(child);
+                    pos = child->mapFrom(window, pos);
+                    event->xbutton.x = pos.x();
+                    event->xbutton.y = pos.y();
+                }
+            }
+            widget->translateMouseEvent(event);
+#if !defined(QT_NO_TABLET)
+        } else {
+            qt_tabletChokeMouse = false;
+        }
+#endif
+        break;
+
+    case XKeyPress:                                // keyboard event
+        qt_net_update_user_time(widget->window(), X11->userTime);
+        // fallthrough intended
+    case XKeyRelease:
+        {
+            if (keywidget && keywidget->isEnabled()) { // should always exist
+                // qDebug("sending key event");
+                qt_keymapper_private()->translateKeyEvent(keywidget, event, grabbed);
+            }
+            break;
+        }
+
+    case GraphicsExpose:
+    case Expose:                                // paint event
+        widget->translatePaintEvent(event);
+        break;
+
+    case ConfigureNotify:                        // window move/resize event
+        if (event->xconfigure.event == event->xconfigure.window)
+            widget->translateConfigEvent(event);
+        break;
+
+    case XFocusIn: {                                // got focus
+        if ((widget->windowType() == Qt::Desktop))
+            break;
+        if (d->inPopupMode()) // some delayed focus event to ignore
+            break;
+        if (!widget->isWindow())
+            break;
+        if (event->xfocus.detail != NotifyAncestor &&
+            event->xfocus.detail != NotifyInferior &&
+            event->xfocus.detail != NotifyNonlinear)
+            break;
+        setActiveWindow(widget);
+        if (X11->focus_model == QX11Data::FM_PointerRoot) {
+            // We got real input focus from somewhere, but we were in PointerRoot
+            // mode, so we don't trust this event.  Check the focus model to make
+            // sure we know what focus mode we are using...
+            qt_check_focus_model();
+        }
+    }
+        break;
+
+    case XFocusOut:                                // lost focus
+        if ((widget->windowType() == Qt::Desktop))
+            break;
+        if (!widget->isWindow())
+            break;
+        if (event->xfocus.mode == NotifyGrab) {
+            qt_xfocusout_grab_counter++;
+            break;
+        }
+        if (event->xfocus.detail != NotifyAncestor &&
+            event->xfocus.detail != NotifyNonlinearVirtual &&
+            event->xfocus.detail != NotifyNonlinear)
+            break;
+        if (!d->inPopupMode() && widget == QApplicationPrivate::active_window) {
+            XEvent ev;
+            bool focus_will_change = false;
+            if (XCheckTypedEvent(X11->display, XFocusIn, &ev)) {
+                // we're about to get an XFocusIn, if we know we will
+                // get a new active window, we don't want to set the
+                // active window to 0 now
+                QWidget *w2 = QWidget::find(ev.xany.window);
+                if (w2
+                    && w2->windowType() != Qt::Desktop
+                    && !d->inPopupMode() // some delayed focus event to ignore
+                    && w2->isWindow()
+                    && (ev.xfocus.detail == NotifyAncestor
+                        || ev.xfocus.detail == NotifyInferior
+                        || ev.xfocus.detail == NotifyNonlinear))
+                    focus_will_change = true;
+
+                XPutBackEvent(X11->display, &ev);
+            }
+            if (!focus_will_change)
+                setActiveWindow(0);
+        }
+        break;
+
+    case EnterNotify: {                        // enter window
+        if (QWidget::mouseGrabber() && (!d->inPopupMode() || widget->window() != activePopupWidget()))
+            break;
+        if ((event->xcrossing.mode != NotifyNormal
+             && event->xcrossing.mode != NotifyUngrab)
+            || event->xcrossing.detail == NotifyVirtual
+            || event->xcrossing.detail == NotifyNonlinearVirtual)
+            break;
+        if (event->xcrossing.focus &&
+            !(widget->windowType() == Qt::Desktop) && !widget->isActiveWindow()) {
+            if (X11->focus_model == QX11Data::FM_Unknown) // check focus model
+                qt_check_focus_model();
+            if (X11->focus_model == QX11Data::FM_PointerRoot) // PointerRoot mode
+                setActiveWindow(widget);
+        }
+
+        if (qt_button_down && !d->inPopupMode())
+            break;
+
+        QWidget *alien = widget->childAt(widget->d_func()->mapFromWS(QPoint(event->xcrossing.x,
+                                                                            event->xcrossing.y)));
+        QWidget *enter = alien ? alien : widget;
+        QWidget *leave = 0;
+        if (qt_last_mouse_receiver && !qt_last_mouse_receiver->internalWinId())
+            leave = qt_last_mouse_receiver;
+        else
+            leave = QWidget::find(curWin);
+
+        // ### Alien: enter/leave might be wrong here with overlapping siblings
+        // if the enter widget is native and stacked under a non-native widget.
+        QApplicationPrivate::dispatchEnterLeave(enter, leave);
+        curWin = widget->internalWinId();
+        qt_last_mouse_receiver = enter;
+        if (!d->inPopupMode() || widget->window() == activePopupWidget())
+            widget->translateMouseEvent(event); //we don't get MotionNotify, emulate it
+    }
+        break;
+    case LeaveNotify: {                        // leave window
+        QWidget *mouseGrabber = QWidget::mouseGrabber();
+        if (mouseGrabber && !d->inPopupMode())
+            break;
+        if (curWin && widget->internalWinId() != curWin)
+            break;
+        if ((event->xcrossing.mode != NotifyNormal
+            && event->xcrossing.mode != NotifyUngrab)
+            || event->xcrossing.detail == NotifyInferior)
+            break;
+        if (!(widget->windowType() == Qt::Desktop))
+            widget->translateMouseEvent(event); //we don't get MotionNotify, emulate it
+
+        QWidget* enter = 0;
+        QPoint enterPoint;
+        XEvent ev;
+        while (XCheckMaskEvent(X11->display, EnterWindowMask | LeaveWindowMask , &ev)
+               && !qt_x11EventFilter(&ev)) {
+            QWidget* event_widget = QWidget::find(ev.xcrossing.window);
+            if(event_widget && event_widget->x11Event(&ev))
+                break;
+            if (ev.type == LeaveNotify
+                || (ev.xcrossing.mode != NotifyNormal
+                    && ev.xcrossing.mode != NotifyUngrab)
+                || ev.xcrossing.detail == NotifyVirtual
+                || ev.xcrossing.detail == NotifyNonlinearVirtual)
+                continue;
+            enter = event_widget;
+            if (enter)
+                enterPoint = enter->d_func()->mapFromWS(QPoint(ev.xcrossing.x, ev.xcrossing.y));
+            if (ev.xcrossing.focus &&
+                enter && !(enter->windowType() == Qt::Desktop) && !enter->isActiveWindow()) {
+                if (X11->focus_model == QX11Data::FM_Unknown) // check focus model
+                    qt_check_focus_model();
+                if (X11->focus_model == QX11Data::FM_PointerRoot) // PointerRoot mode
+                    setActiveWindow(enter);
+            }
+            break;
+        }
+
+        if ((! enter || (enter->windowType() == Qt::Desktop)) &&
+            event->xcrossing.focus && widget == QApplicationPrivate::active_window &&
+            X11->focus_model == QX11Data::FM_PointerRoot // PointerRoot mode
+            ) {
+            setActiveWindow(0);
+        }
+
+        if (qt_button_down && !d->inPopupMode())
+            break;
+
+        if (!curWin)
+            QApplicationPrivate::dispatchEnterLeave(widget, 0);
+
+        if (enter) {
+            QWidget *alienEnter = enter->childAt(enterPoint);
+            if (alienEnter)
+                enter = alienEnter;
+        }
+
+        QWidget *leave = qt_last_mouse_receiver ? qt_last_mouse_receiver : widget;
+        QWidget *activePopupWidget = qApp->activePopupWidget();
+
+        if (mouseGrabber && activePopupWidget && leave == activePopupWidget)
+            enter = mouseGrabber;
+        else if (enter != widget && mouseGrabber) {
+            if (!widget->rect().contains(widget->d_func()->mapFromWS(QPoint(event->xcrossing.x,
+                                                                            event->xcrossing.y))))
+                break;
+        }
+
+        QApplicationPrivate::dispatchEnterLeave(enter, leave);
+        qt_last_mouse_receiver = enter;
+
+        if (enter && QApplicationPrivate::tryModalHelper(enter, 0)) {
+            QWidget *nativeEnter = enter->internalWinId() ? enter : enter->nativeParentWidget();
+            curWin = nativeEnter->internalWinId();
+            static_cast<QETWidget *>(nativeEnter)->translateMouseEvent(&ev); //we don't get MotionNotify, emulate it
+        } else {
+            curWin = 0;
+            qt_last_mouse_receiver = 0;
+        }
+    }
+        break;
+
+    case UnmapNotify:                                // window hidden
+        if (widget->isWindow()) {
+            Q_ASSERT(widget->testAttribute(Qt::WA_WState_Created));
+            widget->d_func()->topData()->waitingForMapNotify = 0;
+
+            if (widget->windowType() != Qt::Popup && !widget->testAttribute(Qt::WA_DontShowOnScreen)) {
+                widget->setAttribute(Qt::WA_Mapped, false);
+                if (widget->isVisible()) {
+                    widget->d_func()->topData()->spont_unmapped = 1;
+                    QHideEvent e;
+                    QApplication::sendSpontaneousEvent(widget, &e);
+                    widget->d_func()->hideChildren(true);
+                }
+            }
+
+            if (!widget->d_func()->topData()->validWMState && X11->deferred_map.removeAll(widget))
+                widget->doDeferredMap();
+        }
+        break;
+
+    case MapNotify:                                // window shown
+        if (widget->isWindow()) {
+            // if we got a MapNotify when we were not waiting for it, it most
+            // likely means the user has already asked to hide the window before
+            // it ever being shown, so we try to withdraw a window after sending
+            // the QShowEvent.
+            bool pendingHide = widget->testAttribute(Qt::WA_WState_ExplicitShowHide) && widget->testAttribute(Qt::WA_WState_Hidden);
+            widget->d_func()->topData()->waitingForMapNotify = 0;
+
+            if (widget->windowType() != Qt::Popup) {
+                widget->setAttribute(Qt::WA_Mapped);
+                if (widget->d_func()->topData()->spont_unmapped) {
+                    widget->d_func()->topData()->spont_unmapped = 0;
+                    widget->d_func()->showChildren(true);
+                    QShowEvent e;
+                    QApplication::sendSpontaneousEvent(widget, &e);
+
+                    // show() must have been called on this widget in
+                    // order to reach this point, but we could have
+                    // cleared these 2 attributes in case something
+                    // previously forced us into WithdrawnState
+                    // (e.g. kdocker)
+                    widget->setAttribute(Qt::WA_WState_ExplicitShowHide, true);
+                    widget->setAttribute(Qt::WA_WState_Visible, true);
+                }
+            }
+            if (pendingHide) // hide the window
+                XWithdrawWindow(X11->display, widget->internalWinId(), widget->x11Info().screen());
+        }
+        break;
+
+    case ClientMessage:                        // client message
+        return x11ClientMessage(widget,event,False);
+
+    case ReparentNotify: {                      // window manager reparents
+        // compress old reparent events to self
+        XEvent ev;
+        while (XCheckTypedWindowEvent(X11->display,
+                                      widget->effectiveWinId(),
+                                      ReparentNotify,
+                                      &ev)) {
+            if (ev.xreparent.window != ev.xreparent.event) {
+                XPutBackEvent(X11->display, &ev);
+                break;
+            }
+        }
+        if (widget->isWindow()) {
+            QTLWExtra *topData = widget->d_func()->topData();
+
+            // store the parent. Useful for many things, embedding for instance.
+            topData->parentWinId = event->xreparent.parent;
+
+            // the widget frame strut should also be invalidated
+            widget->data->fstrut_dirty = 1;
+
+            // work around broken window managers... if we get a
+            // ReparentNotify before the MapNotify, we assume that
+            // we're being managed by a reparenting window
+            // manager.
+            //
+            // however, the WM_STATE property may not have been set
+            // yet, but we are going to assume that it will
+            // be... otherwise we could try to map again after getting
+            // an UnmapNotify... which could then, in turn, trigger a
+            // race in the window manager which causes the window to
+            // disappear when it really should be hidden.
+            if (topData->waitingForMapNotify && !topData->validWMState) {
+                topData->waitingForMapNotify = 0;
+                topData->validWMState = 1;
+            }
+
+            if (X11->focus_model != QX11Data::FM_Unknown) {
+                // toplevel reparented...
+                QWidget *newparent = QWidget::find(event->xreparent.parent);
+                if (! newparent || (newparent->windowType() == Qt::Desktop)) {
+                    // we don't know about the new parent (or we've been
+                    // reparented to root), perhaps a window manager
+                    // has been (re)started?  reset the focus model to unknown
+                    X11->focus_model = QX11Data::FM_Unknown;
+                }
+            }
+        }
+        break;
+    }
+    case SelectionRequest: {
+        XSelectionRequestEvent *req = &event->xselectionrequest;
+        if (! req)
+            break;
+
+        if (ATOM(XdndSelection) && req->selection == ATOM(XdndSelection)) {
+            X11->xdndHandleSelectionRequest(req);
+
+        } else if (qt_clipboard) {
+            QClipboardEvent e(reinterpret_cast<QEventPrivate*>(event));
+            QApplication::sendSpontaneousEvent(qt_clipboard, &e);
+        }
+        break;
+    }
+    case SelectionClear: {
+        XSelectionClearEvent *req = &event->xselectionclear;
+        // don't deliver dnd events to the clipboard, it gets confused
+        if (! req || (ATOM(XdndSelection) && req->selection == ATOM(XdndSelection)))
+            break;
+
+        if (qt_clipboard && !X11->use_xfixes) {
+            QClipboardEvent e(reinterpret_cast<QEventPrivate*>(event));
+            QApplication::sendSpontaneousEvent(qt_clipboard, &e);
+        }
+        break;
+    }
+
+    case SelectionNotify: {
+        XSelectionEvent *req = &event->xselection;
+        // don't deliver dnd events to the clipboard, it gets confused
+        if (! req || (ATOM(XdndSelection) && req->selection == ATOM(XdndSelection)))
+            break;
+
+        if (qt_clipboard) {
+            QClipboardEvent e(reinterpret_cast<QEventPrivate*>(event));
+            QApplication::sendSpontaneousEvent(qt_clipboard, &e);
+        }
+        break;
+    }
+    case PropertyNotify:
+        // some properties changed
+        if (event->xproperty.window == QX11Info::appRootWindow(0)) {
+            // root properties for the first screen
+            if (!X11->use_xfixes && event->xproperty.atom == ATOM(_QT_CLIPBOARD_SENTINEL)) {
+                if (qt_check_clipboard_sentinel()) {
+                    emit clipboard()->changed(QClipboard::Clipboard);
+                    emit clipboard()->dataChanged();
+                }
+            } else if (!X11->use_xfixes && event->xproperty.atom == ATOM(_QT_SELECTION_SENTINEL)) {
+                if (qt_check_selection_sentinel()) {
+                    emit clipboard()->changed(QClipboard::Selection);
+                    emit clipboard()->selectionChanged();
+                }
+            } else if (QApplicationPrivate::obey_desktop_settings) {
+                if (event->xproperty.atom == ATOM(RESOURCE_MANAGER))
+                    qt_set_x11_resources();
+                else if (event->xproperty.atom == ATOM(_QT_SETTINGS_TIMESTAMP))
+                    qt_set_x11_resources();
+            }
+        }
+        if (event->xproperty.window == QX11Info::appRootWindow()) {
+            // root properties for the default screen
+            if (event->xproperty.atom == ATOM(_QT_INPUT_ENCODING)) {
+                qt_set_input_encoding();
+            } else if (event->xproperty.atom == ATOM(_NET_SUPPORTED)) {
+                qt_get_net_supported();
+            } else if (event->xproperty.atom == ATOM(_NET_VIRTUAL_ROOTS)) {
+                qt_get_net_virtual_roots();
+            } else if (event->xproperty.atom == ATOM(_NET_WORKAREA)) {
+                qt_desktopwidget_update_workarea();
+
+                // emit the workAreaResized() signal
+                QDesktopWidget *desktop = QApplication::desktop();
+                int numScreens = desktop->numScreens();
+                for (int i = 0; i < numScreens; ++i)
+                    emit desktop->workAreaResized(i);
+            }
+        } else if (widget) {
+            widget->translatePropertyEvent(event);
+        }  else {
+            return -1; // don't know this window
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+bool QApplication::x11EventFilter(XEvent *)
+{
+    return false;
+}
+
+
+
+/*****************************************************************************
+  Modal widgets; Since Xlib has little support for this we roll our own
+  modal widget mechanism.
+  A modal widget without a parent becomes application-modal.
+  A modal widget with a parent becomes modal to its parent and grandparents..
+
+  QApplicationPrivate::enterModal()
+        Enters modal state
+        Arguments:
+            QWidget *widget        A modal widget
+
+  QApplicationPrivate::leaveModal()
+        Leaves modal state for a widget
+        Arguments:
+            QWidget *widget        A modal widget
+ *****************************************************************************/
+
+bool QApplicationPrivate::modalState()
+{
+    return app_do_modal;
+}
+
+void QApplicationPrivate::enterModal_sys(QWidget *widget)
+{
+    if (!qt_modal_stack)
+        qt_modal_stack = new QWidgetList;
+
+    QWidget *leave = qt_last_mouse_receiver;
+    if (!leave)
+        leave = QWidget::find((WId)curWin);
+    QApplicationPrivate::dispatchEnterLeave(0, leave);
+    qt_modal_stack->insert(0, widget);
+    app_do_modal = true;
+    curWin = 0;
+    qt_last_mouse_receiver = 0;
+}
+
+void QApplicationPrivate::leaveModal_sys(QWidget *widget)
+{
+    if (qt_modal_stack && qt_modal_stack->removeAll(widget)) {
+        if (qt_modal_stack->isEmpty()) {
+            delete qt_modal_stack;
+            qt_modal_stack = 0;
+            QPoint p(QCursor::pos());
+            QWidget* w = QApplication::widgetAt(p.x(), p.y());
+            QWidget *leave = qt_last_mouse_receiver;
+            if (!leave)
+                leave = QWidget::find((WId)curWin);
+            if (QWidget *grabber = QWidget::mouseGrabber()) {
+                w = grabber;
+                if (leave == w)
+                    leave = 0;
+            }
+            QApplicationPrivate::dispatchEnterLeave(w, leave); // send synthetic enter event
+            curWin = w ? w->effectiveWinId() : 0;
+            qt_last_mouse_receiver = w;
+        }
+    }
+    app_do_modal = qt_modal_stack != 0;
+}
+
+bool qt_try_modal(QWidget *widget, XEvent *event)
+{
+    if (qt_xdnd_dragging) {
+        // allow mouse events while DnD is active
+        switch (event->type) {
+        case ButtonPress:
+        case ButtonRelease:
+        case MotionNotify:
+            return true;
+        default:
+            break;
+        }
+    }
+
+    // allow mouse release events to be sent to widgets that have been pressed
+    if (event->type == ButtonRelease) {
+        QWidget *alienWidget = widget->childAt(widget->mapFromGlobal(QPoint(event->xbutton.x_root,
+                                                                            event->xbutton.y_root)));
+        if (widget == qt_button_down || (alienWidget && alienWidget == qt_button_down))
+            return true;
+    }
+
+    if (QApplicationPrivate::tryModalHelper(widget))
+        return true;
+
+    // disallow mouse/key events
+    switch (event->type) {
+    case ButtonPress:
+    case ButtonRelease:
+    case MotionNotify:
+    case XKeyPress:
+    case XKeyRelease:
+    case EnterNotify:
+    case LeaveNotify:
+    case ClientMessage:
+        return false;
+    default:
+        break;
+    }
+
+    return true;
+}
+
+
+/*****************************************************************************
+  Popup widget mechanism
+
+  openPopup()
+        Adds a widget to the list of popup widgets
+        Arguments:
+            QWidget *widget        The popup widget to be added
+
+  closePopup()
+        Removes a widget from the list of popup widgets
+        Arguments:
+            QWidget *widget        The popup widget to be removed
+ *****************************************************************************/
+
+
+static int openPopupCount = 0;
+void QApplicationPrivate::openPopup(QWidget *popup)
+{
+    Q_Q(QApplication);
+    openPopupCount++;
+    if (!QApplicationPrivate::popupWidgets) {                        // create list
+        QApplicationPrivate::popupWidgets = new QWidgetList;
+    }
+    QApplicationPrivate::popupWidgets->append(popup);                // add to end of list
+    Display *dpy = X11->display;
+    if (QApplicationPrivate::popupWidgets->count() == 1 && !qt_nograb()){ // grab mouse/keyboard
+        Q_ASSERT(popup->testAttribute(Qt::WA_WState_Created));
+        int r = XGrabKeyboard(dpy, popup->effectiveWinId(), false,
+                              GrabModeAsync, GrabModeAsync, X11->time);
+        if ((popupGrabOk = (r == GrabSuccess))) {
+            r = XGrabPointer(dpy, popup->effectiveWinId(), true,
+                             (ButtonPressMask | ButtonReleaseMask | ButtonMotionMask
+                              | EnterWindowMask | LeaveWindowMask | PointerMotionMask),
+                             GrabModeAsync, GrabModeAsync, XNone, XNone, X11->time);
+            if (!(popupGrabOk = (r == GrabSuccess))) {
+                // transfer grab back to the keyboard grabber if any
+                if (QWidgetPrivate::keyboardGrabber != 0)
+                    QWidgetPrivate::keyboardGrabber->grabKeyboard();
+                else
+                    XUngrabKeyboard(dpy, X11->time);
+            }
+        }
+    }
+
+    // popups are not focus-handled by the window system (the first
+    // popup grabbed the keyboard), so we have to do that manually: A
+    // new popup gets the focus
+    if (popup->focusWidget()) {
+        popup->focusWidget()->setFocus(Qt::PopupFocusReason);
+    } else if (QApplicationPrivate::popupWidgets->count() == 1) { // this was the first popup
+        if (QWidget *fw = QApplication::focusWidget()) {
+            QFocusEvent e(QEvent::FocusOut, Qt::PopupFocusReason);
+            q->sendEvent(fw, &e);
+        }
+    }
+}
+
+void QApplicationPrivate::closePopup(QWidget *popup)
+{
+    Q_Q(QApplication);
+    if (!QApplicationPrivate::popupWidgets)
+        return;
+    QApplicationPrivate::popupWidgets->removeAll(popup);
+    if (popup == qt_popup_down) {
+        qt_button_down = 0;
+        qt_popup_down = 0;
+    }
+    if (QApplicationPrivate::popupWidgets->count() == 0) {                // this was the last popup
+        delete QApplicationPrivate::popupWidgets;
+        QApplicationPrivate::popupWidgets = 0;
+        if (!qt_nograb() && popupGrabOk) {        // grabbing not disabled
+            Display *dpy = X11->display;
+            if (popup->geometry().contains(QPoint(mouseGlobalXPos, mouseGlobalYPos))
+                || popup->testAttribute(Qt::WA_NoMouseReplay)) {
+                // mouse release event or inside
+                replayPopupMouseEvent = false;
+            } else {                                // mouse press event
+                mouseButtonPressTime -= 10000;        // avoid double click
+                replayPopupMouseEvent = true;
+            }
+            // transfer grab back to mouse grabber if any, otherwise release the grab
+            if (QWidgetPrivate::mouseGrabber != 0)
+                QWidgetPrivate::mouseGrabber->grabMouse();
+            else
+                XUngrabPointer(dpy, X11->time);
+
+            // transfer grab back to keyboard grabber if any, otherwise release the grab
+            if (QWidgetPrivate::keyboardGrabber != 0)
+                QWidgetPrivate::keyboardGrabber->grabKeyboard();
+            else
+                XUngrabKeyboard(dpy, X11->time);
+
+            XFlush(dpy);
+        }
+        if (QApplicationPrivate::active_window) {
+            if (QWidget *fw = QApplicationPrivate::active_window->focusWidget()) {
+                if (fw != QApplication::focusWidget()) {
+                    fw->setFocus(Qt::PopupFocusReason);
+                } else {
+                    QFocusEvent e(QEvent::FocusIn, Qt::PopupFocusReason);
+                    q->sendEvent(fw, &e);
+                }
+            }
+        }
+    } else {
+        // popups are not focus-handled by the window system (the
+        // first popup grabbed the keyboard), so we have to do that
+        // manually: A popup was closed, so the previous popup gets
+        // the focus.
+        QWidget* aw = QApplicationPrivate::popupWidgets->last();
+        if (QWidget *fw = aw->focusWidget())
+            fw->setFocus(Qt::PopupFocusReason);
+
+        // regrab the keyboard and mouse in case 'popup' lost the grab
+        if (QApplicationPrivate::popupWidgets->count() == 1 && !qt_nograb()){ // grab mouse/keyboard
+            Display *dpy = X11->display;
+            Q_ASSERT(aw->testAttribute(Qt::WA_WState_Created));
+            int r = XGrabKeyboard(dpy, aw->effectiveWinId(), false,
+                                  GrabModeAsync, GrabModeAsync, X11->time);
+            if ((popupGrabOk = (r == GrabSuccess))) {
+                r = XGrabPointer(dpy, aw->effectiveWinId(), true,
+                                 (ButtonPressMask | ButtonReleaseMask | ButtonMotionMask
+                                  | EnterWindowMask | LeaveWindowMask | PointerMotionMask),
+                                 GrabModeAsync, GrabModeAsync, XNone, XNone, X11->time);
+                if (!(popupGrabOk = (r == GrabSuccess))) {
+                    // transfer grab back to keyboard grabber
+                    if (QWidgetPrivate::keyboardGrabber != 0)
+                        QWidgetPrivate::keyboardGrabber->grabKeyboard();
+                    else
+                        XUngrabKeyboard(dpy, X11->time);
+                }
+            }
+        }
+    }
+}
+
+/*****************************************************************************
+  Event translation; translates X11 events to Qt events
+ *****************************************************************************/
+
+//
+// Mouse event translation
+//
+// Xlib doesn't give mouse double click events, so we generate them by
+// comparing window, time and position between two mouse press events.
+//
+
+static Qt::MouseButtons translateMouseButtons(int s)
+{
+    Qt::MouseButtons ret = 0;
+    if (s & Button1Mask)
+        ret |= Qt::LeftButton;
+    if (s & Button2Mask)
+        ret |= Qt::MidButton;
+    if (s & Button3Mask)
+        ret |= Qt::RightButton;
+    return ret;
+}
+
+Qt::KeyboardModifiers QX11Data::translateModifiers(int s)
+{
+    Qt::KeyboardModifiers ret = 0;
+    if (s & ShiftMask)
+        ret |= Qt::ShiftModifier;
+    if (s & ControlMask)
+        ret |= Qt::ControlModifier;
+    if (s & qt_alt_mask)
+        ret |= Qt::AltModifier;
+    if (s & qt_meta_mask)
+        ret |= Qt::MetaModifier;
+    if (s & qt_mode_switch_mask)
+        ret |= Qt::GroupSwitchModifier;
+    return ret;
+}
+
+bool QETWidget::translateMouseEvent(const XEvent *event)
+{
+    if (!isWindow() && testAttribute(Qt::WA_NativeWindow))
+        Q_ASSERT(internalWinId());
+
+    Q_D(QWidget);
+    QEvent::Type type;                                // event parameters
+    QPoint pos;
+    QPoint globalPos;
+    Qt::MouseButton button = Qt::NoButton;
+    Qt::MouseButtons buttons;
+    Qt::KeyboardModifiers modifiers;
+    XEvent nextEvent;
+
+    if (qt_sm_blockUserInput) // block user interaction during session management
+        return true;
+
+    if (event->type == MotionNotify) { // mouse move
+        if (event->xmotion.root != RootWindow(X11->display, x11Info().screen()) &&
+            ! qt_xdnd_dragging)
+            return false;
+
+        XMotionEvent lastMotion = event->xmotion;
+        while(XPending(X11->display))  { // compress mouse moves
+            XNextEvent(X11->display, &nextEvent);
+            if (nextEvent.type == ConfigureNotify
+                || nextEvent.type == PropertyNotify
+                || nextEvent.type == Expose
+                || nextEvent.type == GraphicsExpose
+                || nextEvent.type == NoExpose
+                || nextEvent.type == KeymapNotify
+                || ((nextEvent.type == EnterNotify || nextEvent.type == LeaveNotify)
+                    && qt_button_down == this)
+                || (nextEvent.type == ClientMessage
+                    && (nextEvent.xclient.message_type == ATOM(_QT_SCROLL_DONE) ||
+                    (nextEvent.xclient.message_type == ATOM(WM_PROTOCOLS) &&
+                     (Atom)nextEvent.xclient.data.l[0] == ATOM(_NET_WM_SYNC_REQUEST))))) {
+                // Pass the event through the event dispatcher filter so that applications
+                // which install an event filter on the dispatcher get to handle it first.
+                if (!QAbstractEventDispatcher::instance()->filterEvent(&nextEvent))
+                    qApp->x11ProcessEvent(&nextEvent);
+                continue;
+            } else if (nextEvent.type != MotionNotify ||
+                       nextEvent.xmotion.window != event->xmotion.window ||
+                       nextEvent.xmotion.state != event->xmotion.state) {
+                XPutBackEvent(X11->display, &nextEvent);
+                break;
+            }
+            if (!qt_x11EventFilter(&nextEvent)
+                && !x11Event(&nextEvent)) // send event through filter
+                lastMotion = nextEvent.xmotion;
+            else
+                break;
+        }
+        type = QEvent::MouseMove;
+        pos.rx() = lastMotion.x;
+        pos.ry() = lastMotion.y;
+        pos = d->mapFromWS(pos);
+        globalPos.rx() = lastMotion.x_root;
+        globalPos.ry() = lastMotion.y_root;
+        buttons = translateMouseButtons(lastMotion.state);
+        modifiers = X11->translateModifiers(lastMotion.state);
+        if (qt_button_down && !buttons)
+            qt_button_down = 0;
+    } else if (event->type == EnterNotify || event->type == LeaveNotify) {
+        XEvent *xevent = (XEvent *)event;
+        //unsigned int xstate = event->xcrossing.state;
+        type = QEvent::MouseMove;
+        pos.rx() = xevent->xcrossing.x;
+        pos.ry() = xevent->xcrossing.y;
+        pos = d->mapFromWS(pos);
+        globalPos.rx() = xevent->xcrossing.x_root;
+        globalPos.ry() = xevent->xcrossing.y_root;
+        buttons = translateMouseButtons(xevent->xcrossing.state);
+        modifiers = X11->translateModifiers(xevent->xcrossing.state);
+        if (qt_button_down && !buttons)
+            qt_button_down = 0;
+        if (qt_button_down)
+            return true;
+    } else {                                        // button press or release
+        pos.rx() = event->xbutton.x;
+        pos.ry() = event->xbutton.y;
+        pos = d->mapFromWS(pos);
+        globalPos.rx() = event->xbutton.x_root;
+        globalPos.ry() = event->xbutton.y_root;
+        buttons = translateMouseButtons(event->xbutton.state);
+        modifiers = X11->translateModifiers(event->xbutton.state);
+        switch (event->xbutton.button) {
+        case Button1: button = Qt::LeftButton; break;
+        case Button2: button = Qt::MidButton; break;
+        case Button3: button = Qt::RightButton; break;
+        case Button4:
+        case Button5:
+        case 6:
+        case 7:
+            // the fancy mouse wheel.
+
+            // We are only interested in ButtonPress.
+            if (event->type == ButtonPress){
+                // compress wheel events (the X Server will simply
+                // send a button press for each single notch,
+                // regardless whether the application can catch up
+                // or not)
+                int delta = 1;
+                XEvent xevent;
+                while (XCheckTypedWindowEvent(X11->display, effectiveWinId(), ButtonPress, &xevent)){
+                    if (xevent.xbutton.button != event->xbutton.button){
+                        XPutBackEvent(X11->display, &xevent);
+                        break;
+                    }
+                    delta++;
+                }
+
+                // the delta is defined as multiples of
+                // WHEEL_DELTA, which is set to 120. Future wheels
+                // may offer a finer-resolution. A positive delta
+                // indicates forward rotation, a negative one
+                // backward rotation respectively.
+                int btn = event->xbutton.button;
+                delta *= 120 * ((btn == Button4 || btn == 6) ? 1 : -1);
+                bool hor = (((btn == Button4 || btn == Button5) && (modifiers & Qt::AltModifier)) ||
+                            (btn == 6 || btn == 7));
+                translateWheelEvent(globalPos.x(), globalPos.y(), delta, buttons,
+                                    modifiers, (hor) ? Qt::Horizontal: Qt::Vertical);
+            }
+            return true;
+        case 8: button = Qt::XButton1; break;
+        case 9: button = Qt::XButton2; break;
+        }
+        if (event->type == ButtonPress) {        // mouse button pressed
+            buttons |= button;
+#if defined(Q_OS_IRIX) && !defined(QT_NO_TABLET)
+            QTabletDeviceDataList *tablets = qt_tablet_devices();
+            for (int i = 0; i < tablets->size(); ++i) {
+                QTabletDeviceData &tab = tablets->operator[](i);
+                XEvent myEv;
+                if (XCheckTypedEvent(X11->display, tab.xinput_button_press, &myEv)) {
+                        if (translateXinputEvent(&myEv, &tab)) {
+                            //Spontaneous event sent.  Check if we need to continue.
+                            if (qt_tabletChokeMouse) {
+                                qt_tabletChokeMouse = false;
+                                return false;
+                            }
+                        }
+                }
+            }
+#endif
+            if (!qt_button_down) {
+                qt_button_down = childAt(pos);        //magic for masked widgets
+                if (!qt_button_down)
+                    qt_button_down = this;
+            }
+            if (mouseActWindow == event->xbutton.window &&
+                mouseButtonPressed == button &&
+                (long)event->xbutton.time -(long)mouseButtonPressTime
+                < QApplication::doubleClickInterval() &&
+                qAbs(event->xbutton.x - mouseXPos) < QT_GUI_DOUBLE_CLICK_RADIUS &&
+                qAbs(event->xbutton.y - mouseYPos) < QT_GUI_DOUBLE_CLICK_RADIUS) {
+                type = QEvent::MouseButtonDblClick;
+                mouseButtonPressTime -= 2000;        // no double-click next time
+            } else {
+                type = QEvent::MouseButtonPress;
+                mouseButtonPressTime = event->xbutton.time;
+            }
+            mouseButtonPressed = button;        // save event params for
+            mouseXPos = event->xbutton.x;                // future double click tests
+            mouseYPos = event->xbutton.y;
+            mouseGlobalXPos = globalPos.x();
+            mouseGlobalYPos = globalPos.y();
+        } else {                                // mouse button released
+            buttons &= ~button;
+#if defined(Q_OS_IRIX) && !defined(QT_NO_TABLET)
+            QTabletDeviceDataList *tablets = qt_tablet_devices();
+            for (int i = 0; i < tablets->size(); ++i) {
+                QTabletDeviceData &tab = tablets->operator[](i);
+                XEvent myEv;
+                if (XCheckTypedEvent(X11->display, tab.xinput_button_press, &myEv)) {
+                        if (translateXinputEvent(&myEv, &tab)) {
+                            //Spontaneous event sent.  Check if we need to continue.
+                            if (qt_tabletChokeMouse) {
+                                qt_tabletChokeMouse = false;
+                                return false;
+                            }
+                        }
+                }
+            }
+#endif
+            type = QEvent::MouseButtonRelease;
+        }
+    }
+    mouseActWindow = effectiveWinId();                        // save some event params
+    mouseButtonState = buttons;
+    if (type == 0)                                // don't send event
+        return false;
+
+    if (qApp->d_func()->inPopupMode()) {                        // in popup mode
+        QWidget *activePopupWidget = qApp->activePopupWidget();
+        QWidget *popup = qApp->activePopupWidget();
+        if (popup != this) {
+            if (event->type == LeaveNotify)
+                return false;
+            if ((windowType() == Qt::Popup) && rect().contains(pos) && 0)
+                popup = this;
+            else                                // send to last popup
+                pos = popup->mapFromGlobal(globalPos);
+        }
+        bool releaseAfter = false;
+        QWidget *popupChild  = popup->childAt(pos);
+
+        if (popup != qt_popup_down){
+            qt_button_down = 0;
+            qt_popup_down = 0;
+        }
+
+        switch (type) {
+        case QEvent::MouseButtonPress:
+        case QEvent::MouseButtonDblClick:
+            qt_button_down = popupChild;
+            qt_popup_down = popup;
+            break;
+        case QEvent::MouseButtonRelease:
+            releaseAfter = true;
+            break;
+        default:
+            break;                                // nothing for mouse move
+        }
+
+        int oldOpenPopupCount = openPopupCount;
+
+        if (popup->isEnabled()) {
+            // deliver event
+            replayPopupMouseEvent = false;
+            QWidget *receiver = popup;
+            QPoint widgetPos = pos;
+            if (qt_button_down)
+                receiver = qt_button_down;
+            else if (popupChild)
+                receiver = popupChild;
+            if (receiver != popup)
+                widgetPos = receiver->mapFromGlobal(globalPos);
+            QWidget *alien = childAt(mapFromGlobal(globalPos));
+            QMouseEvent e(type, widgetPos, globalPos, button, buttons, modifiers);
+            QApplicationPrivate::sendMouseEvent(receiver, &e, alien, this, &qt_button_down, qt_last_mouse_receiver);
+        } else {
+            // close disabled popups when a mouse button is pressed or released
+            switch (type) {
+            case QEvent::MouseButtonPress:
+            case QEvent::MouseButtonDblClick:
+            case QEvent::MouseButtonRelease:
+                popup->close();
+                break;
+            default:
+                break;
+            }
+        }
+
+        if (qApp->activePopupWidget() != activePopupWidget
+            && replayPopupMouseEvent) {
+            // the active popup was closed, replay the mouse event
+            if (!(windowType() == Qt::Popup)) {
+#if 1
+                qt_button_down = 0;
+#else
+                if (buttons == button)
+                    qt_button_down = this;
+                QMouseEvent e(type, mapFromGlobal(globalPos), globalPos, button,
+                              buttons, modifiers);
+                QApplication::sendSpontaneousEvent(this, &e);
+
+                if (type == QEvent::MouseButtonPress
+                    && button == Qt::RightButton
+                    && (openPopupCount == oldOpenPopupCount)) {
+                    QContextMenuEvent e(QContextMenuEvent::Mouse, mapFromGlobal(globalPos),
+                                        globalPos, modifiers);
+                    QApplication::sendSpontaneousEvent(this, &e);
+                }
+#endif
+            }
+            replayPopupMouseEvent = false;
+        } else if (type == QEvent::MouseButtonPress
+                   && button == Qt::RightButton
+                   && (openPopupCount == oldOpenPopupCount)) {
+            QWidget *popupEvent = popup;
+            if (qt_button_down)
+                popupEvent = qt_button_down;
+            else if(popupChild)
+                popupEvent = popupChild;
+            QContextMenuEvent e(QContextMenuEvent::Mouse, pos, globalPos, modifiers);
+            QApplication::sendSpontaneousEvent(popupEvent, &e);
+        }
+
+        if (releaseAfter) {
+            qt_button_down = 0;
+            qt_popup_down = 0;
+        }
+    } else {
+        QWidget *alienWidget = childAt(pos);
+        QWidget *widget = QApplicationPrivate::pickMouseReceiver(this, globalPos, pos, type, buttons,
+                                                                 qt_button_down, alienWidget);
+        if (!widget) {
+            if (type == QEvent::MouseButtonRelease)
+                QApplicationPrivate::mouse_buttons &= ~button;
+            return false; // don't send event
+        }
+
+        int oldOpenPopupCount = openPopupCount;
+        QMouseEvent e(type, pos, globalPos, button, buttons, modifiers);
+        QApplicationPrivate::sendMouseEvent(widget, &e, alienWidget, this, &qt_button_down,
+                                            qt_last_mouse_receiver);
+        if (type == QEvent::MouseButtonPress
+            && button == Qt::RightButton
+            && (openPopupCount == oldOpenPopupCount)) {
+            QContextMenuEvent e(QContextMenuEvent::Mouse, pos, globalPos, modifiers);
+            QApplication::sendSpontaneousEvent(widget, &e);
+        }
+    }
+    return true;
+}
+
+
+//
+// Wheel event translation
+//
+bool QETWidget::translateWheelEvent(int global_x, int global_y, int delta,
+                                    Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
+                                    Qt::Orientation orient)
+{
+    const QPoint globalPos = QPoint(global_x, global_y);
+    QPoint pos = mapFromGlobal(globalPos);
+    QWidget *widget = childAt(pos);
+    if (!widget)
+        widget = this;
+    else if (!widget->internalWinId())
+        pos = widget->mapFromGlobal(globalPos);
+
+#ifdef ALIEN_DEBUG
+        qDebug() << "QETWidget::translateWheelEvent: receiver:" << widget << "pos:" << pos;
+#endif
+
+    // send the event to the widget or its ancestors
+    {
+        QWidget* popup = qApp->activePopupWidget();
+        if (popup && window() != popup)
+            popup->close();
+#ifndef QT_NO_WHEELEVENT
+        QWheelEvent e(pos, globalPos, delta, buttons, modifiers, orient);
+        if (QApplication::sendSpontaneousEvent(widget, &e))
+#endif
+            return true;
+    }
+
+    // send the event to the widget that has the focus or its ancestors, if different
+    if (widget != qApp->focusWidget() && (widget = qApp->focusWidget())) {
+        if (widget && !widget->internalWinId())
+            pos = widget->mapFromGlobal(globalPos);
+        QWidget* popup = qApp->activePopupWidget();
+        if (popup && widget != popup)
+            popup->hide();
+#ifndef QT_NO_WHEELEVENT
+        QWheelEvent e(pos, globalPos, delta, buttons, modifiers, orient);
+        if (QApplication::sendSpontaneousEvent(widget, &e))
+#endif
+            return true;
+    }
+    return false;
+}
+
+
+//
+// XInput Translation Event
+//
+#if !defined (QT_NO_TABLET)
+
+#if !defined (Q_OS_IRIX)
+void fetchWacomToolId(int &deviceType, qint64 &serialId)
+{
+    if (ptrWacomConfigInit == 0) // we actually have the lib
+        return;
+    WACOMCONFIG *config = ptrWacomConfigInit(X11->display, 0);
+    if (config == 0)
+        return;
+    WACOMDEVICE *device = ptrWacomConfigOpenDevice (config, wacomDeviceName()->constData());
+    if (device == 0)
+        return;
+    unsigned keys[1];
+    int serialInt;
+    ptrWacomConfigGetRawParam (device, XWACOM_PARAM_TOOLSERIAL, &serialInt, 1, keys);
+    serialId = serialInt;
+    int toolId;
+    ptrWacomConfigGetRawParam (device, XWACOM_PARAM_TOOLID, &toolId, 1, keys);
+    switch(toolId) {
+    case 0x007: /* Mouse 4D and 2D */
+    case 0x017: /* Intuos3 2D Mouse */
+    case 0x094:
+    case 0x09c:
+        deviceType = QTabletEvent::FourDMouse;
+        break;
+    case 0x096: /* Lens cursor */
+    case 0x097: /* Intuos3 Lens cursor */
+        deviceType = QTabletEvent::Puck;
+        break;
+    case 0x0fa:
+    case 0x81b: /* Intuos3 Classic Pen Eraser */
+    case 0x82a: /* Eraser */
+    case 0x82b: /* Intuos3 Grip Pen Eraser */
+    case 0x85a:
+    case 0x91a:
+    case 0x91b: /* Intuos3 Airbrush Eraser */
+    case 0xd1a:
+        deviceType = QTabletEvent::XFreeEraser;
+        break;
+    case 0x112:
+    case 0x912:
+    case 0x913: /* Intuos3 Airbrush */
+    case 0xd12:
+        deviceType = QTabletEvent::Airbrush;
+        break;
+    case 0x012:
+    case 0x022:
+    case 0x032:
+    case 0x801: /* Intuos3 Inking pen */
+    case 0x812: /* Inking pen */
+    case 0x813: /* Intuos3 Classic Pen */
+    case 0x822: /* Pen */
+    case 0x823: /* Intuos3 Grip Pen */
+    case 0x832: /* Stroke pen */
+    case 0x842:
+    case 0x852:
+    case 0x885: /* Intuos3 Marker Pen */
+    default: /* Unknown tool */
+        deviceType = QTabletEvent::Stylus;
+    }
+
+    /* Close device and return */
+    ptrWacomConfigCloseDevice (device);
+    ptrWacomConfigTerm(config);
+}
+#endif
+
+struct qt_tablet_motion_data
+{
+    bool filterByWidget;
+    const QWidget *widget;
+    const QWidget *etWidget;
+    int tabletMotionType;
+    bool error; // found a reason to stop searching
+};
+
+static Bool qt_mouseMotion_scanner(Display *, XEvent *event, XPointer arg)
+{
+    qt_tablet_motion_data *data = (qt_tablet_motion_data *) arg;
+    if (data->error)
+        return false;
+
+    if (event->type == MotionNotify)
+        return true;
+
+    data->error = event->type != data->tabletMotionType; // we stop compression when another event gets in between.
+    return false;
+}
+
+static Bool qt_tabletMotion_scanner(Display *, XEvent *event, XPointer arg)
+{
+    qt_tablet_motion_data *data = (qt_tablet_motion_data *) arg;
+    if (data->error)
+        return false;
+    if (event->type == data->tabletMotionType) {
+        const XDeviceMotionEvent *const motion = reinterpret_cast<const XDeviceMotionEvent*>(event);
+        if (data->filterByWidget) {
+            const QPoint curr(motion->x, motion->y);
+            const QWidget *w = data->etWidget;
+            const QWidget *const child = w->childAt(curr);
+            if (child) {
+                w = child;
+            }
+            if (w == data->widget)
+                return true;
+        } else {
+            return true;
+        }
+    }
+
+    data->error = event->type != MotionNotify; // we stop compression when another event gets in between.
+    return false;
+}
+
+bool QETWidget::translateXinputEvent(const XEvent *ev, QTabletDeviceData *tablet)
+{
+#if defined (Q_OS_IRIX)
+    // Wacom has put defines in their wacom.h file so it would be quite wise
+    // to use them, need to think of a decent way of not using
+    // it when it doesn't exist...
+    XDeviceState *s;
+    XInputClass *iClass;
+    XValuatorState *vs;
+    int j;
+#endif
+
+    Q_ASSERT(tablet != 0);
+
+    QWidget *w = this;
+    QPoint global,
+        curr;
+    QPointF hiRes;
+    qreal pressure = 0;
+    int xTilt = 0,
+        yTilt = 0,
+        z = 0;
+    qreal tangentialPressure = 0;
+    qreal rotation = 0;
+    int deviceType = QTabletEvent::NoDevice;
+    int pointerType = QTabletEvent::UnknownPointer;
+    const XDeviceMotionEvent *motion = 0;
+    XDeviceButtonEvent *button = 0;
+    const XProximityNotifyEvent *proximity = 0;
+    QEvent::Type t;
+    Qt::KeyboardModifiers modifiers = 0;
+#if !defined (Q_OS_IRIX)
+    XID device_id;
+#endif
+
+    if (ev->type == tablet->xinput_motion) {
+        motion = reinterpret_cast<const XDeviceMotionEvent*>(ev);
+        t = QEvent::TabletMove;
+        global = QPoint(motion->x_root, motion->y_root);
+        curr = QPoint(motion->x, motion->y);
+#if !defined (Q_OS_IRIX)
+        device_id = motion->deviceid;
+#endif
+    } else if (ev->type == tablet->xinput_button_press || ev->type == tablet->xinput_button_release) {
+        if (ev->type == tablet->xinput_button_press) {
+            t = QEvent::TabletPress;
+        } else {
+            t = QEvent::TabletRelease;
+        }
+        button = (XDeviceButtonEvent*)ev;
+
+        global = QPoint(button->x_root, button->y_root);
+        curr = QPoint(button->x, button->y);
+#if !defined (Q_OS_IRIX)
+        device_id = button->deviceid;
+#endif
+    } else { // Proximity
+        if (ev->type == tablet->xinput_proximity_in)
+            t = QEvent::TabletEnterProximity;
+        else
+            t = QEvent::TabletLeaveProximity;
+        proximity = (const XProximityNotifyEvent*)ev;
+#if !defined (Q_OS_IRIX)
+        device_id = proximity->deviceid;
+#endif
+    }
+
+    qint64 uid = 0;
+#if defined (Q_OS_IRIX)
+    QRect screenArea = qApp->desktop()->screenGeometry(this);
+    s = XQueryDeviceState(X11->display, static_cast<XDevice *>(tablet->device));
+    if (!s)
+        return false;
+    iClass = s->data;
+    for (j = 0; j < s->num_classes; j++) {
+        if (iClass->c_class == ValuatorClass) {
+            vs = reinterpret_cast<XValuatorState *>(iClass);
+            // figure out what device we have, based on bitmasking...
+            if (vs->valuators[WAC_TRANSDUCER_I]
+                 & WAC_TRANSDUCER_PROX_MSK) {
+                switch (vs->valuators[WAC_TRANSDUCER_I]
+                         & WAC_TRANSDUCER_MSK) {
+                case WAC_PUCK_ID:
+                    pointerType = QTabletEvent::Puck;
+                    break;
+                case WAC_STYLUS_ID:
+                    pointerType = QTabletEvent::Pen;
+                    break;
+                case WAC_ERASER_ID:
+                    pointerType = QTabletEvent::Eraser;
+                    break;
+                }
+                // Get a Unique Id for the device, Wacom gives us this ability
+                uid = vs->valuators[WAC_TRANSDUCER_I] & WAC_TRANSDUCER_ID_MSK;
+                uid = (uid << 24) | vs->valuators[WAC_SERIAL_NUM_I];
+                switch (WAC_TRANSDUCER_I & 0x0F0600) {
+                case 0x080200:
+                    deviceType = QTabletEvent::Stylus;
+                    break;
+                case 0x090200:
+                    deviceType = QTabletEvent::Airbrush;
+                    break;
+                case 0x000400:
+                    deviceType = QTabletEvent::FourDMouse;
+                    break;
+                case 0x000600:
+                    deviceType = QTabletEvent::Puck;
+                    break;
+                case 0x080400:
+                    deviceType = QTabletEvent::RotationStylus;
+                    break;
+                }
+            } else {
+                pointerType = QTabletEvent::UnknownPointer;
+                deviceType = QTabletEvent::NoDevice;
+                uid = 0;
+            }
+
+            if (!proximity) {
+                // apparently Wacom needs a cast for the +/- values to make sense
+                xTilt = short(vs->valuators[WAC_XTILT_I]);
+                yTilt = short(vs->valuators[WAC_YTILT_I]);
+                pressure = vs->valuators[WAC_PRESSURE_I];
+                if (deviceType == QTabletEvent::FourDMouse
+                        || deviceType == QTabletEvent::RotationStylus) {
+                    rotation = vs->valuators[WAC_ROTATION_I] / 64.0;
+                    if (deviceType == QTabletEvent::FourDMouse)
+                        z = vs->valuators[WAC_ZCOORD_I];
+                } else if (deviceType == QTabletEvent::Airbrush) {
+                    tangentialPressure = vs->valuators[WAC_TAN_PRESSURE_I]
+                                            / qreal(tablet->maxTanPressure - tablet->minTanPressure);
+                }
+
+                hiRes = tablet->scaleCoord(vs->valuators[WAC_XCOORD_I], vs->valuators[WAC_YCOORD_I],
+                                           screenArea.x(), screenArea.width(),
+                                           screenArea.y(), screenArea.height());
+            }
+            break;
+        }
+        iClass = reinterpret_cast<XInputClass*>(reinterpret_cast<char*>(iClass) + iClass->length);
+    }
+    XFreeDeviceState(s);
+#else
+    // We've been passed in data for a tablet device that handles this type
+    // of event, but it isn't necessarily the tablet device that originated
+    // the event.  Use the device id to find the originating device if we
+    // have it.
+    QTabletDeviceDataList *tablet_list = qt_tablet_devices();
+    for (int i = 0; i < tablet_list->size(); ++i) {
+        QTabletDeviceData &tab = tablet_list->operator[](i);
+        if (device_id == static_cast<XDevice *>(tab.device)->device_id) {
+            // Replace the tablet passed in with this one.
+            tablet = &tab;
+            deviceType = tab.deviceType;
+            if (tab.deviceType == QTabletEvent::XFreeEraser) {
+                deviceType = QTabletEvent::Stylus;
+                pointerType = QTabletEvent::Eraser;
+            } else if (tab.deviceType == QTabletEvent::Stylus) {
+                pointerType = QTabletEvent::Pen;
+            }
+            break;
+        }
+    }
+
+    fetchWacomToolId(deviceType, uid);
+
+    QRect screenArea = qApp->desktop()->rect();
+    if (motion) {
+        xTilt = (short) motion->axis_data[3];
+        yTilt = (short) motion->axis_data[4];
+        rotation = ((short) motion->axis_data[5]) / 64.0;
+        pressure = (short) motion->axis_data[2];
+        modifiers = X11->translateModifiers(motion->state);
+        hiRes = tablet->scaleCoord(motion->axis_data[0], motion->axis_data[1],
+                                    screenArea.x(), screenArea.width(),
+                                    screenArea.y(), screenArea.height());
+    } else if (button) {
+        xTilt = (short) button->axis_data[3];
+        yTilt = (short) button->axis_data[4];
+        rotation = ((short) button->axis_data[5]) / 64.0;
+        pressure = (short) button->axis_data[2];
+        modifiers = X11->translateModifiers(button->state);
+        hiRes = tablet->scaleCoord(button->axis_data[0], button->axis_data[1],
+                                    screenArea.x(), screenArea.width(),
+                                    screenArea.y(), screenArea.height());
+    } else if (proximity) {
+        pressure = 0;
+        modifiers = 0;
+    }
+    if (deviceType == QTabletEvent::Airbrush) {
+        tangentialPressure = rotation;
+        rotation = 0.;
+    }
+#endif
+
+    if (tablet->widgetToGetPress) {
+        w = tablet->widgetToGetPress;
+    } else {
+        QWidget *child = w->childAt(curr);
+        if (child)
+            w = child;
+    }
+    curr = w->mapFromGlobal(global);
+
+    if (t == QEvent::TabletPress) {
+        tablet->widgetToGetPress = w;
+    } else if (t == QEvent::TabletRelease && tablet->widgetToGetPress) {
+        w = tablet->widgetToGetPress;
+        curr = w->mapFromGlobal(global);
+        tablet->widgetToGetPress = 0;
+    }
+
+    QTabletEvent e(t, curr, global, hiRes,
+                   deviceType, pointerType,
+                   qreal(pressure / qreal(tablet->maxPressure - tablet->minPressure)),
+                   xTilt, yTilt, tangentialPressure, rotation, z, modifiers, uid);
+    if (proximity) {
+        QApplication::sendSpontaneousEvent(qApp, &e);
+    } else {
+        QApplication::sendSpontaneousEvent(w, &e);
+        const bool accepted = e.isAccepted();
+        if (!accepted && ev->type == tablet->xinput_motion) {
+            // If the widget does not accept tablet events, we drop the next ones from the event queue
+            // for this widget so it is not overloaded with the numerous tablet events.
+            qt_tablet_motion_data tabletMotionData;
+            tabletMotionData.tabletMotionType = tablet->xinput_motion;
+            tabletMotionData.widget = w;
+            tabletMotionData.etWidget = this;
+            // if nothing is pressed, the events are filtered by position
+            tabletMotionData.filterByWidget = (tablet->widgetToGetPress == 0);
+
+            bool reinsertMouseEvent = false;
+            XEvent mouseMotionEvent;
+            while (true) {
+                // Find first mouse event since we expect them in pairs inside Qt
+                tabletMotionData.error =false;
+                if (XCheckIfEvent(X11->display, &mouseMotionEvent, &qt_mouseMotion_scanner, (XPointer) &tabletMotionData)) {
+                    reinsertMouseEvent = true;
+                } else {
+                    break;
+                }
+
+                // Now discard any duplicate tablet events.
+                tabletMotionData.error = false;
+                XEvent dummy;
+                while (XCheckIfEvent(X11->display, &dummy, &qt_tabletMotion_scanner, (XPointer) &tabletMotionData)) {
+                    // just discard the event
+                }
+            }
+
+            if (reinsertMouseEvent) {
+                XPutBackEvent(X11->display, &mouseMotionEvent);
+            }
+        }
+    }
+    return true;
+}
+#endif
+
+bool QETWidget::translatePropertyEvent(const XEvent *event)
+{
+    Q_D(QWidget);
+    if (!isWindow()) return true;
+
+    Atom ret;
+    int format, e;
+    unsigned char *data = 0;
+    unsigned long nitems, after;
+
+    if (event->xproperty.atom == ATOM(_KDE_NET_WM_FRAME_STRUT)) {
+        this->data->fstrut_dirty = 1;
+
+        if (event->xproperty.state == PropertyNewValue) {
+            e = XGetWindowProperty(X11->display, event->xproperty.window, ATOM(_KDE_NET_WM_FRAME_STRUT),
+                                   0, 4, // struts are 4 longs
+                                   False, XA_CARDINAL, &ret, &format, &nitems, &after, &data);
+
+            if (e == Success && ret == XA_CARDINAL &&
+                format == 32 && nitems == 4) {
+                long *strut = (long *) data;
+                d->topData()->frameStrut.setCoords(strut[0], strut[2], strut[1], strut[3]);
+                this->data->fstrut_dirty = 0;
+            }
+        }
+    } else if (event->xproperty.atom == ATOM(_NET_WM_STATE)) {
+        bool max = false;
+        bool full = false;
+        Qt::WindowStates oldState = Qt::WindowStates(this->data->window_state);
+
+        if (event->xproperty.state == PropertyNewValue) {
+            // using length of 1024 should be safe for all current and
+            // possible NET states...
+            e = XGetWindowProperty(X11->display, event->xproperty.window, ATOM(_NET_WM_STATE), 0, 1024,
+                                   False, XA_ATOM, &ret, &format, &nitems, &after, &data);
+
+            if (e == Success && ret == XA_ATOM && format == 32 && nitems > 0) {
+                Atom *states = (Atom *) data;
+
+                unsigned long i;
+                uint maximized = 0;
+                for (i = 0; i < nitems; i++) {
+                    if (states[i] == ATOM(_NET_WM_STATE_MAXIMIZED_VERT))
+                        maximized |= 1;
+                    else if (states[i] == ATOM(_NET_WM_STATE_MAXIMIZED_HORZ))
+                        maximized |= 2;
+                    else if (states[i] == ATOM(_NET_WM_STATE_FULLSCREEN))
+                        full = true;
+                }
+                if (maximized == 3) {
+                    // only set maximized if both horizontal and vertical properties are set
+                    max = true;
+                }
+            }
+        }
+
+        bool send_event = false;
+
+        if (X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_VERT))
+            && X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ))) {
+            if (max && !isMaximized()) {
+                this->data->window_state = this->data->window_state | Qt::WindowMaximized;
+                send_event = true;
+            } else if (!max && isMaximized()) {
+                this->data->window_state &= ~Qt::WindowMaximized;
+                send_event = true;
+            }
+        }
+
+        if (X11->isSupportedByWM(ATOM(_NET_WM_STATE_FULLSCREEN))) {
+            if (full && !isFullScreen()) {
+                this->data->window_state = this->data->window_state | Qt::WindowFullScreen;
+                send_event = true;
+            } else if (!full && isFullScreen()) {
+                this->data->window_state &= ~Qt::WindowFullScreen;
+                send_event = true;
+            }
+        }
+
+        if (send_event) {
+            QWindowStateChangeEvent e(oldState);
+            QApplication::sendSpontaneousEvent(this, &e);
+        }
+    } else if (event->xproperty.atom == ATOM(WM_STATE)) {
+        // the widget frame strut should also be invalidated
+        this->data->fstrut_dirty = 1;
+
+        if (event->xproperty.state == PropertyDelete) {
+            // the window manager has removed the WM State property,
+            // so it is now in the withdrawn state (ICCCM 4.1.3.1) and
+            // we are free to reuse this window
+            d->topData()->parentWinId = 0;
+            d->topData()->validWMState = 0;
+            // map the window if we were waiting for a transition to
+            // withdrawn
+            if (X11->deferred_map.removeAll(this)) {
+                doDeferredMap();
+            } else if (isVisible()
+                       && !testAttribute(Qt::WA_Mapped)
+                       && !testAttribute(Qt::WA_OutsideWSRange)) {
+                // so that show() will work again. As stated in the
+                // ICCCM section 4.1.4: "Only the client can effect a
+                // transition into or out of the Withdrawn state.",
+                // but apparently this particular window manager
+                // doesn't seem to care
+                setAttribute(Qt::WA_WState_ExplicitShowHide, false);
+                setAttribute(Qt::WA_WState_Visible, false);
+            }
+        } else {
+            // the window manager has changed the WM State property...
+            // we are wanting to see if we are withdrawn so that we
+            // can reuse this window...
+            e = XGetWindowProperty(X11->display, internalWinId(), ATOM(WM_STATE), 0, 2, False,
+                                   ATOM(WM_STATE), &ret, &format, &nitems, &after, &data);
+
+            if (e == Success && ret == ATOM(WM_STATE) && format == 32 && nitems > 0) {
+                long *state = (long *) data;
+                switch (state[0]) {
+                case WithdrawnState:
+                    // if we are in the withdrawn state, we are free
+                    // to reuse this window provided we remove the
+                    // WM_STATE property (ICCCM 4.1.3.1)
+                    XDeleteProperty(X11->display, internalWinId(), ATOM(WM_STATE));
+
+                    // set the parent id to zero, so that show() will
+                    // work again
+                    d->topData()->parentWinId = 0;
+                    d->topData()->validWMState = 0;
+                    // map the window if we were waiting for a
+                    // transition to withdrawn
+                    if (X11->deferred_map.removeAll(this)) {
+                        doDeferredMap();
+                    } else if (isVisible()
+                               && !testAttribute(Qt::WA_Mapped)
+                               && !testAttribute(Qt::WA_OutsideWSRange)) {
+                        // so that show() will work again. As stated
+                        // in the ICCCM section 4.1.4: "Only the
+                        // client can effect a transition into or out
+                        // of the Withdrawn state.", but apparently
+                        // this particular window manager doesn't seem
+                        // to care
+                        setAttribute(Qt::WA_WState_ExplicitShowHide, false);
+                        setAttribute(Qt::WA_WState_Visible, false);
+                    }
+                    break;
+
+                case IconicState:
+                    d->topData()->validWMState = 1;
+                    if (!isMinimized()) {
+                        // window was minimized
+                        this->data->window_state = this->data->window_state | Qt::WindowMinimized;
+                        QWindowStateChangeEvent e(Qt::WindowStates(this->data->window_state & ~Qt::WindowMinimized));
+                        QApplication::sendSpontaneousEvent(this, &e);
+                    }
+                    break;
+
+                default:
+                    d->topData()->validWMState = 1;
+                    if (isMinimized()) {
+                        // window was un-minimized
+                        this->data->window_state &= ~Qt::WindowMinimized;
+                        QWindowStateChangeEvent e(Qt::WindowStates(this->data->window_state | Qt::WindowMinimized));
+                        QApplication::sendSpontaneousEvent(this, &e);
+                    }
+                    break;
+                }
+            }
+        }
+    } else if (event->xproperty.atom == ATOM(_NET_WM_WINDOW_OPACITY)) {
+        // the window opacity was changed
+        if (event->xproperty.state == PropertyNewValue) {
+            e = XGetWindowProperty(event->xclient.display,
+                                   event->xclient.window,
+                                   ATOM(_NET_WM_WINDOW_OPACITY),
+                                   0, 1, False, XA_CARDINAL,
+                                   &ret, &format, &nitems, &after, &data);
+
+            if (e == Success && ret == XA_CARDINAL && format == 32 && nitems == 1
+                && after == 0 && data) {
+                ulong value = *(ulong*)(data);
+                d->topData()->opacity = uint(value >> 24);
+            }
+        } else
+            d->topData()->opacity = 255;
+    }
+
+    if (data)
+        XFree(data);
+
+    return true;
+}
+
+
+//
+// Paint event translation
+//
+// When receiving many expose events, we compress them (union of all expose
+// rectangles) into one event which is sent to the widget.
+
+struct PaintEventInfo {
+    Window window;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool isPaintOrScrollDoneEvent(Display *, XEvent *ev, XPointer a)
+{
+    PaintEventInfo *info = (PaintEventInfo *)a;
+    if (ev->type == Expose || ev->type == GraphicsExpose
+        || (ev->type == ClientMessage && ev->xclient.message_type == ATOM(_QT_SCROLL_DONE)))
+    {
+        if (ev->xexpose.window == info->window)
+            return True;
+    }
+    return False;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+
+static
+bool translateBySips(QWidget* that, QRect& paintRect)
+{
+    int dx=0, dy=0;
+    int sips=0;
+    for (int i = 0; i < X11->sip_list.size(); ++i) {
+        const QX11Data::ScrollInProgress &sip = X11->sip_list.at(i);
+        if (sip.scrolled_widget == that) {
+            if (sips) {
+                dx += sip.dx;
+                dy += sip.dy;
+            }
+            sips++;
+        }
+    }
+    if (sips > 1) {
+        paintRect.translate(dx, dy);
+        return true;
+    }
+    return false;
+}
+
+void QETWidget::translatePaintEvent(const XEvent *event)
+{
+    if (!isWindow() && testAttribute(Qt::WA_NativeWindow))
+        Q_ASSERT(internalWinId());
+
+    Q_D(QWidget);
+    QRect  paintRect(event->xexpose.x, event->xexpose.y,
+                     event->xexpose.width, event->xexpose.height);
+    XEvent xevent;
+    PaintEventInfo info;
+    info.window = internalWinId();
+    translateBySips(this, paintRect);
+    paintRect = d->mapFromWS(paintRect);
+
+    QRegion paintRegion = paintRect;
+
+    // WARNING: this is O(number_of_events * number_of_matching_events)
+    while (XCheckIfEvent(X11->display,&xevent,isPaintOrScrollDoneEvent,
+                         (XPointer)&info) &&
+           !qt_x11EventFilter(&xevent)  &&
+           !x11Event(&xevent)) // send event through filter
+    {
+        if (xevent.type == Expose || xevent.type == GraphicsExpose) {
+            QRect exposure(xevent.xexpose.x,
+                           xevent.xexpose.y,
+                           xevent.xexpose.width,
+                           xevent.xexpose.height);
+            translateBySips(this, exposure);
+            exposure = d->mapFromWS(exposure);
+            paintRegion |= exposure;
+        } else {
+            translateScrollDoneEvent(&xevent);
+        }
+    }
+
+    if (!paintRegion.isEmpty() && !testAttribute(Qt::WA_WState_ConfigPending))
+        d->syncBackingStore(paintRegion);
+}
+
+//
+// Scroll-done event translation.
+//
+
+bool QETWidget::translateScrollDoneEvent(const XEvent *event)
+{
+    long id = event->xclient.data.l[0];
+
+    // Remove any scroll-in-progress record for the given id.
+    for (int i = 0; i < X11->sip_list.size(); ++i) {
+        const QX11Data::ScrollInProgress &sip = X11->sip_list.at(i);
+        if (sip.id == id) {
+            X11->sip_list.removeAt(i);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+//
+// ConfigureNotify (window move and resize) event translation
+
+bool QETWidget::translateConfigEvent(const XEvent *event)
+{
+    Q_ASSERT((!isWindow() && !testAttribute(Qt::WA_NativeWindow)) ? internalWinId() : true);
+
+    Q_D(QWidget);
+    bool wasResize = testAttribute(Qt::WA_WState_ConfigPending); // set in QWidget::setGeometry_sys()
+    setAttribute(Qt::WA_WState_ConfigPending, false);
+
+    if (testAttribute(Qt::WA_OutsideWSRange)) {
+        // discard events for windows that have a geometry X can't handle
+        XEvent xevent;
+        while (XCheckTypedWindowEvent(X11->display,internalWinId(), ConfigureNotify,&xevent) &&
+               !qt_x11EventFilter(&xevent)  &&
+               !x11Event(&xevent)) // send event through filter
+            ;
+        return true;
+    }
+
+    const QSize oldSize = size();
+
+    if (isWindow()) {
+        QPoint newCPos(geometry().topLeft());
+        QSize  newSize(event->xconfigure.width, event->xconfigure.height);
+
+        bool trust = isVisible()
+                     && (d->topData()->parentWinId == XNone ||
+                         d->topData()->parentWinId == QX11Info::appRootWindow());
+        bool isCPos = false;
+
+        if (event->xconfigure.send_event || trust) {
+            // if a ConfigureNotify comes from a real sendevent request, we can
+            // trust its values.
+            newCPos.rx() = event->xconfigure.x + event->xconfigure.border_width;
+            newCPos.ry() = event->xconfigure.y + event->xconfigure.border_width;
+            isCPos = true;
+        }
+        if (isVisible())
+            QApplication::syncX();
+
+        if (d->extra->compress_events) {
+            // ConfigureNotify compression for faster opaque resizing
+            XEvent otherEvent;
+            while (XCheckTypedWindowEvent(X11->display, internalWinId(), ConfigureNotify,
+                                          &otherEvent)) {
+                if (qt_x11EventFilter(&otherEvent))
+                    continue;
+
+                if (x11Event(&otherEvent))
+                    continue;
+
+                if (otherEvent.xconfigure.event != otherEvent.xconfigure.window)
+                    continue;
+
+                newSize.setWidth(otherEvent.xconfigure.width);
+                newSize.setHeight(otherEvent.xconfigure.height);
+
+                if (otherEvent.xconfigure.send_event || trust) {
+                    newCPos.rx() = otherEvent.xconfigure.x +
+                                   otherEvent.xconfigure.border_width;
+                    newCPos.ry() = otherEvent.xconfigure.y +
+                                   otherEvent.xconfigure.border_width;
+                    isCPos = true;
+                }
+            }
+#ifndef QT_NO_XSYNC
+            qt_sync_request_event_data sync_event;
+            sync_event.window = internalWinId();
+            for (XEvent ev;;) {
+                if (!XCheckIfEvent(X11->display, &ev, &qt_sync_request_scanner, (XPointer)&sync_event))
+                    break;
+            }
+#endif // QT_NO_XSYNC
+        }
+
+        if (!isCPos) {
+            // we didn't get an updated position of the toplevel.
+            // either we haven't moved or there is a bug in the window manager.
+            // anyway, let's query the position to be certain.
+            int x, y;
+            Window child;
+            XTranslateCoordinates(X11->display, internalWinId(),
+                                  QApplication::desktop()->screen(d->xinfo.screen())->internalWinId(),
+                                  0, 0, &x, &y, &child);
+            newCPos.rx() = x;
+            newCPos.ry() = y;
+        }
+
+        QRect cr (geometry());
+        if (newCPos != cr.topLeft()) { // compare with cpos (exluding frame)
+            QPoint oldPos = geometry().topLeft();
+            cr.moveTopLeft(newCPos);
+            data->crect = cr;
+            if (isVisible()) {
+                QMoveEvent e(newCPos, oldPos); // pos (including frame), not cpos
+                QApplication::sendSpontaneousEvent(this, &e);
+            } else {
+                setAttribute(Qt::WA_PendingMoveEvent, true);
+            }
+        }
+        if (newSize != cr.size()) { // size changed
+            cr.setSize(newSize);
+            data->crect = cr;
+
+            uint old_state = data->window_state;
+            if (!X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_VERT))
+                && !X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ)))
+                data->window_state &= ~Qt::WindowMaximized;
+            if (!X11->isSupportedByWM(ATOM(_NET_WM_STATE_FULLSCREEN)))
+                data->window_state &= ~Qt::WindowFullScreen;
+
+            if (old_state != data->window_state) {
+                QWindowStateChangeEvent e((Qt::WindowStates) old_state);
+                QApplication::sendEvent(this, &e);
+            }
+
+            if (!isVisible())
+                setAttribute(Qt::WA_PendingResizeEvent, true);
+            wasResize = true;
+        }
+
+    } else {
+        XEvent xevent;
+        while (XCheckTypedWindowEvent(X11->display,internalWinId(), ConfigureNotify,&xevent) &&
+               !qt_x11EventFilter(&xevent)  &&
+               !x11Event(&xevent)) // send event through filter
+            ;
+    }
+
+    if (wasResize) {
+        if (isVisible() && data->crect.size() != oldSize) {
+            Q_ASSERT(d->extra->topextra);
+            QWidgetBackingStore *bs = d->extra->topextra->backingStore.data();
+            const bool hasStaticContents = bs && bs->hasStaticContents();
+            // If we have a backing store with static contents, we have to disable the top-level
+            // resize optimization in order to get invalidated regions for resized widgets.
+            // The optimization discards all invalidateBuffer() calls since we're going to
+            // repaint everything anyways, but that's not the case with static contents.
+            if (!hasStaticContents)
+                d->extra->topextra->inTopLevelResize = true;
+            QResizeEvent e(data->crect.size(), oldSize);
+            QApplication::sendSpontaneousEvent(this, &e);
+        }
+
+        const bool waitingForMapNotify = d->extra->topextra && d->extra->topextra->waitingForMapNotify;
+        if (!waitingForMapNotify) {
+            if (d->paintOnScreen()) {
+                QRegion updateRegion(rect());
+                if (testAttribute(Qt::WA_StaticContents))
+                    updateRegion -= QRect(0, 0, oldSize.width(), oldSize.height());
+                d->syncBackingStore(updateRegion);
+            } else {
+                d->syncBackingStore();
+            }
+        }
+
+        if (d->extra && d->extra->topextra)
+            d->extra->topextra->inTopLevelResize = false;
+    }
+#ifndef QT_NO_XSYNC
+    if (QTLWExtra *tlwExtra = d->maybeTopData()) {
+        if (tlwExtra->newCounterValueLo != 0 || tlwExtra->newCounterValueHi != 0) {
+            XSyncValue value;
+            XSyncIntsToValue(&value,
+                             tlwExtra->newCounterValueLo,
+                             tlwExtra->newCounterValueHi);
+
+            XSyncSetCounter(X11->display, tlwExtra->syncUpdateCounter, value);
+            tlwExtra->newCounterValueHi = 0;
+            tlwExtra->newCounterValueLo = 0;
+        }
+    }
+#endif
+    return true;
+}
+
+//
+// Close window event translation.
+//
+bool QETWidget::translateCloseEvent(const XEvent *)
+{
+    Q_D(QWidget);
+    return d->close_helper(QWidgetPrivate::CloseWithSpontaneousEvent);
+}
+
+
+void QApplication::setCursorFlashTime(int msecs)
+{
+    QApplicationPrivate::cursor_flash_time = msecs;
+}
+
+int QApplication::cursorFlashTime()
+{
+    return QApplicationPrivate::cursor_flash_time;
+}
+
+void QApplication::setDoubleClickInterval(int ms)
+{
+    QApplicationPrivate::mouse_double_click_time = ms;
+}
+
+int QApplication::doubleClickInterval()
+{
+    return QApplicationPrivate::mouse_double_click_time;
+}
+
+void QApplication::setKeyboardInputInterval(int ms)
+{
+    QApplicationPrivate::keyboard_input_time = ms;
+}
+
+int QApplication::keyboardInputInterval()
+{
+    return QApplicationPrivate::keyboard_input_time;
+}
+
+#ifndef QT_NO_WHEELEVENT
+void QApplication::setWheelScrollLines(int n)
+{
+    QApplicationPrivate::wheel_scroll_lines = n;
+}
+
+int QApplication::wheelScrollLines()
+{
+    return QApplicationPrivate::wheel_scroll_lines;
+}
+#endif
+
+void QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)
+{
+    switch (effect) {
+    case Qt::UI_AnimateMenu:
+        if (enable) QApplicationPrivate::fade_menu = false;
+        QApplicationPrivate::animate_menu = enable;
+        break;
+    case Qt::UI_FadeMenu:
+        if (enable)
+            QApplicationPrivate::animate_menu = true;
+        QApplicationPrivate::fade_menu = enable;
+        break;
+    case Qt::UI_AnimateCombo:
+        QApplicationPrivate::animate_combo = enable;
+        break;
+    case Qt::UI_AnimateTooltip:
+        if (enable) QApplicationPrivate::fade_tooltip = false;
+        QApplicationPrivate::animate_tooltip = enable;
+        break;
+    case Qt::UI_FadeTooltip:
+        if (enable)
+            QApplicationPrivate::animate_tooltip = true;
+        QApplicationPrivate::fade_tooltip = enable;
+        break;
+    case Qt::UI_AnimateToolBox:
+        QApplicationPrivate::animate_toolbox = enable;
+        break;
+    default:
+        QApplicationPrivate::animate_ui = enable;
+        break;
+    }
+}
+
+bool QApplication::isEffectEnabled(Qt::UIEffect effect)
+{
+    if (QColormap::instance().depth() < 16 || !QApplicationPrivate::animate_ui)
+        return false;
+
+    switch(effect) {
+    case Qt::UI_AnimateMenu:
+        return QApplicationPrivate::animate_menu;
+    case Qt::UI_FadeMenu:
+        return QApplicationPrivate::fade_menu;
+    case Qt::UI_AnimateCombo:
+        return QApplicationPrivate::animate_combo;
+    case Qt::UI_AnimateTooltip:
+        return QApplicationPrivate::animate_tooltip;
+    case Qt::UI_FadeTooltip:
+        return QApplicationPrivate::fade_tooltip;
+    case Qt::UI_AnimateToolBox:
+        return QApplicationPrivate::animate_toolbox;
+    default:
+        return QApplicationPrivate::animate_ui;
+    }
+}
+
+/*****************************************************************************
+  Session management support
+ *****************************************************************************/
+
+#ifndef QT_NO_SESSIONMANAGER
+
+QT_BEGIN_INCLUDE_NAMESPACE
+#include <X11/SM/SMlib.h>
+QT_END_INCLUDE_NAMESPACE
+
+class QSessionManagerPrivate : public QObjectPrivate
+{
+public:
+    QSessionManagerPrivate(QSessionManager* mgr, QString& id, QString& key)
+        : QObjectPrivate(), sm(mgr), sessionId(id), sessionKey(key),
+            restartHint(QSessionManager::RestartIfRunning), eventLoop(0) {}
+    QSessionManager* sm;
+    QStringList restartCommand;
+    QStringList discardCommand;
+    QString& sessionId;
+    QString& sessionKey;
+    QSessionManager::RestartHint restartHint;
+    QEventLoop *eventLoop;
+};
+
+class QSmSocketReceiver : public QObject
+{
+    Q_OBJECT
+public:
+    QSmSocketReceiver(int socket)
+        {
+            QSocketNotifier* sn = new QSocketNotifier(socket, QSocketNotifier::Read, this);
+            connect(sn, SIGNAL(activated(int)), this, SLOT(socketActivated(int)));
+        }
+
+public slots:
+     void socketActivated(int);
+};
+
+
+static SmcConn smcConnection = 0;
+static bool sm_interactionActive;
+static bool sm_smActive;
+static int sm_interactStyle;
+static int sm_saveType;
+static bool sm_cancel;
+// static bool sm_waitingForPhase2;  ### never used?!?
+static bool sm_waitingForInteraction;
+static bool sm_isshutdown;
+// static bool sm_shouldbefast;  ### never used?!?
+static bool sm_phase2;
+static bool sm_in_phase2;
+
+static QSmSocketReceiver* sm_receiver = 0;
+
+static void resetSmState();
+static void sm_setProperty(const char* name, const char* type,
+                            int num_vals, SmPropValue* vals);
+static void sm_saveYourselfCallback(SmcConn smcConn, SmPointer clientData,
+                                  int saveType, Bool shutdown , int interactStyle, Bool fast);
+static void sm_saveYourselfPhase2Callback(SmcConn smcConn, SmPointer clientData) ;
+static void sm_dieCallback(SmcConn smcConn, SmPointer clientData) ;
+static void sm_shutdownCancelledCallback(SmcConn smcConn, SmPointer clientData);
+static void sm_saveCompleteCallback(SmcConn smcConn, SmPointer clientData);
+static void sm_interactCallback(SmcConn smcConn, SmPointer clientData);
+static void sm_performSaveYourself(QSessionManagerPrivate*);
+
+static void resetSmState()
+{
+//    sm_waitingForPhase2 = false; ### never used?!?
+    sm_waitingForInteraction = false;
+    sm_interactionActive = false;
+    sm_interactStyle = SmInteractStyleNone;
+    sm_smActive = false;
+    qt_sm_blockUserInput = false;
+    sm_isshutdown = false;
+//    sm_shouldbefast = false; ### never used?!?
+    sm_phase2 = false;
+    sm_in_phase2 = false;
+}
+
+
+// theoretically it's possible to set several properties at once. For
+// simplicity, however, we do just one property at a time
+static void sm_setProperty(const char* name, const char* type,
+                            int num_vals, SmPropValue* vals)
+{
+    if (num_vals) {
+      SmProp prop;
+      prop.name = (char*)name;
+      prop.type = (char*)type;
+      prop.num_vals = num_vals;
+      prop.vals = vals;
+
+      SmProp* props[1];
+      props[0] = &prop;
+      SmcSetProperties(smcConnection, 1, props);
+    }
+    else {
+      char* names[1];
+      names[0] = (char*) name;
+      SmcDeleteProperties(smcConnection, 1, names);
+    }
+}
+
+static void sm_setProperty(const QString& name, const QString& value)
+{
+    QByteArray v = value.toUtf8();
+    SmPropValue prop;
+    prop.length = v.length();
+    prop.value = (SmPointer) v.constData();
+    sm_setProperty(name.toLatin1().data(), SmARRAY8, 1, &prop);
+}
+
+static void sm_setProperty(const QString& name, const QStringList& value)
+{
+    SmPropValue *prop = new SmPropValue[value.count()];
+    int count = 0;
+    QList<QByteArray> vl;
+    for (QStringList::ConstIterator it = value.begin(); it != value.end(); ++it) {
+      prop[count].length = (*it).length();
+      vl.append((*it).toUtf8());
+      prop[count].value = (char*)vl.last().data();
+      ++count;
+    }
+    sm_setProperty(name.toLatin1().data(), SmLISTofARRAY8, count, prop);
+    delete [] prop;
+}
+
+
+// workaround for broken libsm, see below
+struct QT_smcConn {
+    unsigned int save_yourself_in_progress : 1;
+    unsigned int shutdown_in_progress : 1;
+};
+
+static void sm_saveYourselfCallback(SmcConn smcConn, SmPointer clientData,
+                                  int saveType, Bool shutdown , int interactStyle, Bool /*fast*/)
+{
+    if (smcConn != smcConnection)
+        return;
+    sm_cancel = false;
+    sm_smActive = true;
+    sm_isshutdown = shutdown;
+    sm_saveType = saveType;
+    sm_interactStyle = interactStyle;
+//    sm_shouldbefast = fast; ### never used?!?
+
+    // ugly workaround for broken libSM. libSM should do that _before_
+    // actually invoking the callback in sm_process.c
+    ((QT_smcConn*)smcConn)->save_yourself_in_progress = true;
+    if (sm_isshutdown)
+        ((QT_smcConn*)smcConn)->shutdown_in_progress = true;
+
+    sm_performSaveYourself((QSessionManagerPrivate*) clientData);
+    if (!sm_isshutdown) // we cannot expect a confirmation message in that case
+        resetSmState();
+}
+
+static void sm_performSaveYourself(QSessionManagerPrivate* smd)
+{
+    if (sm_isshutdown)
+        qt_sm_blockUserInput = true;
+
+    QSessionManager* sm = smd->sm;
+
+    // generate a new session key
+    timeval tv;
+    gettimeofday(&tv, 0);
+    smd->sessionKey  = QString::number(qulonglong(tv.tv_sec)) + QLatin1Char('_') + QString::number(qulonglong(tv.tv_usec));
+
+    QStringList arguments = qApp->arguments();
+    QString argument0 = arguments.isEmpty() ? qApp->applicationFilePath() : arguments.at(0);
+
+    // tell the session manager about our program in best POSIX style
+    sm_setProperty(QString::fromLatin1(SmProgram), argument0);
+    // tell the session manager about our user as well.
+    struct passwd *entryPtr = 0;
+#if defined(_POSIX_THREAD_SAFE_FUNCTIONS) && (_POSIX_THREAD_SAFE_FUNCTIONS - 0 > 0)
+    QVarLengthArray<char, 1024> buf(qMax<long>(sysconf(_SC_GETPW_R_SIZE_MAX), 1024L));
+    struct passwd entry;
+    while (getpwuid_r(geteuid(), &entry, buf.data(), buf.size(), &entryPtr) == ERANGE) {
+        if (buf.size() >= 32768) {
+            // too big already, fail
+            static char badusername[] = "";
+            entryPtr = &entry;
+            entry.pw_name = badusername;
+            break;
+        }
+
+        // retry with a bigger buffer
+        buf.resize(buf.size() * 2);
+    }
+#else
+    entryPtr = getpwuid(geteuid());
+#endif
+    if (entryPtr)
+        sm_setProperty(QString::fromLatin1(SmUserID), QString::fromLatin1(entryPtr->pw_name));
+
+    // generate a restart and discard command that makes sense
+    QStringList restart;
+    restart  << argument0 << QLatin1String("-session")
+             << smd->sessionId + QLatin1Char('_') + smd->sessionKey;
+    if (qstricmp(appName, QX11Info::appClass()) != 0)
+        restart << QLatin1String("-name") << qAppName();
+    sm->setRestartCommand(restart);
+    QStringList discard;
+    sm->setDiscardCommand(discard);
+
+    switch (sm_saveType) {
+    case SmSaveBoth:
+        qApp->commitData(*sm);
+        if (sm_isshutdown && sm_cancel)
+            break; // we cancelled the shutdown, no need to save state
+    // fall through
+    case SmSaveLocal:
+        qApp->saveState(*sm);
+        break;
+    case SmSaveGlobal:
+        qApp->commitData(*sm);
+        break;
+    default:
+        break;
+    }
+
+    if (sm_phase2 && !sm_in_phase2) {
+        SmcRequestSaveYourselfPhase2(smcConnection, sm_saveYourselfPhase2Callback, (SmPointer*) smd);
+        qt_sm_blockUserInput = false;
+    }
+    else {
+        // close eventual interaction monitors and cancel the
+        // shutdown, if required. Note that we can only cancel when
+        // performing a shutdown, it does not work for checkpoints
+        if (sm_interactionActive) {
+            SmcInteractDone(smcConnection, sm_isshutdown && sm_cancel);
+            sm_interactionActive = false;
+        }
+        else if (sm_cancel && sm_isshutdown) {
+            if (sm->allowsErrorInteraction()) {
+                SmcInteractDone(smcConnection, True);
+                sm_interactionActive = false;
+            }
+        }
+
+        // set restart and discard command in session manager
+        sm_setProperty(QString::fromLatin1(SmRestartCommand), sm->restartCommand());
+        sm_setProperty(QString::fromLatin1(SmDiscardCommand), sm->discardCommand());
+
+        // set the restart hint
+        SmPropValue prop;
+        prop.length = sizeof(int);
+        int value = sm->restartHint();
+        prop.value = (SmPointer) &value;
+        sm_setProperty(SmRestartStyleHint, SmCARD8, 1, &prop);
+
+        // we are done
+        SmcSaveYourselfDone(smcConnection, !sm_cancel);
+    }
+}
+
+static void sm_dieCallback(SmcConn smcConn, SmPointer /* clientData */)
+{
+    if (smcConn != smcConnection)
+        return;
+    resetSmState();
+    QEvent quitEvent(QEvent::Quit);
+    QApplication::sendEvent(qApp, &quitEvent);
+}
+
+static void sm_shutdownCancelledCallback(SmcConn smcConn, SmPointer clientData)
+{
+    if (smcConn != smcConnection)
+        return;
+    if (sm_waitingForInteraction)
+        ((QSessionManagerPrivate *) clientData)->eventLoop->exit();
+    resetSmState();
+}
+
+static void sm_saveCompleteCallback(SmcConn smcConn, SmPointer /*clientData */)
+{
+    if (smcConn != smcConnection)
+        return;
+    resetSmState();
+}
+
+static void sm_interactCallback(SmcConn smcConn, SmPointer clientData)
+{
+    if (smcConn != smcConnection)
+        return;
+    if (sm_waitingForInteraction)
+        ((QSessionManagerPrivate *) clientData)->eventLoop->exit();
+}
+
+static void sm_saveYourselfPhase2Callback(SmcConn smcConn, SmPointer clientData)
+{
+    if (smcConn != smcConnection)
+        return;
+    sm_in_phase2 = true;
+    sm_performSaveYourself((QSessionManagerPrivate*) clientData);
+}
+
+
+void QSmSocketReceiver::socketActivated(int)
+{
+    IceProcessMessages(SmcGetIceConnection(smcConnection), 0, 0);
+}
+
+
+#undef Bool
+QT_BEGIN_INCLUDE_NAMESPACE
+#include "qapplication_x11.moc"
+QT_END_INCLUDE_NAMESPACE
+
+QSessionManager::QSessionManager(QApplication * app, QString &id, QString& key)
+    : QObject(*new QSessionManagerPrivate(this, id, key), app)
+{
+    Q_D(QSessionManager);
+    d->restartHint = RestartIfRunning;
+
+    resetSmState();
+    char cerror[256];
+    char* myId = 0;
+    QByteArray b_id = id.toLatin1();
+    char* prevId = b_id.data();
+
+    SmcCallbacks cb;
+    cb.save_yourself.callback = sm_saveYourselfCallback;
+    cb.save_yourself.client_data = (SmPointer) d;
+    cb.die.callback = sm_dieCallback;
+    cb.die.client_data = (SmPointer) d;
+    cb.save_complete.callback = sm_saveCompleteCallback;
+    cb.save_complete.client_data = (SmPointer) d;
+    cb.shutdown_cancelled.callback = sm_shutdownCancelledCallback;
+    cb.shutdown_cancelled.client_data = (SmPointer) d;
+
+    // avoid showing a warning message below
+    if (qgetenv("SESSION_MANAGER").isEmpty())
+        return;
+
+    smcConnection = SmcOpenConnection(0, 0, 1, 0,
+                                       SmcSaveYourselfProcMask |
+                                       SmcDieProcMask |
+                                       SmcSaveCompleteProcMask |
+                                       SmcShutdownCancelledProcMask,
+                                       &cb,
+                                       prevId,
+                                       &myId,
+                                       256, cerror);
+
+    id = QString::fromLatin1(myId);
+    ::free(myId); // it was allocated by C
+
+    QString error = QString::fromLocal8Bit(cerror);
+    if (!smcConnection) {
+        qWarning("Qt: Session management error: %s", qPrintable(error));
+    }
+    else {
+        sm_receiver = new QSmSocketReceiver(IceConnectionNumber(SmcGetIceConnection(smcConnection)));
+    }
+}
+
+QSessionManager::~QSessionManager()
+{
+    if (smcConnection)
+        SmcCloseConnection(smcConnection, 0, 0);
+    smcConnection = 0;
+    delete sm_receiver;
+}
+
+QString QSessionManager::sessionId() const
+{
+    Q_D(const QSessionManager);
+    return d->sessionId;
+}
+
+QString QSessionManager::sessionKey() const
+{
+    Q_D(const QSessionManager);
+    return d->sessionKey;
+}
+
+
+void* QSessionManager::handle() const
+{
+    return (void*) smcConnection;
+}
+
+
+bool QSessionManager::allowsInteraction()
+{
+    Q_D(QSessionManager);
+    if (sm_interactionActive)
+        return true;
+
+    if (sm_waitingForInteraction)
+        return false;
+
+    if (sm_interactStyle == SmInteractStyleAny) {
+        sm_waitingForInteraction =  SmcInteractRequest(smcConnection, SmDialogNormal,
+                                                        sm_interactCallback, (SmPointer*) d);
+    }
+    if (sm_waitingForInteraction) {
+        QEventLoop eventLoop;
+        d->eventLoop = &eventLoop;
+        (void) eventLoop.exec();
+        d->eventLoop = 0;
+
+        sm_waitingForInteraction = false;
+        if (sm_smActive) { // not cancelled
+            sm_interactionActive = true;
+            qt_sm_blockUserInput = false;
+            return true;
+        }
+    }
+    return false;
+}
+
+bool QSessionManager::allowsErrorInteraction()
+{
+    Q_D(QSessionManager);
+    if (sm_interactionActive)
+        return true;
+
+    if (sm_waitingForInteraction)
+        return false;
+
+    if (sm_interactStyle == SmInteractStyleAny || sm_interactStyle == SmInteractStyleErrors) {
+        sm_waitingForInteraction =  SmcInteractRequest(smcConnection, SmDialogError,
+                                                        sm_interactCallback, (SmPointer*) d);
+    }
+    if (sm_waitingForInteraction) {
+        QEventLoop eventLoop;
+        d->eventLoop = &eventLoop;
+        (void) eventLoop.exec();
+        d->eventLoop = 0;
+
+        sm_waitingForInteraction = false;
+        if (sm_smActive) { // not cancelled
+            sm_interactionActive = true;
+            qt_sm_blockUserInput = false;
+            return true;
+        }
+    }
+    return false;
+}
+
+void QSessionManager::release()
+{
+    if (sm_interactionActive) {
+        SmcInteractDone(smcConnection, False);
+        sm_interactionActive = false;
+        if (sm_smActive && sm_isshutdown)
+            qt_sm_blockUserInput = true;
+    }
+}
+
+void QSessionManager::cancel()
+{
+    sm_cancel = true;
+}
+
+void QSessionManager::setRestartHint(QSessionManager::RestartHint hint)
+{
+    Q_D(QSessionManager);
+    d->restartHint = hint;
+}
+
+QSessionManager::RestartHint QSessionManager::restartHint() const
+{
+    Q_D(const QSessionManager);
+    return d->restartHint;
+}
+
+void QSessionManager::setRestartCommand(const QStringList& command)
+{
+    Q_D(QSessionManager);
+    d->restartCommand = command;
+}
+
+QStringList QSessionManager::restartCommand() const
+{
+    Q_D(const QSessionManager);
+    return d->restartCommand;
+}
+
+void QSessionManager::setDiscardCommand(const QStringList& command)
+{
+    Q_D(QSessionManager);
+    d->discardCommand = command;
+}
+
+QStringList QSessionManager::discardCommand() const
+{
+    Q_D(const QSessionManager);
+    return d->discardCommand;
+}
+
+void QSessionManager::setManagerProperty(const QString& name, const QString& value)
+{
+    sm_setProperty(name, value);
+}
+
+void QSessionManager::setManagerProperty(const QString& name, const QStringList& value)
+{
+    sm_setProperty(name, value);
+}
+
+bool QSessionManager::isPhase2() const
+{
+    return sm_in_phase2;
+}
+
+void QSessionManager::requestPhase2()
+{
+    sm_phase2 = true;
+}
+
+#endif // QT_NO_SESSIONMANAGER
+
+#if defined(QT_RX71_MULTITOUCH)
+
+static inline int testBit(const char *array, int bit)
+{
+    return (array[bit/8] & (1<<(bit%8)));
+}
+
+static int openRX71Device(const QByteArray &deviceName)
+{
+    int fd = open(deviceName, O_RDONLY | O_NONBLOCK);
+    if (fd == -1) {
+        fd = -errno;
+        return fd;
+    }
+
+    // fetch the event type mask and check that the device reports absolute coordinates
+    char eventTypeMask[(EV_MAX + sizeof(char) - 1) * sizeof(char) + 1];
+    memset(eventTypeMask, 0, sizeof(eventTypeMask));
+    if (ioctl(fd, EVIOCGBIT(0, sizeof(eventTypeMask)), eventTypeMask) < 0) {
+        close(fd);
+        return -1;
+    }
+    if (!testBit(eventTypeMask, EV_ABS)) {
+        close(fd);
+        return -1;
+    }
+
+    // make sure that we can get the absolute X and Y positions from the device
+    char absMask[(ABS_MAX + sizeof(char) - 1) * sizeof(char) + 1];
+    memset(absMask, 0, sizeof(absMask));
+    if (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absMask)), absMask) < 0) {
+        close(fd);
+        return -1;
+    }
+    if (!testBit(absMask, ABS_X) || !testBit(absMask, ABS_Y)) {
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
+
+void QApplicationPrivate::initializeMultitouch_sys()
+{
+    Q_Q(QApplication);
+
+    QByteArray deviceName = QByteArray("/dev/input/event");
+    int currentDeviceNumber = 0;
+    for (;;) {
+        int fd = openRX71Device(QByteArray(deviceName + QByteArray::number(currentDeviceNumber++)));
+        if (fd == -ENOENT) {
+            // no more devices
+            break;
+        }
+        if (fd < 0) {
+            // not a touch device
+            continue;
+        }
+
+        struct input_absinfo abs_x, abs_y, abs_z;
+        ioctl(fd, EVIOCGABS(ABS_X), &abs_x);
+        ioctl(fd, EVIOCGABS(ABS_Y), &abs_y);
+        ioctl(fd, EVIOCGABS(ABS_Z), &abs_z);
+
+        int deviceNumber = allRX71TouchPoints.count();
+
+        QSocketNotifier *socketNotifier = new QSocketNotifier(fd, QSocketNotifier::Read, q);
+        QObject::connect(socketNotifier, SIGNAL(activated(int)), q, SLOT(_q_readRX71MultiTouchEvents()));
+
+        RX71TouchPointState touchPointState = {
+            socketNotifier,
+            QTouchEvent::TouchPoint(deviceNumber),
+
+            abs_x.minimum, abs_x.maximum, q->desktop()->screenGeometry().width(),
+            abs_y.minimum, abs_y.maximum, q->desktop()->screenGeometry().height(),
+            abs_z.minimum, abs_z.maximum
+        };
+        allRX71TouchPoints.append(touchPointState);
+    }
+
+    hasRX71MultiTouch = allRX71TouchPoints.count() > 1;
+    if (!hasRX71MultiTouch) {
+        for (int i = 0; i < allRX71TouchPoints.count(); ++i) {
+            QSocketNotifier *socketNotifier = allRX71TouchPoints.at(i).socketNotifier;
+            close(socketNotifier->socket());
+            delete socketNotifier;
+        }
+        allRX71TouchPoints.clear();
+    }
+}
+
+void QApplicationPrivate::cleanupMultitouch_sys()
+{
+    hasRX71MultiTouch = false;
+    for (int i = 0; i < allRX71TouchPoints.count(); ++i) {
+        QSocketNotifier *socketNotifier = allRX71TouchPoints.at(i).socketNotifier;
+        close(socketNotifier->socket());
+        delete socketNotifier;
+    }
+    allRX71TouchPoints.clear();
+}
+
+bool QApplicationPrivate::readRX71MultiTouchEvents(int deviceNumber)
+{
+    RX71TouchPointState &touchPointState = allRX71TouchPoints[deviceNumber];
+    QSocketNotifier *socketNotifier = touchPointState.socketNotifier;
+    int fd = socketNotifier->socket();
+
+    QTouchEvent::TouchPoint &touchPoint = touchPointState.touchPoint;
+
+    bool down = touchPoint.state() != Qt::TouchPointReleased;
+    if (down)
+        touchPoint.setState(Qt::TouchPointStationary);
+
+    bool changed = false;
+    for (;;) {
+        struct input_event inputEvent;
+        int bytesRead = read(fd, &inputEvent, sizeof(inputEvent));
+        if (bytesRead <= 0)
+            break;
+        if (bytesRead != sizeof(inputEvent)) {
+            qWarning("Qt: INTERNAL ERROR: short read in readRX71MultiTouchEvents()");
+            return false;
+        }
+
+        switch (inputEvent.type) {
+        case EV_SYN:
+            changed = true;
+            switch (touchPoint.state()) {
+            case Qt::TouchPointPressed:
+            case Qt::TouchPointReleased:
+                // make sure we don't compress pressed and releases with any other events
+                return changed;
+            default:
+                break;
+            }
+            continue;
+        case EV_KEY:
+        case EV_ABS:
+            break;
+        default:
+            qWarning("Qt: WARNING: unknown event type %d on multitouch device", inputEvent.type);
+            continue;
+        }
+
+        QPointF screenPos = touchPoint.screenPos();
+        switch (inputEvent.code) {
+        case BTN_TOUCH:
+            if (!down && inputEvent.value != 0)
+                touchPoint.setState(Qt::TouchPointPressed);
+            else if (down && inputEvent.value == 0)
+                touchPoint.setState(Qt::TouchPointReleased);
+            break;
+        case ABS_TOOL_WIDTH:
+        case ABS_VOLUME:
+        case ABS_PRESSURE:
+            // ignore for now
+            break;
+        case ABS_X:
+        {
+            qreal newValue = ((qreal(inputEvent.value - touchPointState.minX)
+                              / qreal(touchPointState.maxX - touchPointState.minX))
+                              * touchPointState.scaleX);
+            screenPos.rx() = newValue;
+            touchPoint.setScreenPos(screenPos);
+            break;
+        }
+        case ABS_Y:
+        {
+            qreal newValue = ((qreal(inputEvent.value - touchPointState.minY)
+                              / qreal(touchPointState.maxY - touchPointState.minY))
+                              * touchPointState.scaleY);
+            screenPos.ry() = newValue;
+            touchPoint.setScreenPos(screenPos);
+            break;
+        }
+        case ABS_Z:
+        {
+            // map Z (signal strength) to pressure for now
+            qreal newValue = (qreal(inputEvent.value - touchPointState.minZ)
+                              / qreal(touchPointState.maxZ - touchPointState.minZ));
+            touchPoint.setPressure(newValue);
+            break;
+        }
+        default:
+            qWarning("Qt: WARNING: unknown event code %d on multitouch device", inputEvent.code);
+            continue;
+        }
+    }
+
+    if (down && touchPoint.state() != Qt::TouchPointReleased)
+        touchPoint.setState(changed ? Qt::TouchPointMoved : Qt::TouchPointStationary);
+
+    return changed;
+}
+
+void QApplicationPrivate::_q_readRX71MultiTouchEvents()
+{
+    // read touch events from all devices
+    bool changed = false;
+    for (int i = 0; i < allRX71TouchPoints.count(); ++i)
+        changed = readRX71MultiTouchEvents(i) || changed;
+    if (!changed)
+        return;
+
+    QList<QTouchEvent::TouchPoint> touchPoints;
+    for (int i = 0; i < allRX71TouchPoints.count(); ++i)
+        touchPoints.append(allRX71TouchPoints.at(i).touchPoint);
+
+    translateRawTouchEvent(0, QTouchEvent::TouchScreen, touchPoints);
+}
+
+#else // !QT_RX71_MULTITOUCH
+
+void QApplicationPrivate::initializeMultitouch_sys()
+{ }
+void QApplicationPrivate::cleanupMultitouch_sys()
+{ }
+
+#endif // QT_RX71_MULTITOUCH
+
+QT_END_NAMESPACE
--- a/src/gui/kernel/qapplication_x11.cpp.rej
+++ b/src/gui/kernel/qapplication_x11.cpp.rej
@@ -0,0 +1,16 @@
+--- src/gui/kernel/qapplication_x11.cpp
++++ src/gui/kernel/qapplication_x11.cpp
+@@ -325,6 +323,13 @@
+     "STYLUS\0"
+     "ERASER\0"
+     "TABLET\0"
++
++    // XInput 2.1 touch
++    "Abs MT Touch Major\0"
++    "Abs MT Touch Minor\0"
++    "Abs MT Orientation\0"
++    "Abs MT Position X\0"
++    "Abs MT Position Y\0"
+ };
+ 
+ Q_GUI_EXPORT QX11Data *qt_x11Data = 0;
--- a/src/gui/kernel/qevent.h
+++ b/src/gui/kernel/qevent.h
@@ -800,6 +800,7 @@
         QTouchEventTouchPointPrivate *d;
         friend class QApplication;
         friend class QApplicationPrivate;
+        friend class QETWidget;
     };
 
     enum DeviceType {
--- a/src/gui/kernel/qt_x11_p.h
+++ b/src/gui/kernel/qt_x11_p.h
@@ -98,13 +98,15 @@
 #  include <X11/extensions/shape.h>
 #endif // QT_NO_SHAPE
 
-
+#if !defined(QT_NO_XINPUT2)
+#  include <X11/extensions/XInput2.h>
+#endif
 #if !defined (QT_NO_TABLET)
 #  include <X11/extensions/XInput.h>
-#if defined (Q_OS_IRIX)
-#  include <X11/extensions/SGIMisc.h>
-#  include <wacom.h>
-#endif
+#  if defined (Q_OS_IRIX)
+#    include <X11/extensions/SGIMisc.h>
+#    include <wacom.h>
+#  endif
 #endif // QT_NO_TABLET
 
 
@@ -438,11 +440,16 @@
     bool use_mitshm_pixmaps;
     int mitshm_major;
 
-    // true if Qt is compiled w/ Tablet support and we have a tablet.
+    // true if Qt is compiled w/ XInput2 or Tablet support and we have a tablet.
     bool use_xinput;
-    int xinput_major;
+    bool use_xinput2;
+    int xinput_opcode;
     int xinput_eventbase;
     int xinput_errorbase;
+#if !defined(QT_NO_XINPUT2)
+    XIDeviceInfo *xideviceinfo;
+    XITouchClassInfo *xitouchclassinfo;
+#endif
 
     // for XKEYBOARD support
     bool use_xkb;
@@ -689,6 +696,12 @@
         XTabletStylus,
         XTabletEraser,
 
+        XAbsMTTouchMajor,
+        XAbsMTTouchMinor,
+        XAbsMTOrientation,
+        XAbsMTPositionX,
+        XAbsMTPositionY,
+
         NPredefinedAtoms,
 
         _QT_SETTINGS_TIMESTAMP = NPredefinedAtoms,
--- a/src/gui/kernel/qt_x11_p.h.orig
+++ b/src/gui/kernel/qt_x11_p.h.orig
@@ -0,0 +1,760 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QT_X11_P_H
+#define QT_X11_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "QtGui/qwindowdefs.h"
+#include "QtCore/qhash.h"
+#include "QtCore/qlist.h"
+#include "QtCore/qvariant.h"
+
+// the following is necessary to work around breakage in many versions
+// of XFree86's Xlib.h still in use
+// ### which versions?
+#if defined(_XLIB_H_) // crude hack, but...
+#error "cannot include <X11/Xlib.h> before this file"
+#endif
+#define XRegisterIMInstantiateCallback qt_XRegisterIMInstantiateCallback
+#define XUnregisterIMInstantiateCallback qt_XUnregisterIMInstantiateCallback
+#define XSetIMValues qt_XSetIMValues
+#include <X11/Xlib.h>
+#undef XRegisterIMInstantiateCallback
+#undef XUnregisterIMInstantiateCallback
+#undef XSetIMValues
+
+#include <X11/Xutil.h>
+#include <X11/Xos.h>
+#ifdef index
+#  undef index
+#endif
+#ifdef rindex
+#  undef rindex
+#endif
+#ifdef Q_OS_VXWORS
+#  ifdef open
+#    undef open
+#  endif
+#  ifdef getpid
+#    undef getpid
+#  endif
+#endif // Q_OS_VXWORKS
+#include <X11/Xatom.h>
+
+//#define QT_NO_SHAPE
+#ifdef QT_NO_SHAPE
+#  define XShapeCombineRegion(a,b,c,d,e,f,g)
+#  define XShapeCombineMask(a,b,c,d,e,f,g)
+#else
+#  include <X11/extensions/shape.h>
+#endif // QT_NO_SHAPE
+
+
+#if !defined (QT_NO_TABLET)
+#  include <X11/extensions/XInput.h>
+#if defined (Q_OS_IRIX)
+#  include <X11/extensions/SGIMisc.h>
+#  include <wacom.h>
+#endif
+#endif // QT_NO_TABLET
+
+
+// #define QT_NO_XINERAMA
+#ifndef QT_NO_XINERAMA
+#  if 0 // ### Xsun, but how to detect it?
+// Xinerama is only supported in Solaris 7 with patches 107648/108376 and
+// Solaris 8 or above which introduce the X11R6.4 Xserver.
+// To switch the Xinerama functionality on, you need to add the "+xinerama"
+// argument to the Xsun start line.
+// At least Solaris 7 and 8 are missing Xinerama system headers and function
+// declarations (bug 4284701).
+// The Xinerama API is not documented. In theory it could change but it
+// probably won't because Sun are using it in at least dtlogin (bug 4221829).
+extern "C" Bool XPanoramiXQueryExtension(
+    Display*,
+    int*,
+    int*
+);
+extern "C" Status XPanoramiXQueryVersion(
+    Display*,
+    int*,
+    int*
+);
+extern "C" Status XPanoramiXGetState(
+    Display*,
+    Drawable,
+    XPanoramiXInfo*
+);
+extern "C" Status XPanoramiXGetScreenCount(
+    Display *,
+    Drawable,
+    XPanoramiXInfo*
+);
+extern "C" Status XPanoramiXGetScreenSize(
+    Display*,
+    Drawable,
+    int,
+    XPanoramiXInfo*
+);
+#  else // XFree86
+// XFree86 does not C++ify Xinerama (at least up to XFree86 4.0.3).
+extern "C" {
+#    include <X11/extensions/Xinerama.h>
+}
+#  endif
+#endif // QT_NO_XINERAMA
+
+// #define QT_NO_XRANDR
+#ifndef QT_NO_XRANDR
+#  include <X11/extensions/Xrandr.h>
+#endif // QT_NO_XRANDR
+
+// #define QT_NO_XRENDER
+#ifndef QT_NO_XRENDER
+#  include <X11/extensions/Xrender.h>
+#endif // QT_NO_XRENDER
+
+#ifndef QT_NO_XSYNC
+extern "C" {
+#  include "X11/extensions/sync.h"
+}
+#endif
+
+// #define QT_NO_XKB
+#ifndef QT_NO_XKB
+#  include <X11/XKBlib.h>
+#endif // QT_NO_XKB
+
+
+#if !defined(XlibSpecificationRelease)
+#  define X11R4
+typedef char *XPointer;
+#else
+#  undef X11R4
+#endif
+
+// #define QT_NO_XIM
+#if defined(X11R4)
+// X11R4 does not have XIM
+#define QT_NO_XIM
+#elif defined(Q_OS_OSF) && (XlibSpecificationRelease < 6)
+// broken in Xlib up to OSF/1 3.2
+#define QT_NO_XIM
+#elif defined(Q_OS_AIX)
+// broken in Xlib up to what version of AIX?
+#define QT_NO_XIM
+#elif defined(QT_NO_DEBUG) && defined(Q_OS_IRIX)
+// XmbLookupString broken on IRIX
+// XCreateIC broken when compiling -64 on IRIX 6.5.2
+#define QT_NO_XIM
+#elif defined(Q_OS_HPUX) && defined(__LP64__)
+// XCreateIC broken when compiling 64-bit ELF on HP-UX 11.0
+#define QT_NO_XIM
+#elif defined(Q_OS_SCO)
+// ### suggested by user...
+// ### #define QT_NO_XIM
+#endif // QT_NO_XIM
+
+#ifndef QT_NO_XFIXES
+typedef Bool (*PtrXFixesQueryExtension)(Display *, int *, int *);
+typedef Status (*PtrXFixesQueryVersion)(Display *, int *, int *);
+typedef void (*PtrXFixesSetCursorName)(Display *dpy, Cursor cursor, const char *name);
+typedef void (*PtrXFixesSelectSelectionInput)(Display *dpy, Window win, Atom selection, unsigned long eventMask);
+typedef void (*PtrXFixesDestroyRegion)(Display *dpy, /*XserverRegion*/ XID region);
+typedef /*XserverRegion*/ XID (*PtrXFixesCreateRegionFromWindow)(Display *dpy, Window window, int kind);
+typedef XRectangle *(*PtrXFixesFetchRegion)(Display *dpy, /*XserverRegion*/ XID region, int *nrectanglesRet);
+#endif // QT_NO_XFIXES
+
+#ifndef QT_NO_XCURSOR
+#include <X11/Xcursor/Xcursor.h>
+typedef Cursor (*PtrXcursorLibraryLoadCursor)(Display *, const char *);
+#endif // QT_NO_XCURSOR
+
+#ifndef QT_NO_XINERAMA
+typedef Bool (*PtrXineramaQueryExtension)(Display *dpy, int *event_base, int *error_base);
+typedef Bool (*PtrXineramaIsActive)(Display *dpy);
+typedef XineramaScreenInfo *(*PtrXineramaQueryScreens)(Display *dpy, int *number);
+#endif // QT_NO_XINERAMA
+
+#ifndef QT_NO_XRANDR
+typedef void (*PtrXRRSelectInput)(Display *, Window, int);
+typedef int (*PtrXRRUpdateConfiguration)(XEvent *);
+typedef int (*PtrXRRRootToScreen)(Display *, Window);
+typedef Bool (*PtrXRRQueryExtension)(Display *, int *, int *);
+#endif // QT_NO_XRANDR
+
+#ifndef QT_NO_XINPUT
+typedef int (*PtrXCloseDevice)(Display *, XDevice *);
+typedef XDeviceInfo* (*PtrXListInputDevices)(Display *, int *);
+typedef XDevice* (*PtrXOpenDevice)(Display *, XID);
+typedef void (*PtrXFreeDeviceList)(XDeviceInfo *);
+typedef int (*PtrXSelectExtensionEvent)(Display *, Window, XEventClass *, int);
+#endif // QT_NO_XINPUT
+
+/*
+ * Solaris patch 108652-47 and higher fixes crases in
+ * XRegisterIMInstantiateCallback, but the function doesn't seem to
+ * work.
+ *
+ * Instead, we disabled R6 input, and open the input method
+ * immediately at application start.
+ */
+#if !defined(QT_NO_XIM) && (XlibSpecificationRelease >= 6) && \
+    !defined(Q_OS_SOLARIS)
+#define USE_X11R6_XIM
+
+//######### XFree86 has wrong declarations for XRegisterIMInstantiateCallback
+//######### and XUnregisterIMInstantiateCallback in at least version 3.3.2.
+//######### Many old X11R6 header files lack XSetIMValues.
+//######### Therefore, we have to declare these functions ourselves.
+
+extern "C" Bool XRegisterIMInstantiateCallback(
+    Display*,
+    struct _XrmHashBucketRec*,
+    char*,
+    char*,
+    XIMProc, //XFree86 has XIDProc, which has to be wrong
+    XPointer
+);
+
+extern "C" Bool XUnregisterIMInstantiateCallback(
+    Display*,
+    struct _XrmHashBucketRec*,
+    char*,
+    char*,
+    XIMProc, //XFree86 has XIDProc, which has to be wrong
+    XPointer
+);
+
+extern "C" char *XSetIMValues(XIM /* im */, ...);
+
+#endif
+
+#ifndef QT_NO_FONTCONFIG
+#include <fontconfig/fontconfig.h>
+#endif
+
+#ifndef QT_NO_XIM
+// some platforms (eg. Solaris 2.51) don't have these defines in Xlib.h
+#ifndef XNResetState
+#define XNResetState "resetState"
+#endif
+#ifndef XIMPreserveState
+#define XIMPreserveState (1L<<1)
+#endif
+#endif
+
+
+#ifndef X11R4
+#  include <X11/Xlocale.h>
+#endif // X11R4
+
+
+#ifndef QT_NO_MITSHM
+#  include <X11/extensions/XShm.h>
+#endif // QT_NO_MITSHM
+
+QT_BEGIN_NAMESPACE
+
+class QWidget;
+
+struct QX11InfoData {
+    uint ref;
+    int screen;
+    int dpiX;
+    int dpiY;
+    int depth;
+    int cells;
+    Colormap colormap;
+    Visual *visual;
+    bool defaultColormap;
+    bool defaultVisual;
+    int subpixel;
+};
+
+class QDrag;
+struct QXdndDropTransaction
+{
+    Time timestamp;
+    Window target;
+    Window proxy_target;
+    QWidget *targetWidget;
+    QWidget *embedding_widget;
+    QDrag *object;
+};
+
+class QMimeData;
+
+struct QX11Data;
+extern Q_GUI_EXPORT QX11Data *qt_x11Data;
+
+enum DesktopEnvironment {
+    DE_UNKNOWN,
+    DE_KDE,
+    DE_GNOME,
+    DE_CDE,
+    DE_MEEGO_COMPOSITOR,
+    DE_4DWM
+};
+
+struct QX11Data
+{
+    static Qt::KeyboardModifiers translateModifiers(int s);
+
+    Window findClientWindow(Window, Atom, bool);
+
+    // from qclipboard_x11.cpp
+    bool clipboardWaitForEvent(Window win, int type, XEvent *event, int timeout, bool checkManager = false);
+    bool clipboardReadProperty(Window win, Atom property, bool deleteProperty,
+                            QByteArray *buffer, int *size, Atom *type, int *format);
+    QByteArray clipboardReadIncrementalProperty(Window win, Atom property, int nbytes, bool nullterm);
+
+    // from qdnd_x11.cpp
+    bool dndEnable(QWidget* w, bool on);
+    static void xdndSetup();
+    void xdndHandleEnter(QWidget *, const XEvent *, bool);
+    void xdndHandlePosition(QWidget *, const XEvent *, bool);
+    void xdndHandleStatus(QWidget *, const XEvent *, bool);
+    void xdndHandleLeave(QWidget *, const XEvent *, bool);
+    void xdndHandleDrop(QWidget *, const XEvent *, bool);
+    void xdndHandleFinished(QWidget *, const XEvent *, bool);
+    void xdndHandleSelectionRequest(const XSelectionRequestEvent *);
+    static bool xdndHandleBadwindow();
+    QByteArray xdndAtomToString(Atom a);
+    Atom xdndStringToAtom(const char *);
+
+    QString xdndMimeAtomToString(Atom a);
+    Atom xdndMimeStringToAtom(const QString &mimeType);
+    QStringList xdndMimeFormatsForAtom(Atom a);
+    bool xdndMimeDataForAtom(Atom a, QMimeData *mimeData, QByteArray *data, Atom *atomFormat, int *dataFormat);
+    QList<Atom> xdndMimeAtomsForFormat(const QString &format);
+    QVariant xdndMimeConvertToFormat(Atom a, const QByteArray &data, const QString &format, QVariant::Type requestedType, const QByteArray &encoding);
+    Atom xdndMimeAtomForFormat(const QString &format, QVariant::Type requestedType, const QList<Atom> &atoms, QByteArray *requestedEncoding);
+
+    QList<QXdndDropTransaction> dndDropTransactions;
+
+    // from qmotifdnd_x11.cpp
+    void motifdndHandle(QWidget *, const XEvent *, bool);
+    void motifdndEnable(QWidget *, bool);
+    QVariant motifdndObtainData(const char *format);
+    QByteArray motifdndFormat(int n);
+    bool motifdnd_active;
+
+    Display *display;
+    char *displayName;
+    bool foreignDisplay;
+    // current focus model
+    enum {
+        FM_Unknown = -1,
+        FM_Other = 0,
+        FM_PointerRoot = 1
+    };
+    int focus_model;
+
+    // true if Qt is compiled w/ RANDR support and RANDR is supported on the connected Display
+    bool use_xrandr;
+    int xrandr_major;
+    int xrandr_eventbase;
+    int xrandr_errorbase;
+
+    // true if Qt is compiled w/ RENDER support and RENDER is supported on the connected Display
+    bool use_xrender;
+    int xrender_major;
+    int xrender_version;
+
+    // true if Qt is compiled w/ XFIXES support and XFIXES is supported on the connected Display
+    bool use_xfixes;
+    int xfixes_major;
+    int xfixes_eventbase;
+    int xfixes_errorbase;
+
+#ifndef QT_NO_XFIXES
+    PtrXFixesQueryExtension ptrXFixesQueryExtension;
+    PtrXFixesQueryVersion ptrXFixesQueryVersion;
+    PtrXFixesSetCursorName ptrXFixesSetCursorName;
+    PtrXFixesSelectSelectionInput ptrXFixesSelectSelectionInput;
+#endif
+
+#ifndef QT_NO_XINPUT
+    PtrXCloseDevice ptrXCloseDevice;
+    PtrXListInputDevices ptrXListInputDevices;
+    PtrXOpenDevice ptrXOpenDevice;
+    PtrXFreeDeviceList ptrXFreeDeviceList;
+    PtrXSelectExtensionEvent ptrXSelectExtensionEvent;
+#endif // QT_NO_XINPUT
+
+
+    // true if Qt is compiled w/ MIT-SHM support and MIT-SHM is supported on the connected Display
+    bool use_mitshm;
+    bool use_mitshm_pixmaps;
+    int mitshm_major;
+
+    // true if Qt is compiled w/ Tablet support and we have a tablet.
+    bool use_xinput;
+    int xinput_major;
+    int xinput_eventbase;
+    int xinput_errorbase;
+
+    // for XKEYBOARD support
+    bool use_xkb;
+    int xkb_major;
+    int xkb_eventbase;
+    int xkb_errorbase;
+
+    QList<QWidget *> deferred_map;
+    struct ScrollInProgress {
+        long id;
+        QWidget* scrolled_widget;
+        int dx, dy;
+    };
+    long sip_serial;
+    QList<ScrollInProgress> sip_list;
+
+    // window managers list of supported "stuff"
+    Atom *net_supported_list;
+    // list of virtual root windows
+    Window *net_virtual_root_list;
+    // client leader window
+    Window wm_client_leader;
+
+    QX11InfoData *screens;
+    Visual **argbVisuals;
+    Colormap *argbColormaps;
+    int screenCount;
+    int defaultScreen;
+    QHash<int, int> bppForDepth;
+
+    Time time;
+    Time userTime;
+
+    QString default_im;
+
+    // starts to ignore bad window errors from X
+    static inline void ignoreBadwindow() {
+        qt_x11Data->ignore_badwindow = true;
+        qt_x11Data->seen_badwindow = false;
+    }
+
+    // ends ignoring bad window errors and returns whether an error had happened.
+    static inline bool badwindow() {
+        qt_x11Data->ignore_badwindow = false;
+        return qt_x11Data->seen_badwindow;
+    }
+
+    bool ignore_badwindow;
+    bool seen_badwindow;
+
+    // options
+    int visual_class;
+    int visual_id;
+    int color_count;
+    bool custom_cmap;
+
+    // outside visual/colormap
+    Visual *visual;
+    Colormap colormap;
+
+#ifndef QT_NO_XRENDER
+    enum { solid_fill_count = 16 };
+    struct SolidFills {
+        XRenderColor color;
+        int screen;
+        Picture picture;
+    } solid_fills[solid_fill_count];
+    enum { pattern_fill_count = 16 };
+    struct PatternFills {
+        XRenderColor color;
+        XRenderColor bg_color;
+        int screen;
+        int style;
+        bool opaque;
+        Picture picture;
+    } pattern_fills[pattern_fill_count];
+    Picture getSolidFill(int screen, const QColor &c);
+    XRenderColor preMultiply(const QColor &c);
+#endif
+
+    bool has_fontconfig;
+    qreal fc_scale;
+    bool fc_antialias;
+    int fc_hint_style;
+
+    char *startupId;
+
+    DesktopEnvironment desktopEnvironment : 8;
+    uint desktopVersion : 8;  /* Used only for KDE */
+
+    /* Warning: if you modify this list, modify the names of atoms in qapplication_x11.cpp as well! */
+    enum X11Atom {
+        // window-manager <-> client protocols
+        WM_PROTOCOLS,
+        WM_DELETE_WINDOW,
+        WM_TAKE_FOCUS,
+        _NET_WM_PING,
+        _NET_WM_CONTEXT_HELP,
+        _NET_WM_SYNC_REQUEST,
+        _NET_WM_SYNC_REQUEST_COUNTER,
+
+        // ICCCM window state
+        WM_STATE,
+        WM_CHANGE_STATE,
+
+        // Session management
+        WM_CLIENT_LEADER,
+        WM_WINDOW_ROLE,
+        SM_CLIENT_ID,
+
+        // Clipboard
+        CLIPBOARD,
+        INCR,
+        TARGETS,
+        MULTIPLE,
+        TIMESTAMP,
+        SAVE_TARGETS,
+        CLIP_TEMPORARY,
+        _QT_SELECTION,
+        _QT_CLIPBOARD_SENTINEL,
+        _QT_SELECTION_SENTINEL,
+        CLIPBOARD_MANAGER,
+
+        RESOURCE_MANAGER,
+
+        _XSETROOT_ID,
+
+        _QT_SCROLL_DONE,
+        _QT_INPUT_ENCODING,
+
+        _MOTIF_WM_HINTS,
+
+        DTWM_IS_RUNNING,
+        ENLIGHTENMENT_DESKTOP,
+        _DT_SAVE_MODE,
+        _SGI_DESKS_MANAGER,
+
+        // EWMH (aka NETWM)
+        _NET_SUPPORTED,
+        _NET_VIRTUAL_ROOTS,
+        _NET_WORKAREA,
+
+        _NET_MOVERESIZE_WINDOW,
+        _NET_WM_MOVERESIZE,
+
+        _NET_WM_NAME,
+        _NET_WM_ICON_NAME,
+        _NET_WM_ICON,
+
+        _NET_WM_PID,
+
+        _NET_WM_WINDOW_OPACITY,
+
+        _NET_WM_STATE,
+        _NET_WM_STATE_ABOVE,
+        _NET_WM_STATE_BELOW,
+        _NET_WM_STATE_FULLSCREEN,
+        _NET_WM_STATE_MAXIMIZED_HORZ,
+        _NET_WM_STATE_MAXIMIZED_VERT,
+        _NET_WM_STATE_MODAL,
+        _NET_WM_STATE_STAYS_ON_TOP,
+        _NET_WM_STATE_DEMANDS_ATTENTION,
+
+        _NET_WM_USER_TIME,
+        _NET_WM_USER_TIME_WINDOW,
+        _NET_WM_FULL_PLACEMENT,
+
+        _NET_WM_WINDOW_TYPE,
+        _NET_WM_WINDOW_TYPE_DESKTOP,
+        _NET_WM_WINDOW_TYPE_DOCK,
+        _NET_WM_WINDOW_TYPE_TOOLBAR,
+        _NET_WM_WINDOW_TYPE_MENU,
+        _NET_WM_WINDOW_TYPE_UTILITY,
+        _NET_WM_WINDOW_TYPE_SPLASH,
+        _NET_WM_WINDOW_TYPE_DIALOG,
+        _NET_WM_WINDOW_TYPE_DROPDOWN_MENU,
+        _NET_WM_WINDOW_TYPE_POPUP_MENU,
+        _NET_WM_WINDOW_TYPE_TOOLTIP,
+        _NET_WM_WINDOW_TYPE_NOTIFICATION,
+        _NET_WM_WINDOW_TYPE_COMBO,
+        _NET_WM_WINDOW_TYPE_DND,
+        _NET_WM_WINDOW_TYPE_NORMAL,
+        _KDE_NET_WM_WINDOW_TYPE_OVERRIDE,
+
+        _KDE_NET_WM_FRAME_STRUT,
+
+        _NET_STARTUP_INFO,
+        _NET_STARTUP_INFO_BEGIN,
+
+        _NET_SUPPORTING_WM_CHECK,
+
+        _NET_WM_CM_S0,
+
+        _NET_SYSTEM_TRAY_VISUAL,
+
+        _NET_ACTIVE_WINDOW,
+
+        // Property formats
+        COMPOUND_TEXT,
+        TEXT,
+        UTF8_STRING,
+
+        // Xdnd
+        XdndEnter,
+        XdndPosition,
+        XdndStatus,
+        XdndLeave,
+        XdndDrop,
+        XdndFinished,
+        XdndTypelist,
+        XdndActionList,
+
+        XdndSelection,
+
+        XdndAware,
+        XdndProxy,
+
+        XdndActionCopy,
+        XdndActionLink,
+        XdndActionMove,
+        XdndActionPrivate,
+
+        // Motif DND
+        _MOTIF_DRAG_AND_DROP_MESSAGE,
+        _MOTIF_DRAG_INITIATOR_INFO,
+        _MOTIF_DRAG_RECEIVER_INFO,
+        _MOTIF_DRAG_WINDOW,
+        _MOTIF_DRAG_TARGETS,
+
+        XmTRANSFER_SUCCESS,
+        XmTRANSFER_FAILURE,
+
+        // Xkb
+        _XKB_RULES_NAMES,
+
+        // XEMBED
+        _XEMBED,
+        _XEMBED_INFO,
+
+        XWacomStylus,
+        XWacomCursor,
+        XWacomEraser,
+
+        XTabletStylus,
+        XTabletEraser,
+
+        NPredefinedAtoms,
+
+        _QT_SETTINGS_TIMESTAMP = NPredefinedAtoms,
+        NAtoms
+    };
+    Atom atoms[NAtoms];
+
+    bool isSupportedByWM(Atom atom);
+
+    bool compositingManagerRunning;
+
+#ifndef QT_NO_XCURSOR
+    PtrXcursorLibraryLoadCursor ptrXcursorLibraryLoadCursor;
+#endif // QT_NO_XCURSOR
+
+#ifndef QT_NO_XINERAMA
+    PtrXineramaQueryExtension ptrXineramaQueryExtension;
+    PtrXineramaIsActive ptrXineramaIsActive;
+    PtrXineramaQueryScreens ptrXineramaQueryScreens;
+#endif // QT_NO_XINERAMA
+
+#ifndef QT_NO_XRANDR
+    PtrXRRSelectInput ptrXRRSelectInput;
+    PtrXRRUpdateConfiguration ptrXRRUpdateConfiguration;
+    PtrXRRRootToScreen ptrXRRRootToScreen;
+    PtrXRRQueryExtension ptrXRRQueryExtension;
+#endif // QT_NO_XRANDR
+};
+
+extern QX11Data *qt_x11Data;
+#define ATOM(x) qt_x11Data->atoms[QX11Data::x]
+#define X11 qt_x11Data
+
+// rename a couple of X defines to get rid of name clashes
+// resolve the conflict between X11's FocusIn and QEvent::FocusIn
+enum {
+    XFocusOut = FocusOut,
+    XFocusIn = FocusIn,
+    XKeyPress = KeyPress,
+    XKeyRelease = KeyRelease,
+    XNone = None,
+    XRevertToParent = RevertToParent,
+    XGrayScale = GrayScale,
+    XCursorShape = CursorShape
+};
+#undef FocusOut
+#undef FocusIn
+#undef KeyPress
+#undef KeyRelease
+#undef None
+#undef RevertToParent
+#undef GrayScale
+#undef CursorShape
+
+#ifdef FontChange
+#undef FontChange
+#endif
+
+Q_DECLARE_TYPEINFO(XPoint, Q_PRIMITIVE_TYPE);
+Q_DECLARE_TYPEINFO(XRectangle, Q_PRIMITIVE_TYPE);
+Q_DECLARE_TYPEINFO(XChar2b, Q_PRIMITIVE_TYPE);
+#ifndef QT_NO_XRENDER
+Q_DECLARE_TYPEINFO(XGlyphElt32, Q_PRIMITIVE_TYPE);
+#endif
+
+
+QT_END_NAMESPACE
+
+#endif // QT_X11_P_H
--- a/src/gui/kernel/qwidget.cpp
+++ b/src/gui/kernel/qwidget.cpp
@@ -11007,7 +11007,7 @@
 #endif
         break;
     case Qt::WA_AcceptTouchEvents:
-#if defined(Q_WS_WIN) || defined(Q_WS_MAC) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_WIN) || defined(Q_WS_MAC) || defined(Q_OS_SYMBIAN) || defined(Q_WS_X11)
         if (on)
             d->registerTouchWindow();
 #endif
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -791,6 +791,7 @@
     void updateX11AcceptFocus();
     QPoint mapToGlobal(const QPoint &pos) const;
     QPoint mapFromGlobal(const QPoint &pos) const;
+    void registerTouchWindow();
 #elif defined(Q_WS_WIN) // <--------------------------------------------------------- WIN
     uint noPaintOnScreen : 1; // see qwidget_win.cpp ::paintEngine()
 #ifndef QT_NO_GESTURES
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -870,7 +870,13 @@
 //         else
         XSelectInput(dpy, id, stdDesktopEventMask);
     } else if (q->internalWinId()) {
-        XSelectInput(dpy, id, stdWidgetEventMask);
+        uint eventmask = stdWidgetEventMask;
+
+        if (q->testAttribute(Qt::WA_AcceptTouchEvents))
+            registerTouchWindow();
+
+        XSelectInput(dpy, id, eventmask);
+
 #if !defined (QT_NO_TABLET)
         QTabletDeviceDataList *tablet_list = qt_tablet_devices();
         if (X11->ptrXSelectExtensionEvent) {
@@ -946,6 +952,9 @@
             surface->flush(q, q->rect(), q->mapTo(surface->window(), QPoint()));
     }
 
+    if (q->testAttribute(Qt::WA_AcceptTouchEvents))
+        registerTouchWindow();
+
 #ifdef ALIEN_DEBUG
     qDebug() << "QWidgetPrivate::create_sys END:" << q;
 #endif
@@ -3140,4 +3149,32 @@
         XFree((char *)h);
 }
 
+void QWidgetPrivate::registerTouchWindow()
+{
+#if !defined(QT_NO_XINPUT2)
+    Q_Q(QWidget);
+
+    if (!q->testAttribute(Qt::WA_WState_Created) || q->windowType() == Qt::Desktop)
+        return;
+
+    if (X11->use_xinput2) {
+        XIEventMask xieventmask;
+
+        const int mask_len = XIMaskLen(XI_LASTEVENT);
+        QVector<uchar> mask_vector(mask_len, 0);
+        uchar *bitmask = mask_vector.data();
+
+        xieventmask.deviceid = XIAllMasterDevices;
+        xieventmask.mask = bitmask;
+        xieventmask.mask_len = mask_len;
+
+        XISetMask(bitmask, XI_TouchBegin);
+        XISetMask(bitmask, XI_TouchEnd);
+        XISetMask(bitmask, XI_TouchUpdate);
+
+        XISelectEvents(X11->display, q->effectiveWinId(), &xieventmask, 1);
+    }
+#endif
+}
+
 QT_END_NAMESPACE
--- a/src/gui/kernel/qwidget_x11.cpp.orig
+++ b/src/gui/kernel/qwidget_x11.cpp.orig
@@ -0,0 +1,3143 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qevent.h"
+#include "qwidget.h"
+#include "qdesktopwidget.h"
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qabstracteventdispatcher.h"
+#include "qnamespace.h"
+#include "qpainter.h"
+#include "qbitmap.h"
+#include "qlayout.h"
+#include "qtextcodec.h"
+#include "qelapsedtimer.h"
+#include "qcursor.h"
+#include "qstack.h"
+#include "qcolormap.h"
+#include "qdebug.h"
+#include "qmenu.h"
+#include "private/qmenu_p.h"
+#include "private/qbackingstore_p.h"
+#include "private/qwindowsurface_x11_p.h"
+
+//extern bool qt_sendSpontaneousEvent(QObject *, QEvent *); //qapplication_x11.cpp
+
+#include <private/qpixmap_x11_p.h>
+#include <private/qpaintengine_x11_p.h>
+#include "qt_x11_p.h"
+#include "qx11info_x11.h"
+
+#include <stdlib.h>
+
+//#define ALIEN_DEBUG
+
+// defined in qapplication_x11.cpp
+//bool qt_wstate_iconified(WId);
+//void qt_updated_rootinfo();
+
+
+#if !defined(QT_NO_IM)
+#include "qinputcontext.h"
+#include "qinputcontextfactory.h"
+#endif
+
+#include "qwidget_p.h"
+
+#define XCOORD_MAX 16383
+#define WRECT_MAX 8191
+
+QT_BEGIN_NAMESPACE
+
+extern bool qt_nograb();
+
+QWidget *QWidgetPrivate::mouseGrabber = 0;
+QWidget *QWidgetPrivate::keyboardGrabber = 0;
+
+void qt_net_remove_user_time(QWidget *tlw);
+void qt_net_update_user_time(QWidget *tlw, unsigned long timestamp);
+
+int qt_x11_create_desktop_on_screen = -1;
+
+extern void qt_net_update_user_time(QWidget *tlw, unsigned long timestamp);
+
+// MWM support
+struct QtMWMHints {
+    ulong flags, functions, decorations;
+    long input_mode;
+    ulong status;
+};
+
+enum {
+    MWM_HINTS_FUNCTIONS   = (1L << 0),
+
+    MWM_FUNC_ALL      = (1L << 0),
+    MWM_FUNC_RESIZE   = (1L << 1),
+    MWM_FUNC_MOVE     = (1L << 2),
+    MWM_FUNC_MINIMIZE = (1L << 3),
+    MWM_FUNC_MAXIMIZE = (1L << 4),
+    MWM_FUNC_CLOSE    = (1L << 5),
+
+    MWM_HINTS_DECORATIONS = (1L << 1),
+
+    MWM_DECOR_ALL      = (1L << 0),
+    MWM_DECOR_BORDER   = (1L << 1),
+    MWM_DECOR_RESIZEH  = (1L << 2),
+    MWM_DECOR_TITLE    = (1L << 3),
+    MWM_DECOR_MENU     = (1L << 4),
+    MWM_DECOR_MINIMIZE = (1L << 5),
+    MWM_DECOR_MAXIMIZE = (1L << 6),
+
+    MWM_HINTS_INPUT_MODE = (1L << 2),
+
+    MWM_INPUT_MODELESS                  = 0L,
+    MWM_INPUT_PRIMARY_APPLICATION_MODAL = 1L,
+    MWM_INPUT_FULL_APPLICATION_MODAL    = 3L
+};
+
+
+static QtMWMHints GetMWMHints(Display *display, Window window)
+{
+    QtMWMHints mwmhints;
+
+    Atom type;
+    int format;
+    ulong nitems, bytesLeft;
+    uchar *data = 0;
+    if ((XGetWindowProperty(display, window, ATOM(_MOTIF_WM_HINTS), 0, 5, false,
+                            ATOM(_MOTIF_WM_HINTS), &type, &format, &nitems, &bytesLeft,
+                            &data) == Success)
+        && (type == ATOM(_MOTIF_WM_HINTS)
+            && format == 32
+            && nitems >= 5)) {
+        mwmhints = *(reinterpret_cast<QtMWMHints *>(data));
+    } else {
+        mwmhints.flags = 0L;
+        mwmhints.functions = MWM_FUNC_ALL;
+        mwmhints.decorations = MWM_DECOR_ALL;
+        mwmhints.input_mode = 0L;
+        mwmhints.status = 0L;
+    }
+
+    if (data)
+        XFree(data);
+
+    return mwmhints;
+}
+
+static void SetMWMHints(Display *display, Window window, const QtMWMHints &mwmhints)
+{
+    if (mwmhints.flags != 0l) {
+        XChangeProperty(display, window, ATOM(_MOTIF_WM_HINTS), ATOM(_MOTIF_WM_HINTS), 32,
+                        PropModeReplace, (unsigned char *) &mwmhints, 5);
+    } else {
+        XDeleteProperty(display, window, ATOM(_MOTIF_WM_HINTS));
+    }
+}
+
+// Returns true if we should set WM_TRANSIENT_FOR on \a w
+static inline bool isTransient(const QWidget *w)
+{
+    return ((w->windowType() == Qt::Dialog
+             || w->windowType() == Qt::Sheet
+             || w->windowType() == Qt::Tool
+             || w->windowType() == Qt::SplashScreen
+             || w->windowType() == Qt::ToolTip
+             || w->windowType() == Qt::Drawer
+             || w->windowType() == Qt::Popup)
+            && !w->testAttribute(Qt::WA_X11BypassTransientForHint));
+}
+
+static void do_size_hints(QWidget* widget, QWExtra *x);
+
+/*****************************************************************************
+  QWidget member functions
+ *****************************************************************************/
+
+const uint stdWidgetEventMask =                        // X event mask
+        (uint)(
+            KeyPressMask | KeyReleaseMask |
+            ButtonPressMask | ButtonReleaseMask |
+            KeymapStateMask |
+            ButtonMotionMask | PointerMotionMask |
+            EnterWindowMask | LeaveWindowMask |
+            FocusChangeMask |
+            ExposureMask |
+            PropertyChangeMask |
+            StructureNotifyMask
+       );
+
+const uint stdDesktopEventMask =                        // X event mask
+       (uint)(
+           KeymapStateMask |
+           EnterWindowMask | LeaveWindowMask |
+           PropertyChangeMask
+      );
+
+
+/*
+  The qt_ functions below are implemented in qwidgetcreate_x11.cpp.
+*/
+
+Window qt_XCreateWindow(const QWidget *creator,
+                         Display *display, Window parent,
+                         int x, int y, uint w, uint h,
+                         int borderwidth, int depth,
+                         uint windowclass, Visual *visual,
+                         ulong valuemask, XSetWindowAttributes *attributes);
+Window qt_XCreateSimpleWindow(const QWidget *creator,
+                               Display *display, Window parent,
+                               int x, int y, uint w, uint h, int borderwidth,
+                               ulong border, ulong background);
+void qt_XDestroyWindow(const QWidget *destroyer,
+                        Display *display, Window window);
+
+
+static void qt_insert_sip(QWidget* scrolled_widget, int dx, int dy)
+{
+    if (!scrolled_widget->isWindow() && !scrolled_widget->internalWinId())
+        return;
+    QX11Data::ScrollInProgress sip = { X11->sip_serial++, scrolled_widget, dx, dy };
+    X11->sip_list.append(sip);
+
+    XClientMessageEvent client_message;
+    client_message.type = ClientMessage;
+    client_message.window = scrolled_widget->internalWinId();
+    client_message.format = 32;
+    client_message.message_type = ATOM(_QT_SCROLL_DONE);
+    client_message.data.l[0] = sip.id;
+
+    XSendEvent(X11->display, scrolled_widget->internalWinId(), False, NoEventMask,
+        (XEvent*)&client_message);
+}
+
+static int qt_sip_count(QWidget* scrolled_widget)
+{
+    int sips=0;
+
+    for (int i = 0; i < X11->sip_list.size(); ++i) {
+        const QX11Data::ScrollInProgress &sip = X11->sip_list.at(i);
+        if (sip.scrolled_widget == scrolled_widget)
+            sips++;
+    }
+
+    return sips;
+}
+
+static void create_wm_client_leader()
+{
+    if (X11->wm_client_leader) return;
+
+    X11->wm_client_leader =
+        XCreateSimpleWindow(X11->display,
+                             QX11Info::appRootWindow(),
+                             0, 0, 1, 1, 0, 0, 0);
+
+    // set client leader property to itself
+    XChangeProperty(X11->display,
+                     X11->wm_client_leader, ATOM(WM_CLIENT_LEADER),
+                     XA_WINDOW, 32, PropModeReplace,
+                     (unsigned char *)&X11->wm_client_leader, 1);
+
+#ifndef QT_NO_SESSIONMANAGER
+    // If we are session managed, inform the window manager about it
+    QByteArray session = qApp->sessionId().toLatin1();
+    if (!session.isEmpty()) {
+        XChangeProperty(X11->display,
+                         X11->wm_client_leader, ATOM(SM_CLIENT_ID),
+                         XA_STRING, 8, PropModeReplace,
+                         (unsigned char *)session.data(), session.size());
+    }
+#endif
+}
+
+/*!
+   \internal
+   Update the X11 cursor of the widget w.
+   \a force is true if this function is called from dispatchEnterLeave, it means that the
+   mouse is actually directly under this widget.
+ */
+void qt_x11_enforce_cursor(QWidget * w, bool force)
+{
+    if (!w->testAttribute(Qt::WA_WState_Created))
+        return;
+
+    static QPointer<QWidget> lastUnderMouse = 0;
+    if (force) {
+        lastUnderMouse = w;
+    } else if (lastUnderMouse && lastUnderMouse->effectiveWinId() == w->effectiveWinId()) {
+        w = lastUnderMouse;
+    } else if (!w->internalWinId()) {
+        return; //the mouse is not under this widget, and it's not native, so don't change it
+    }
+
+    while (!w->internalWinId() && w->parentWidget() && !w->isWindow() && !w->testAttribute(Qt::WA_SetCursor))
+        w = w->parentWidget();
+
+    QWidget *nativeParent = w;
+    if (!w->internalWinId())
+        nativeParent = w->nativeParentWidget();
+    // This does the same as effectiveWinId(), but since it is possible
+    // to not have a native parent widget due to a special hack in
+    // qwidget for reparenting widgets to a different X11 screen,
+    // added additional check to make sure native parent widget exists.
+    if (!nativeParent || !nativeParent->internalWinId())
+        return;
+    WId winid = nativeParent->internalWinId();
+
+    if (w->isWindow() || w->testAttribute(Qt::WA_SetCursor)) {
+#ifndef QT_NO_CURSOR
+        QCursor *oc = QApplication::overrideCursor();
+        if (oc) {
+            XDefineCursor(X11->display, winid, oc->handle());
+        } else if (w->isEnabled()) {
+            XDefineCursor(X11->display, winid, w->cursor().handle());
+        } else {
+            // enforce the windows behavior of clearing the cursor on
+            // disabled widgets
+            XDefineCursor(X11->display, winid, XNone);
+        }
+#endif
+    } else {
+        XDefineCursor(X11->display, winid, XNone);
+    }
+}
+
+Q_GUI_EXPORT void qt_x11_enforce_cursor(QWidget * w)
+{
+    qt_x11_enforce_cursor(w, false);
+}
+
+void qt_x11_wait_for_window_manager(QWidget *w, bool sendPostedEvents)
+{
+    if (!w || (!w->isWindow() && !w->internalWinId()))
+        return;
+    QApplication::flush();
+    XEvent ev;
+    QElapsedTimer t;
+    t.start();
+    static const int maximumWaitTime = 2000;
+    if (!w->testAttribute(Qt::WA_WState_Created))
+        return;
+
+    WId winid = w->internalWinId();
+
+    // first deliver events that are already in the local queue
+    if (sendPostedEvents)
+        QApplication::sendPostedEvents();
+
+    // the normal sequence is:
+    //  ... ConfigureNotify ... ReparentNotify ... MapNotify ... Expose
+    // with X11BypassWindowManagerHint:
+    //  ConfigureNotify ... MapNotify ... Expose
+
+    enum State {
+        Initial, Mapped
+    } state = Initial;
+
+    do {
+        if (XEventsQueued(X11->display, QueuedAlready)) {
+            XNextEvent(X11->display, &ev);
+            // Pass the event through the event dispatcher filter so that applications
+            // which install an event filter on the dispatcher get to handle it first.
+            if (!QAbstractEventDispatcher::instance()->filterEvent(&ev)) {
+                qApp->x11ProcessEvent(&ev);
+
+                switch (state) {
+                case Initial:
+                    if (ev.type == MapNotify && ev.xany.window == winid)
+                        state = Mapped;
+                    break;
+                case Mapped:
+                    if (ev.type == Expose && ev.xany.window == winid)
+                        return;
+                    break;
+                }
+            }
+        } else {
+            if (!XEventsQueued(X11->display, QueuedAfterFlush))
+                qApp->syncX(); // non-busy wait
+        }
+        if (t.elapsed() > maximumWaitTime)
+            return;
+    } while(1);
+}
+
+Q_GUI_EXPORT void qt_x11_wait_for_window_manager(QWidget *w)
+{
+    qt_x11_wait_for_window_manager(w, true);
+}
+
+void qt_change_net_wm_state(const QWidget* w, bool set, Atom one, Atom two = 0)
+{
+    if (!w->isVisible()) // not managed by the window manager
+        return;
+
+    XEvent e;
+    e.xclient.type = ClientMessage;
+    e.xclient.message_type = ATOM(_NET_WM_STATE);
+    e.xclient.display = X11->display;
+    e.xclient.window = w->internalWinId();
+    e.xclient.format = 32;
+    e.xclient.data.l[0] = set ? 1 : 0;
+    e.xclient.data.l[1] = one;
+    e.xclient.data.l[2] = two;
+    e.xclient.data.l[3] = 0;
+    e.xclient.data.l[4] = 0;
+    XSendEvent(X11->display, RootWindow(X11->display, w->x11Info().screen()),
+               false, (SubstructureNotifyMask | SubstructureRedirectMask), &e);
+}
+
+struct QX11WindowAttributes {
+    const XWindowAttributes *att;
+};
+
+void qt_x11_getX11InfoForWindow(QX11Info * xinfo, const XWindowAttributes &a)
+{
+    QX11WindowAttributes att;
+    att.att = &a;
+    qt_x11_getX11InfoForWindow(xinfo,att);
+}
+
+
+static QVector<Atom> getNetWmState(QWidget *w)
+{
+    QVector<Atom> returnValue;
+
+    // Don't read anything, just get the size of the property data
+    Atom actualType;
+    int actualFormat;
+    ulong propertyLength;
+    ulong bytesLeft;
+    uchar *propertyData = 0;
+    if (XGetWindowProperty(X11->display, w->internalWinId(), ATOM(_NET_WM_STATE), 0, 0,
+                           False, XA_ATOM, &actualType, &actualFormat,
+                           &propertyLength, &bytesLeft, &propertyData) == Success
+        && actualType == XA_ATOM && actualFormat == 32) {
+        returnValue.resize(bytesLeft / 4);
+        XFree((char*) propertyData);
+        propertyData = 0;
+
+        // fetch all data
+        if (XGetWindowProperty(X11->display, w->internalWinId(), ATOM(_NET_WM_STATE), 0,
+                               returnValue.size(), False, XA_ATOM, &actualType, &actualFormat,
+                               &propertyLength, &bytesLeft, &propertyData) != Success) {
+            returnValue.clear();
+        } else if (propertyLength != (ulong)returnValue.size()) {
+            returnValue.resize(propertyLength);
+        }
+
+        // put it into netWmState
+        if (!returnValue.isEmpty()) {
+            memcpy(returnValue.data(), propertyData, returnValue.size() * sizeof(Atom));
+        }
+        if (propertyData)
+            XFree((char*) propertyData);
+    }
+
+    return returnValue;
+}
+
+void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyOldWindow)
+{
+    Q_Q(QWidget);
+    Qt::WindowType type = q->windowType();
+    Qt::WindowFlags &flags = data.window_flags;
+    QWidget *parentWidget = q->parentWidget();
+
+    if (type == Qt::ToolTip)
+        flags |= Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint;
+    if (type == Qt::Popup)
+        flags |= Qt::X11BypassWindowManagerHint;
+
+    bool topLevel = (flags & Qt::Window);
+    bool popup = (type == Qt::Popup);
+    bool desktop = (type == Qt::Desktop);
+    bool tool = (type == Qt::Tool || type == Qt::SplashScreen
+                 || type == Qt::ToolTip || type == Qt::Drawer);
+
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::create_sys START:" << q << "topLevel?" << topLevel << "WId:"
+             << window << "initializeWindow:" << initializeWindow << "destroyOldWindow" << destroyOldWindow;
+#endif
+    if (topLevel) {
+        if (parentWidget) { // if our parent stays on top, so must we
+            QWidget *ptl = parentWidget->window();
+            if(ptl && (ptl->windowFlags() & Qt::WindowStaysOnTopHint))
+                flags |= Qt::WindowStaysOnTopHint;
+        }
+
+        if (type == Qt::SplashScreen) {
+            if (X11->isSupportedByWM(ATOM(_NET_WM_WINDOW_TYPE_SPLASH))) {
+                flags &= ~Qt::X11BypassWindowManagerHint;
+            } else {
+                flags |= Qt::X11BypassWindowManagerHint | Qt::FramelessWindowHint;
+            }
+        }
+        // All these buttons depend on the system menu, so we enable it
+        if (flags & (Qt::WindowMinimizeButtonHint
+                     | Qt::WindowMaximizeButtonHint
+                     | Qt::WindowContextHelpButtonHint))
+            flags |= Qt::WindowSystemMenuHint;
+    }
+
+
+    Window parentw, destroyw = 0;
+    WId id = 0;
+
+    // always initialize
+    if (!window)
+        initializeWindow = true;
+
+    QX11Info *parentXinfo = parentWidget ? &parentWidget->d_func()->xinfo : 0;
+
+    if (desktop &&
+        qt_x11_create_desktop_on_screen >= 0 &&
+        qt_x11_create_desktop_on_screen != xinfo.screen()) {
+        // desktop on a certain screen other than the default requested
+        QX11InfoData *xd = &X11->screens[qt_x11_create_desktop_on_screen];
+        xinfo.setX11Data(xd);
+    } else if (parentXinfo && (parentXinfo->screen() != xinfo.screen()
+                               || (parentXinfo->visual() != xinfo.visual()
+                                   && !q->inherits("QGLWidget"))))
+    {
+        // QGLWidgets have to be excluded here as they have a
+        // specially crafted QX11Info structure which can't be swapped
+        // out with the parent widgets QX11Info. The parent visual,
+        // for instance, might not even be GL capable.
+        xinfo = *parentXinfo;
+    }
+
+    //get display, screen number, root window and desktop geometry for
+    //the current screen
+    Display *dpy = X11->display;
+    int scr = xinfo.screen();
+    Window root_win = RootWindow(dpy, scr);
+    int sw = DisplayWidth(dpy,scr);
+    int sh = DisplayHeight(dpy,scr);
+
+    if (desktop) {                                // desktop widget
+        popup = false;                        // force these flags off
+        data.crect.setRect(0, 0, sw, sh);
+    } else if (topLevel && !q->testAttribute(Qt::WA_Resized)) {
+        QDesktopWidget *desktopWidget = qApp->desktop();
+        if (desktopWidget->isVirtualDesktop()) {
+            QRect r = desktopWidget->screenGeometry();
+            sw = r.width();
+            sh = r.height();
+        }
+
+        int width = sw / 2;
+        int height = 4 * sh / 10;
+        if (extra) {
+            width = qMax(qMin(width, extra->maxw), extra->minw);
+            height = qMax(qMin(height, extra->maxh), extra->minh);
+        }
+        data.crect.setSize(QSize(width, height));
+    }
+
+    parentw = topLevel ? root_win : parentWidget->effectiveWinId();
+
+    XSetWindowAttributes wsa;
+
+    if (window) {                                // override the old window
+        if (destroyOldWindow) {
+            if (topLevel)
+                X11->dndEnable(q, false);
+            destroyw = data.winid;
+        }
+        id = window;
+        setWinId(window);
+        XWindowAttributes a;
+        XGetWindowAttributes(dpy, window, &a);
+        data.crect.setRect(a.x, a.y, a.width, a.height);
+
+        if (a.map_state == IsUnmapped)
+            q->setAttribute(Qt::WA_WState_Visible, false);
+        else
+            q->setAttribute(Qt::WA_WState_Visible);
+
+        qt_x11_getX11InfoForWindow(&xinfo,a);
+
+    } else if (desktop) {                        // desktop widget
+#ifdef QWIDGET_EXTRA_DEBUG
+        qDebug() << "create desktop";
+#endif
+        id = (WId)parentw;                        // id = root window
+//         QWidget *otherDesktop = find(id);        // is there another desktop?
+//         if (otherDesktop && otherDesktop->testWFlags(Qt::WPaintDesktop)) {
+//             otherDesktop->d->setWinId(0);        // remove id from widget mapper
+//             d->setWinId(id);                     // make sure otherDesktop is
+//             otherDesktop->d->setWinId(id);       // found first
+//         } else {
+        setWinId(id);
+//         }
+    } else if (topLevel || q->testAttribute(Qt::WA_NativeWindow) || paintOnScreen()) {
+#ifdef QWIDGET_EXTRA_DEBUG
+        static int topLevels = 0;
+        static int children = 0;
+        if (parentw == root_win)
+            qDebug() << "create toplevel" << ++topLevels;
+        else
+            qDebug() << "create child" << ++children;
+#endif
+        QRect safeRect = data.crect; //##### must handle huge sizes as well.... i.e. wrect
+        if (safeRect.width() < 1|| safeRect.height() < 1) {
+            if (topLevel) {
+                // top-levels must be at least 1x1
+                safeRect.setSize(safeRect.size().expandedTo(QSize(1, 1)));
+            } else {
+                // create it way off screen, and rely on
+                // setWSGeometry() to do the right thing with it later
+                safeRect = QRect(-1000,-1000,1,1);
+            }
+        }
+#ifndef QT_NO_XRENDER
+        int screen = xinfo.screen();
+        if (topLevel && X11->use_xrender
+            && xinfo.depth() != 32 && X11->argbVisuals[screen]
+            && q->testAttribute(Qt::WA_TranslucentBackground))
+        {
+            QX11InfoData *xd = xinfo.getX11Data(true);
+
+            xd->screen = screen;
+            xd->visual = X11->argbVisuals[screen];
+            xd->colormap = X11->argbColormaps[screen];
+            xd->depth = 32;
+            xd->defaultVisual = false;
+            xd->defaultColormap = false;
+            xd->cells = xd->visual->map_entries;
+            xinfo.setX11Data(xd);
+        }
+#endif
+        if (xinfo.defaultVisual() && xinfo.defaultColormap()) {
+            id = (WId)qt_XCreateSimpleWindow(q, dpy, parentw,
+                                             safeRect.left(), safeRect.top(),
+                                             safeRect.width(), safeRect.height(),
+                                             0,
+                                             BlackPixel(dpy, xinfo.screen()),
+                                             WhitePixel(dpy, xinfo.screen()));
+        } else {
+            wsa.background_pixel = WhitePixel(dpy, xinfo.screen());
+            wsa.border_pixel = BlackPixel(dpy, xinfo.screen());
+            wsa.colormap = xinfo.colormap();
+            id = (WId)qt_XCreateWindow(q, dpy, parentw,
+                                       safeRect.left(), safeRect.top(),
+                                       safeRect.width(), safeRect.height(),
+                                       0, xinfo.depth(), InputOutput,
+                                       (Visual *) xinfo.visual(),
+                                       CWBackPixel|CWBorderPixel|CWColormap,
+                                       &wsa);
+        }
+
+        setWinId(id);                                // set widget id/handle + hd
+    }
+
+#ifndef QT_NO_XRENDER
+    if (picture) {
+        XRenderFreePicture(X11->display, picture);
+        picture = 0;
+    }
+
+    if (X11->use_xrender && !desktop && q->internalWinId()) {
+        XRenderPictFormat *format = XRenderFindVisualFormat(dpy, (Visual *) xinfo.visual());
+        if (format)
+            picture = XRenderCreatePicture(dpy, id, format, 0, 0);
+    }
+#endif // QT_NO_XRENDER
+
+    QtMWMHints mwmhints;
+    mwmhints.flags = 0L;
+    mwmhints.functions = 0L;
+    mwmhints.decorations = 0;
+    mwmhints.input_mode = 0L;
+    mwmhints.status = 0L;
+
+    if (topLevel) {
+        ulong wsa_mask = 0;
+        if (type != Qt::SplashScreen) { // && customize) {
+            mwmhints.flags |= MWM_HINTS_DECORATIONS;
+
+            bool customize = flags & Qt::CustomizeWindowHint;
+            if (!(flags & Qt::FramelessWindowHint) && !(customize && !(flags & Qt::WindowTitleHint))) {
+                mwmhints.decorations |= MWM_DECOR_BORDER;
+                mwmhints.decorations |= MWM_DECOR_RESIZEH;
+
+                if (flags & Qt::WindowTitleHint)
+                    mwmhints.decorations |= MWM_DECOR_TITLE;
+
+                if (flags & Qt::WindowSystemMenuHint)
+                    mwmhints.decorations |= MWM_DECOR_MENU;
+
+                if (flags & Qt::WindowMinimizeButtonHint) {
+                    mwmhints.decorations |= MWM_DECOR_MINIMIZE;
+                    mwmhints.functions |= MWM_FUNC_MINIMIZE;
+                }
+
+                if (flags & Qt::WindowMaximizeButtonHint) {
+                    mwmhints.decorations |= MWM_DECOR_MAXIMIZE;
+                    mwmhints.functions |= MWM_FUNC_MAXIMIZE;
+                }
+
+                if (flags & Qt::WindowCloseButtonHint)
+                     mwmhints.functions |= MWM_FUNC_CLOSE;
+            }
+        } else {
+            // if type == Qt::SplashScreen
+            mwmhints.decorations = MWM_DECOR_ALL;
+        }
+
+        if (tool) {
+            wsa.save_under = True;
+            wsa_mask |= CWSaveUnder;
+        }
+
+        if (flags & Qt::X11BypassWindowManagerHint) {
+            wsa.override_redirect = True;
+            wsa_mask |= CWOverrideRedirect;
+        }
+
+        if (wsa_mask && initializeWindow) {
+            Q_ASSERT(id);
+            XChangeWindowAttributes(dpy, id, wsa_mask, &wsa);
+        }
+
+        if (mwmhints.functions != 0) {
+            mwmhints.flags |= MWM_HINTS_FUNCTIONS;
+            mwmhints.functions |= MWM_FUNC_MOVE | MWM_FUNC_RESIZE;
+        } else {
+            mwmhints.functions = MWM_FUNC_ALL;
+        }
+
+        if (!(flags & Qt::FramelessWindowHint)
+            && flags & Qt::CustomizeWindowHint
+            && flags & Qt::WindowTitleHint
+            && !(flags &
+                 (Qt::WindowMinimizeButtonHint
+                  | Qt::WindowMaximizeButtonHint
+                  | Qt::WindowCloseButtonHint))) {
+            // a special case - only the titlebar without any button
+            mwmhints.flags = MWM_HINTS_FUNCTIONS;
+            mwmhints.functions = MWM_FUNC_MOVE | MWM_FUNC_RESIZE;
+            mwmhints.decorations = 0;
+        }
+    }
+
+    if (!initializeWindow) {
+        // do no initialization
+    } else if (popup) {                        // popup widget
+        // set EWMH window types
+        setNetWmWindowTypes();
+
+        wsa.override_redirect = True;
+        wsa.save_under = True;
+        Q_ASSERT(id);
+        XChangeWindowAttributes(dpy, id, CWOverrideRedirect | CWSaveUnder,
+                                &wsa);
+    } else if (topLevel && !desktop) {        // top-level widget
+        if (!X11->wm_client_leader)
+            create_wm_client_leader();
+
+        // note: WM_TRANSIENT_FOR is set in QWidgetPrivate::show_sys()
+
+        XSizeHints size_hints;
+        memset(&size_hints, 0, sizeof(size_hints));
+        size_hints.flags = USSize | PSize | PWinGravity;
+        size_hints.x = data.crect.left();
+        size_hints.y = data.crect.top();
+        size_hints.width = data.crect.width();
+        size_hints.height = data.crect.height();
+        size_hints.win_gravity =
+            QApplication::isRightToLeft() ? NorthEastGravity : NorthWestGravity;
+
+        XWMHints wm_hints;                        // window manager hints
+        memset(&wm_hints, 0, sizeof(wm_hints)); // make valgrind happy
+        wm_hints.flags = InputHint | StateHint | WindowGroupHint;
+        wm_hints.input = q->testAttribute(Qt::WA_X11DoNotAcceptFocus) ? False : True;
+        wm_hints.initial_state = NormalState;
+        wm_hints.window_group = X11->wm_client_leader;
+
+        XClassHint class_hint;
+        QByteArray appName = qAppName().toLatin1();
+        class_hint.res_name = appName.data(); // application name
+        class_hint.res_class = const_cast<char *>(QX11Info::appClass());   // application class
+
+        XSetWMProperties(dpy, id, 0, 0,
+                         qApp->d_func()->argv, qApp->d_func()->argc,
+                         &size_hints, &wm_hints, &class_hint);
+
+        XResizeWindow(dpy, id,
+                      qBound(1, data.crect.width(), XCOORD_MAX),
+                      qBound(1, data.crect.height(), XCOORD_MAX));
+        XStoreName(dpy, id, appName.data());
+        Atom protocols[5];
+        int n = 0;
+        protocols[n++] = ATOM(WM_DELETE_WINDOW);        // support del window protocol
+        protocols[n++] = ATOM(WM_TAKE_FOCUS);                // support take focus window protocol
+        protocols[n++] = ATOM(_NET_WM_PING);                // support _NET_WM_PING protocol
+#ifndef QT_NO_XSYNC
+        protocols[n++] = ATOM(_NET_WM_SYNC_REQUEST);        // support _NET_WM_SYNC_REQUEST protocol
+#endif // QT_NO_XSYNC
+        if (flags & Qt::WindowContextHelpButtonHint)
+            protocols[n++] = ATOM(_NET_WM_CONTEXT_HELP);
+        XSetWMProtocols(dpy, id, protocols, n);
+
+        // set mwm hints
+        SetMWMHints(dpy, id, mwmhints);
+
+        // set EWMH window types
+        setNetWmWindowTypes();
+
+        // set _NET_WM_PID
+        long curr_pid = getpid();
+        XChangeProperty(dpy, id, ATOM(_NET_WM_PID), XA_CARDINAL, 32, PropModeReplace,
+                        (unsigned char *) &curr_pid, 1);
+
+        // when we create a toplevel widget, the frame strut should be dirty
+        data.fstrut_dirty = 1;
+
+        // declare the widget's window role
+        if (QTLWExtra *topData = maybeTopData()) {
+            if (!topData->role.isEmpty()) {
+                QByteArray windowRole = topData->role.toUtf8();
+                XChangeProperty(dpy, id,
+                                ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                                (unsigned char *)windowRole.constData(), windowRole.length());
+            }
+        }
+
+        // set client leader property
+        XChangeProperty(dpy, id, ATOM(WM_CLIENT_LEADER),
+                        XA_WINDOW, 32, PropModeReplace,
+                        (unsigned char *)&X11->wm_client_leader, 1);
+    } else {
+        // non-toplevel widgets don't have a frame, so no need to
+        // update the strut
+        data.fstrut_dirty = 0;
+    }
+
+    if (initializeWindow && q->internalWinId()) {
+        // don't erase when resizing
+        wsa.bit_gravity = QApplication::isRightToLeft() ? NorthEastGravity : NorthWestGravity;
+        Q_ASSERT(id);
+        XChangeWindowAttributes(dpy, id, CWBitGravity, &wsa);
+    }
+
+    // set X11 event mask
+    if (desktop) {
+//         QWidget* main_desktop = find(id);
+//         if (main_desktop->testWFlags(Qt::WPaintDesktop))
+//             XSelectInput(dpy, id, stdDesktopEventMask | ExposureMask);
+//         else
+        XSelectInput(dpy, id, stdDesktopEventMask);
+    } else if (q->internalWinId()) {
+        XSelectInput(dpy, id, stdWidgetEventMask);
+#if !defined (QT_NO_TABLET)
+        QTabletDeviceDataList *tablet_list = qt_tablet_devices();
+        if (X11->ptrXSelectExtensionEvent) {
+            for (int i = 0; i < tablet_list->size(); ++i) {
+                QTabletDeviceData tablet = tablet_list->at(i);
+                X11->ptrXSelectExtensionEvent(dpy, id, reinterpret_cast<XEventClass*>(tablet.eventList),
+                                              tablet.eventCount);
+            }
+        }
+#endif
+    }
+
+    if (desktop) {
+        q->setAttribute(Qt::WA_WState_Visible);
+    } else if (topLevel) {                        // set X cursor
+        if (initializeWindow) {
+            qt_x11_enforce_cursor(q);
+
+            if (QTLWExtra *topData = maybeTopData())
+                if (!topData->caption.isEmpty())
+                    setWindowTitle_helper(topData->caption);
+
+            //always enable dnd: it's not worth the effort to maintain the state
+            // NOTE: this always creates topData()
+            X11->dndEnable(q, true);
+
+            if (maybeTopData() && maybeTopData()->opacity != 255)
+                q->setWindowOpacity(maybeTopData()->opacity/255.);
+
+        }
+    } else if (q->internalWinId()) {
+        qt_x11_enforce_cursor(q);
+        if (QWidget *p = q->parentWidget()) // reset the cursor on the native parent
+            qt_x11_enforce_cursor(p);
+    }
+
+    if (extra && !extra->mask.isEmpty() && q->internalWinId())
+        XShapeCombineRegion(X11->display, q->internalWinId(), ShapeBounding, 0, 0,
+                            extra->mask.handle(), ShapeSet);
+#ifndef QT_NO_IM
+    if (q->hasFocus() && q->testAttribute(Qt::WA_InputMethodEnabled)) {
+        QInputContext *inputContext = q->inputContext();
+        if (inputContext)
+            inputContext->setFocusWidget(q);
+    }
+#endif
+    if (destroyw) {
+        qt_XDestroyWindow(q, dpy, destroyw);
+        if (QTLWExtra *topData = maybeTopData()) {
+#ifndef QT_NO_XSYNC
+            if (topData->syncUpdateCounter)
+                XSyncDestroyCounter(dpy, topData->syncUpdateCounter);
+#endif
+            // we destroyed our old window - reset the top-level state
+            createTLSysExtra();
+        }
+    }
+
+    // newly created windows are positioned at the window system's
+    // (0,0) position. If the parent uses wrect mapping to expand the
+    // coordinate system, we must also adjust this widget's window
+    // system position
+    if (!topLevel && !parentWidget->data->wrect.topLeft().isNull())
+        setWSGeometry();
+    else if (topLevel && (data.crect.width() == 0 || data.crect.height() == 0))
+        q->setAttribute(Qt::WA_OutsideWSRange, true);
+
+    if (!topLevel && q->testAttribute(Qt::WA_NativeWindow) && q->testAttribute(Qt::WA_Mapped)) {
+        Q_ASSERT(q->internalWinId());
+        XMapWindow(X11->display, q->internalWinId());
+        // Ensure that mapped alien widgets are flushed immediately when re-created as native widgets.
+        if (QWindowSurface *surface = q->windowSurface())
+            surface->flush(q, q->rect(), q->mapTo(surface->window(), QPoint()));
+    }
+
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::create_sys END:" << q;
+#endif
+}
+
+static void qt_x11_recreateWidget(QWidget *widget)
+{
+    if (widget->inherits("QGLWidget")) {
+        // We send QGLWidgets a ParentChange event which causes them to
+        // recreate their GL context, which in turn causes them to choose
+        // their visual again. Now that WA_TranslucentBackground is set,
+        // QGLContext::chooseVisual will select an ARGB visual.
+
+        // QGLWidget expects a ParentAboutToChange to be sent first
+        QEvent aboutToChangeEvent(QEvent::ParentAboutToChange);
+        QApplication::sendEvent(widget, &aboutToChangeEvent);
+
+        QEvent parentChangeEvent(QEvent::ParentChange);
+        QApplication::sendEvent(widget, &parentChangeEvent);
+    } else {
+        // For regular widgets, reparent them with their parent which
+        // also triggers a recreation of the native window
+        QPoint pos = widget->pos();
+        bool visible = widget->isVisible();
+        if (visible)
+            widget->hide();
+
+        widget->setParent(widget->parentWidget(), widget->windowFlags());
+        widget->move(pos);
+        if (visible)
+            widget->show();
+    }
+}
+
+static void qt_x11_recreateNativeWidgetsRecursive(QWidget *widget)
+{
+    if (widget->internalWinId())
+        qt_x11_recreateWidget(widget);
+
+    const QObjectList &children = widget->children();
+    for (int i = 0; i < children.size(); ++i) {
+        QWidget *child = qobject_cast<QWidget*>(children.at(i));
+        if (child)
+            qt_x11_recreateNativeWidgetsRecursive(child);
+    }
+}
+
+void QWidgetPrivate::x11UpdateIsOpaque()
+{
+#ifndef QT_NO_XRENDER
+    Q_Q(QWidget);
+    if (!q->testAttribute(Qt::WA_WState_Created) || !q->testAttribute(Qt::WA_TranslucentBackground))
+        return;
+
+    bool topLevel = (data.window_flags & Qt::Window);
+    int screen = xinfo.screen();
+    if (topLevel && X11->use_xrender
+        && X11->argbVisuals[screen] && xinfo.depth() != 32)
+    {
+        qt_x11_recreateNativeWidgetsRecursive(q);
+    }
+#endif
+}
+
+/*
+  Returns true if the background is inherited; otherwise returns
+  false.
+
+  Mainly used in the paintOnScreen case.
+*/
+bool QWidgetPrivate::isBackgroundInherited() const
+{
+    Q_Q(const QWidget);
+
+    // windows do not inherit their background
+    if (q->isWindow() || q->windowType() == Qt::SubWindow)
+        return false;
+
+    if (q->testAttribute(Qt::WA_NoSystemBackground) || q->testAttribute(Qt::WA_OpaquePaintEvent))
+        return false;
+
+    const QPalette &pal = q->palette();
+    QPalette::ColorRole bg = q->backgroundRole();
+    QBrush brush = pal.brush(bg);
+
+    // non opaque brushes leaves us no choice, we must inherit
+    if (!q->autoFillBackground() || !brush.isOpaque())
+        return true;
+
+    if (brush.style() == Qt::SolidPattern) {
+        // the background is just a solid color. If there is no
+        // propagated contents, then we claim as performance
+        // optimization that it was not inheritet. This is the normal
+        // case in standard Windows or Motif style.
+        const QWidget *w = q->parentWidget();
+        if (!w->d_func()->isBackgroundInherited())
+            return false;
+    }
+
+    return true;
+}
+
+void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
+{
+    Q_D(QWidget);
+    d->aboutToDestroy();
+    if (!isWindow() && parentWidget())
+        parentWidget()->d_func()->invalidateBuffer(d->effectiveRectFor(geometry()));
+    d->deactivateWidgetCleanup();
+    if (testAttribute(Qt::WA_WState_Created)) {
+        setAttribute(Qt::WA_WState_Created, false);
+        QObjectList childList = children();
+        for (int i = 0; i < childList.size(); ++i) { // destroy all widget children
+            register QObject *obj = childList.at(i);
+            if (obj->isWidgetType())
+                static_cast<QWidget*>(obj)->destroy(destroySubWindows,
+                                                    destroySubWindows);
+        }
+        if (QWidgetPrivate::mouseGrabber == this)
+            releaseMouse();
+        if (QWidgetPrivate::keyboardGrabber == this)
+            releaseKeyboard();
+        if (isWindow())
+            X11->deferred_map.removeAll(this);
+        if (isModal()) {
+            // just be sure we leave modal
+            QApplicationPrivate::leaveModal(this);
+        }
+        else if ((windowType() == Qt::Popup))
+            qApp->d_func()->closePopup(this);
+
+#ifndef QT_NO_XRENDER
+        if (d->picture) {
+            if (destroyWindow)
+                XRenderFreePicture(X11->display, d->picture);
+            d->picture = 0;
+        }
+#endif // QT_NO_XRENDER
+
+        // delete the _NET_WM_USER_TIME_WINDOW
+        qt_net_remove_user_time(this);
+
+        if ((windowType() == Qt::Desktop)) {
+            if (acceptDrops())
+                X11->dndEnable(this, false);
+        } else {
+            if (isWindow())
+                X11->dndEnable(this, false);
+            if (destroyWindow)
+                qt_XDestroyWindow(this, X11->display, data->winid);
+        }
+        QT_TRY {
+            d->setWinId(0);
+        } QT_CATCH (const std::bad_alloc &) {
+            // swallow - destructors must not throw
+        }
+
+        extern void qPRCleanup(QWidget *widget); // from qapplication_x11.cpp
+        if (testAttribute(Qt::WA_WState_Reparented))
+            qPRCleanup(this);
+#ifndef QT_NO_IM
+        if(d->ic) {
+            delete d->ic;
+        } else {
+            // release previous focus information participating with
+            // preedit preservation of qic
+            QInputContext *qic = QApplicationPrivate::inputContext;
+            if (qic)
+                qic->widgetDestroyed(this);
+        }
+#endif
+    }
+}
+
+void QWidgetPrivate::setParent_sys(QWidget *parent, Qt::WindowFlags f)
+{
+    Q_Q(QWidget);
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::setParent_sys START" << q << "parent:" << parent;
+#endif
+    QX11Info old_xinfo = xinfo;
+    if (parent && parent->windowType() == Qt::Desktop) {
+        // make sure the widget is created on the same screen as the
+        // programmer specified desktop widget
+        xinfo = parent->d_func()->xinfo;
+        parent = 0;
+    }
+
+    QTLWExtra *topData = maybeTopData();
+    bool wasCreated = q->testAttribute(Qt::WA_WState_Created);
+    if (q->isVisible() && q->parentWidget() && parent != q->parentWidget())
+        q->parentWidget()->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
+    extern void qPRCreate(const QWidget *, Window);
+#ifndef QT_NO_CURSOR
+    QCursor oldcurs;
+#endif
+
+    // dnd unregister (we will register again below)
+    if (q->testAttribute(Qt::WA_DropSiteRegistered))
+        q->setAttribute(Qt::WA_DropSiteRegistered, false);
+
+    // if we are a top then remove our dnd prop for now
+    // it will get rest later
+    if (q->isWindow() && wasCreated)
+        X11->dndEnable(q, false);
+
+    if (topData)
+        qt_net_remove_user_time(q);
+
+//     QWidget *oldparent = q->parentWidget();
+    WId old_winid = wasCreated ? data.winid : 0;
+    if ((q->windowType() == Qt::Desktop))
+        old_winid = 0;
+    setWinId(0);
+
+#ifndef QT_NO_XRENDER
+    if (picture) {
+        XRenderFreePicture(X11->display, picture);
+        picture = 0;
+    }
+#endif
+
+    // hide and reparent our own window away. Otherwise we might get
+    // destroyed when emitting the child remove event below. See QWorkspace.
+    if (wasCreated && old_winid) {
+        XUnmapWindow(X11->display, old_winid);
+        if (!old_xinfo.screen() != xinfo.screen())
+            XReparentWindow(X11->display, old_winid, RootWindow(X11->display, xinfo.screen()), 0, 0);
+    }
+    if (topData) {
+        topData->parentWinId = 0;
+        // zero the frame strut and mark it dirty
+        topData->frameStrut.setCoords(0, 0, 0, 0);
+
+        // reparenting from top-level, make sure show() works again
+        topData->waitingForMapNotify = 0;
+        topData->validWMState = 0;
+    }
+    data.fstrut_dirty = (!parent || (f & Qt::Window)); // toplevels get a dirty framestrut
+
+    QObjectPrivate::setParent_helper(parent);
+    bool explicitlyHidden = q->testAttribute(Qt::WA_WState_Hidden) && q->testAttribute(Qt::WA_WState_ExplicitShowHide);
+
+    data.window_flags = f;
+    q->setAttribute(Qt::WA_WState_Created, false);
+    q->setAttribute(Qt::WA_WState_Visible, false);
+    q->setAttribute(Qt::WA_WState_Hidden, false);
+    adjustFlags(data.window_flags, q);
+    // keep compatibility with previous versions, we need to preserve the created state
+    // (but we recreate the winId for the widget being reparented, again for compatibility)
+    if (wasCreated)
+        createWinId();
+    if (q->isWindow() || (!parent || parent->isVisible()) || explicitlyHidden)
+        q->setAttribute(Qt::WA_WState_Hidden);
+    q->setAttribute(Qt::WA_WState_ExplicitShowHide, explicitlyHidden);
+
+    if (wasCreated) {
+        QObjectList chlist = q->children();
+        for (int i = 0; i < chlist.size(); ++i) { // reparent children
+            QObject *obj = chlist.at(i);
+            if (obj->isWidgetType()) {
+                QWidget *w = (QWidget *)obj;
+                if (!w->testAttribute(Qt::WA_WState_Created))
+                    continue;
+                if (xinfo.screen() != w->d_func()->xinfo.screen()) {
+                    // ### force setParent() to not shortcut out (because
+                    // ### we're setting the parent to the current parent)
+                    // ### setParent will add child back to the list
+                    // ### of children so we need to make sure the
+                    // ### widget won't be added twice.
+                    w->d_func()->parent = 0;
+                    this->children.removeOne(w);
+                    w->setParent(q);
+                } else if (!w->isWindow()) {
+                    w->d_func()->invalidateBuffer(w->rect());
+                    if (w->internalWinId()) {
+                        if (w->testAttribute(Qt::WA_NativeWindow)) {
+                            QWidget *nativeParentWidget = w->nativeParentWidget();
+                            // Qt::WA_NativeWindow ensures that we always have a nativeParentWidget
+                            Q_ASSERT(nativeParentWidget != 0);
+                            QPoint p = w->mapTo(nativeParentWidget, QPoint());
+                            XReparentWindow(X11->display,
+                                            w->internalWinId(),
+                                            nativeParentWidget->internalWinId(),
+                                            p.x(), p.y());
+                        } else {
+                            w->d_func()->setParent_sys(q, w->data->window_flags);
+                        }
+                    }
+                } else if (isTransient(w)) {
+                    /*
+                      when reparenting toplevel windows with toplevel-transient children,
+                      we need to make sure that the window manager gets the updated
+                      WM_TRANSIENT_FOR information... unfortunately, some window managers
+                      don't handle changing WM_TRANSIENT_FOR before the toplevel window is
+                      visible, so we unmap and remap all toplevel-transient children *after*
+                      the toplevel parent has been mapped.  thankfully, this is easy in Qt :)
+
+                      note that the WM_TRANSIENT_FOR hint is actually updated in
+                      QWidgetPrivate::show_sys()
+                    */
+                    if (w->internalWinId())
+                        XUnmapWindow(X11->display, w->internalWinId());
+                    QApplication::postEvent(w, new QEvent(QEvent::ShowWindowRequest));
+                }
+            }
+        }
+        qPRCreate(q, old_winid);
+        updateSystemBackground();
+
+        if (old_winid) {
+            Window *cmwret;
+            int count;
+            if (XGetWMColormapWindows(X11->display, old_winid, &cmwret, &count)) {
+                Window *cmw;
+                int cmw_size = sizeof(Window)*count;
+                cmw = new Window[count];
+                memcpy((char *)cmw, (char *)cmwret, cmw_size);
+                XFree((char *)cmwret);
+                int i;
+                for (i=0; i<count; i++) {
+                    if (cmw[i] == old_winid) {
+                        cmw[i] = q->internalWinId();
+                        break;
+                    }
+                }
+                int top_count;
+                if (XGetWMColormapWindows(X11->display, q->window()->internalWinId(),
+                                          &cmwret, &top_count))
+                {
+                    Window *merged_cmw = new Window[count + top_count];
+                    memcpy((char *)merged_cmw, (char *)cmw, cmw_size);
+                    memcpy((char *)merged_cmw + cmw_size, (char *)cmwret, sizeof(Window)*top_count);
+                    delete [] cmw;
+                    XFree((char *)cmwret);
+                    cmw = merged_cmw;
+                    count += top_count;
+                }
+
+                XSetWMColormapWindows(X11->display, q->window()->internalWinId(), cmw, count);
+                delete [] cmw;
+            }
+
+            qt_XDestroyWindow(q, X11->display, old_winid);
+        }
+    }
+
+    // check if we need to register our dropsite
+    if (q->testAttribute(Qt::WA_AcceptDrops)
+        || (!q->isWindow() && q->parentWidget() && q->parentWidget()->testAttribute(Qt::WA_DropSiteRegistered))) {
+        q->setAttribute(Qt::WA_DropSiteRegistered, true);
+    }
+#if !defined(QT_NO_IM)
+    ic = 0;
+#endif
+    invalidateBuffer(q->rect());
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::setParent_sys END" << q;
+#endif
+}
+
+QPoint QWidgetPrivate::mapToGlobal(const QPoint &pos) const
+{
+    Q_Q(const QWidget);
+    if (!q->testAttribute(Qt::WA_WState_Created) || !q->internalWinId()) {
+        QPoint p = pos + q->data->crect.topLeft();
+        //cannot trust that !isWindow() implies parentWidget() before create
+        return (q->isWindow() || !q->parentWidget()) ?  p : q->parentWidget()->d_func()->mapToGlobal(p);
+    }
+    int x, y;
+    Window child;
+    QPoint p = mapToWS(pos);
+    XTranslateCoordinates(X11->display, q->internalWinId(),
+                          QApplication::desktop()->screen(xinfo.screen())->internalWinId(),
+                          p.x(), p.y(), &x, &y, &child);
+    return QPoint(x, y);
+}
+
+QPoint QWidgetPrivate::mapFromGlobal(const QPoint &pos) const
+{
+    Q_Q(const QWidget);
+    if (!q->testAttribute(Qt::WA_WState_Created) || !q->internalWinId()) {
+        //cannot trust that !isWindow() implies parentWidget() before create
+        QPoint p = (q->isWindow() || !q->parentWidget()) ?  pos : q->parentWidget()->d_func()->mapFromGlobal(pos);
+        return p - q->data->crect.topLeft();
+    }
+    int x, y;
+    Window child;
+    XTranslateCoordinates(X11->display,
+                          QApplication::desktop()->screen(xinfo.screen())->internalWinId(),
+                          q->internalWinId(), pos.x(), pos.y(), &x, &y, &child);
+    return mapFromWS(QPoint(x, y));
+}
+
+QPoint QWidget::mapToGlobal(const QPoint &pos) const
+{
+    Q_D(const QWidget);
+    return d->mapToGlobal(pos);
+}
+
+QPoint QWidget::mapFromGlobal(const QPoint &pos) const
+{
+    Q_D(const QWidget);
+    return d->mapFromGlobal(pos);
+}
+
+void QWidgetPrivate::updateSystemBackground()
+{
+    Q_Q(QWidget);
+    if (!q->testAttribute(Qt::WA_WState_Created) || !q->internalWinId())
+        return;
+    QBrush brush = q->palette().brush(QPalette::Active, q->backgroundRole());
+    Qt::WindowType type = q->windowType();
+    if (brush.style() == Qt::NoBrush
+        || q->testAttribute(Qt::WA_NoSystemBackground)
+        || q->testAttribute(Qt::WA_UpdatesDisabled)
+        || type == Qt::Popup || type == Qt::ToolTip) {
+            if (QX11Info::isCompositingManagerRunning()
+                && q->testAttribute(Qt::WA_TranslucentBackground)
+                && !(q->parent()))
+                XSetWindowBackground(X11->display, q->internalWinId(),
+                                     QColormap::instance(xinfo.screen()).pixel(Qt::transparent));
+            else
+                XSetWindowBackgroundPixmap(X11->display, q->internalWinId(), XNone);
+        }
+    else if (brush.style() == Qt::SolidPattern && brush.isOpaque())
+        XSetWindowBackground(X11->display, q->internalWinId(),
+                             QColormap::instance(xinfo.screen()).pixel(brush.color()));
+    else if (isBackgroundInherited())
+        XSetWindowBackgroundPixmap(X11->display, q->internalWinId(), ParentRelative);
+    else if (brush.style() == Qt::TexturePattern) {
+        extern QPixmap qt_toX11Pixmap(const QPixmap &pixmap); // qpixmap_x11.cpp
+        XSetWindowBackgroundPixmap(X11->display, q->internalWinId(),
+                                   static_cast<QX11PixmapData*>(qt_toX11Pixmap(brush.texture()).data.data())->x11ConvertToDefaultDepth());
+    } else
+        XSetWindowBackground(X11->display, q->internalWinId(),
+                             QColormap::instance(xinfo.screen()).pixel(brush.color()));
+}
+
+#ifndef QT_NO_CURSOR
+void QWidgetPrivate::setCursor_sys(const QCursor &)
+{
+    Q_Q(QWidget);
+    qt_x11_enforce_cursor(q);
+    XFlush(X11->display);
+}
+
+void QWidgetPrivate::unsetCursor_sys()
+{
+    Q_Q(QWidget);
+    qt_x11_enforce_cursor(q);
+    XFlush(X11->display);
+}
+#endif
+
+static XTextProperty*
+qstring_to_xtp(const QString& s)
+{
+    static XTextProperty tp = { 0, 0, 0, 0 };
+    static bool free_prop = true; // we can't free tp.value in case it references
+    // the data of the static QCString below.
+    if (tp.value) {
+        if (free_prop)
+            XFree(tp.value);
+        tp.value = 0;
+        free_prop = true;
+    }
+
+    static const QTextCodec* mapper = QTextCodec::codecForLocale();
+    int errCode = 0;
+    if (mapper) {
+        QByteArray mapped = mapper->fromUnicode(s);
+        char* tl[2];
+        tl[0] = mapped.data();
+        tl[1] = 0;
+        errCode = XmbTextListToTextProperty(X11->display, tl, 1, XStdICCTextStyle, &tp);
+#if defined(QT_DEBUG)
+        if (errCode < 0)
+            qDebug("qstring_to_xtp result code %d", errCode);
+#endif
+    }
+    if (!mapper || errCode < 0) {
+        static QByteArray qcs;
+        qcs = s.toAscii();
+        tp.value = (uchar*)qcs.data();
+        tp.encoding = XA_STRING;
+        tp.format = 8;
+        tp.nitems = qcs.length();
+        free_prop = false;
+    }
+
+    // ### If we knew WM could understand unicode, we could use
+    // ### a much simpler, cheaper encoding...
+    /*
+        tp.value = (XChar2b*)s.unicode();
+        tp.encoding = XA_UNICODE; // wish
+        tp.format = 16;
+        tp.nitems = s.length();
+    */
+
+    return &tp;
+}
+
+void QWidgetPrivate::setWindowTitle_sys(const QString &caption)
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    if (!q->internalWinId())
+        return;
+    XSetWMName(X11->display, q->internalWinId(), qstring_to_xtp(caption));
+
+    QByteArray net_wm_name = caption.toUtf8();
+    XChangeProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_NAME), ATOM(UTF8_STRING), 8,
+                    PropModeReplace, (unsigned char *)net_wm_name.data(), net_wm_name.size());
+}
+
+void QWidgetPrivate::setWindowIcon_sys(bool forceReset)
+{
+    Q_Q(QWidget);
+    if (!q->testAttribute(Qt::WA_WState_Created))
+        return;
+    QTLWExtra *topData = this->topData();
+    if (topData->iconPixmap && !forceReset)
+        // already been set
+        return;
+
+    // preparing images to set the _NET_WM_ICON property
+    QIcon icon = q->windowIcon();
+    QVector<long> icon_data;
+    Qt::HANDLE pixmap_handle = 0;
+    if (!icon.isNull()) {
+        QList<QSize> availableSizes = icon.availableSizes();
+        if(availableSizes.isEmpty()) {
+            // try to use default sizes since the icon can be a scalable image like svg.
+            availableSizes.push_back(QSize(16,16));
+            availableSizes.push_back(QSize(32,32));
+            availableSizes.push_back(QSize(64,64));
+            availableSizes.push_back(QSize(128,128));
+        }
+        for(int i = 0; i < availableSizes.size(); ++i) {
+            QSize size = availableSizes.at(i);
+            QPixmap pixmap = icon.pixmap(size);
+            if (!pixmap.isNull()) {
+                QImage image = pixmap.toImage().convertToFormat(QImage::Format_ARGB32);
+                int pos = icon_data.size();
+                icon_data.resize(pos + 2 + image.width()*image.height());
+                icon_data[pos++] = image.width();
+                icon_data[pos++] = image.height();
+                if (sizeof(long) == sizeof(quint32)) {
+                    memcpy(icon_data.data() + pos, image.scanLine(0), image.byteCount());
+                } else {
+                    for (int y = 0; y < image.height(); ++y) {
+                        uint *scanLine = reinterpret_cast<uint *>(image.scanLine(y));
+                        for (int x = 0; x < image.width(); ++x)
+                            icon_data[pos + y*image.width() + x] = scanLine[x];
+                    }
+                }
+            }
+        }
+        if (!icon_data.isEmpty()) {
+            extern QPixmap qt_toX11Pixmap(const QPixmap &pixmap);
+            /*
+              if the app is running on an unknown desktop, or it is not
+              using the default visual, convert the icon to 1bpp as stated
+              in the ICCCM section 4.1.2.4; otherwise, create the icon pixmap
+              in the default depth (even though this violates the ICCCM)
+            */
+            if (X11->desktopEnvironment == DE_UNKNOWN
+                || !QX11Info::appDefaultVisual(xinfo.screen())
+                || !QX11Info::appDefaultColormap(xinfo.screen())) {
+                // unknown DE or non-default visual/colormap, use 1bpp bitmap
+                if (!forceReset || !topData->iconPixmap)
+                    topData->iconPixmap = new QPixmap(qt_toX11Pixmap(QBitmap(icon.pixmap(QSize(64,64)))));
+                pixmap_handle = topData->iconPixmap->handle();
+            } else {
+                // default depth, use a normal pixmap (even though this
+                // violates the ICCCM), since this works on all DEs known to Qt
+                if (!forceReset || !topData->iconPixmap)
+                    topData->iconPixmap = new QPixmap(qt_toX11Pixmap(icon.pixmap(QSize(64,64))));
+                pixmap_handle = static_cast<QX11PixmapData*>(topData->iconPixmap->data.data())->x11ConvertToDefaultDepth();
+            }
+        }
+    }
+
+    if (!q->internalWinId())
+        return;
+
+    if (!icon_data.isEmpty()) {
+        XChangeProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_ICON), XA_CARDINAL, 32,
+                        PropModeReplace, (unsigned char *) icon_data.data(),
+                        icon_data.size());
+    } else {
+        XDeleteProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_ICON));
+    }
+
+    XWMHints *h = XGetWMHints(X11->display, q->internalWinId());
+    XWMHints wm_hints;
+    if (!h) {
+        memset(&wm_hints, 0, sizeof(wm_hints)); // make valgrind happy
+        h = &wm_hints;
+    }
+
+    if (pixmap_handle) {
+        h->icon_pixmap = pixmap_handle;
+        h->flags |= IconPixmapHint;
+    } else {
+        h->icon_pixmap = 0;
+        h->flags &= ~(IconPixmapHint | IconMaskHint);
+    }
+
+    XSetWMHints(X11->display, q->internalWinId(), h);
+    if (h != &wm_hints)
+        XFree((char *)h);
+}
+
+void QWidgetPrivate::setWindowIconText_sys(const QString &iconText)
+{
+    Q_Q(QWidget);
+    if (!q->internalWinId())
+        return;
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    XSetWMIconName(X11->display, q->internalWinId(), qstring_to_xtp(iconText));
+
+    QByteArray icon_name = iconText.toUtf8();
+    XChangeProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_ICON_NAME), ATOM(UTF8_STRING), 8,
+                    PropModeReplace, (unsigned char *) icon_name.constData(), icon_name.size());
+}
+
+
+void QWidget::grabMouse()
+{
+    if (isVisible() && !qt_nograb()) {
+        if (QWidgetPrivate::mouseGrabber && QWidgetPrivate::mouseGrabber != this)
+            QWidgetPrivate::mouseGrabber->releaseMouse();
+        Q_ASSERT(testAttribute(Qt::WA_WState_Created));
+#ifndef QT_NO_DEBUG
+        int status =
+#endif
+            XGrabPointer(X11->display, effectiveWinId(), False,
+                          (uint)(ButtonPressMask | ButtonReleaseMask |
+                                  PointerMotionMask | EnterWindowMask |
+                                  LeaveWindowMask),
+                          GrabModeAsync, GrabModeAsync,
+                          XNone, XNone, X11->time);
+#ifndef QT_NO_DEBUG
+        if (status) {
+            const char *s =
+                status == GrabNotViewable ? "\"GrabNotViewable\"" :
+                status == AlreadyGrabbed  ? "\"AlreadyGrabbed\"" :
+                status == GrabFrozen      ? "\"GrabFrozen\"" :
+                status == GrabInvalidTime ? "\"GrabInvalidTime\"" :
+                "<?>";
+            qWarning("QWidget::grabMouse: Failed with %s", s);
+        }
+#endif
+        QWidgetPrivate::mouseGrabber = this;
+    }
+}
+
+
+#ifndef QT_NO_CURSOR
+void QWidget::grabMouse(const QCursor &cursor)
+{
+    if (!qt_nograb()) {
+        if (QWidgetPrivate::mouseGrabber && QWidgetPrivate::mouseGrabber != this)
+            QWidgetPrivate::mouseGrabber->releaseMouse();
+        Q_ASSERT(testAttribute(Qt::WA_WState_Created));
+#ifndef QT_NO_DEBUG
+        int status =
+#endif
+        XGrabPointer(X11->display, effectiveWinId(), False,
+                      (uint)(ButtonPressMask | ButtonReleaseMask |
+                             PointerMotionMask | EnterWindowMask | LeaveWindowMask),
+                      GrabModeAsync, GrabModeAsync,
+                      XNone, cursor.handle(), X11->time);
+#ifndef QT_NO_DEBUG
+        if (status) {
+            const char *s =
+                status == GrabNotViewable ? "\"GrabNotViewable\"" :
+                status == AlreadyGrabbed  ? "\"AlreadyGrabbed\"" :
+                status == GrabFrozen      ? "\"GrabFrozen\"" :
+                status == GrabInvalidTime ? "\"GrabInvalidTime\"" :
+                                            "<?>";
+            qWarning("QWidget::grabMouse: Failed with %s", s);
+        }
+#endif
+        QWidgetPrivate::mouseGrabber = this;
+    }
+}
+#endif
+
+
+void QWidget::releaseMouse()
+{
+    if (!qt_nograb() && QWidgetPrivate::mouseGrabber == this) {
+        XUngrabPointer(X11->display, X11->time);
+        XFlush(X11->display);
+        QWidgetPrivate::mouseGrabber = 0;
+    }
+}
+
+
+void QWidget::grabKeyboard()
+{
+    if (!qt_nograb()) {
+        if (QWidgetPrivate::keyboardGrabber && QWidgetPrivate::keyboardGrabber != this)
+            QWidgetPrivate::keyboardGrabber->releaseKeyboard();
+        XGrabKeyboard(X11->display, effectiveWinId(), False, GrabModeAsync, GrabModeAsync,
+                      X11->time);
+        QWidgetPrivate::keyboardGrabber = this;
+    }
+}
+
+
+void QWidget::releaseKeyboard()
+{
+    if (!qt_nograb() && QWidgetPrivate::keyboardGrabber == this) {
+        XUngrabKeyboard(X11->display, X11->time);
+        QWidgetPrivate::keyboardGrabber = 0;
+    }
+}
+
+
+QWidget *QWidget::mouseGrabber()
+{
+    return QWidgetPrivate::mouseGrabber;
+}
+
+
+QWidget *QWidget::keyboardGrabber()
+{
+    return QWidgetPrivate::keyboardGrabber;
+}
+
+void QWidget::activateWindow()
+{
+    QWidget *tlw = window();
+    if (tlw->isVisible() && !tlw->d_func()->topData()->embedded && !X11->deferred_map.contains(tlw)) {
+        if (X11->userTime == 0)
+            X11->userTime = X11->time;
+        qt_net_update_user_time(tlw, X11->userTime);
+
+        if (X11->isSupportedByWM(ATOM(_NET_ACTIVE_WINDOW))
+            && !(tlw->windowFlags() & Qt::X11BypassWindowManagerHint)) {
+            XEvent e;
+            e.xclient.type = ClientMessage;
+            e.xclient.message_type = ATOM(_NET_ACTIVE_WINDOW);
+            e.xclient.display = X11->display;
+            e.xclient.window = tlw->internalWinId();
+            e.xclient.format = 32;
+            e.xclient.data.l[0] = 1;     // 1 == application
+            e.xclient.data.l[1] = X11->userTime;
+            if (QWidget *aw = QApplication::activeWindow())
+                e.xclient.data.l[2] = aw->internalWinId();
+            else
+                e.xclient.data.l[2] = XNone;
+            e.xclient.data.l[3] = 0;
+            e.xclient.data.l[4] = 0;
+            XSendEvent(X11->display, RootWindow(X11->display, tlw->x11Info().screen()),
+                       false, SubstructureNotifyMask | SubstructureRedirectMask, &e);
+        } else {
+            if (!qt_widget_private(tlw)->topData()->waitingForMapNotify)
+                XSetInputFocus(X11->display, tlw->internalWinId(), XRevertToParent, X11->time);
+        }
+    }
+}
+
+void QWidget::setWindowState(Qt::WindowStates newstate)
+{
+    Q_D(QWidget);
+    bool needShow = false;
+    Qt::WindowStates oldstate = windowState();
+    if (oldstate == newstate)
+        return;
+    if (isWindow()) {
+        // Ensure the initial size is valid, since we store it as normalGeometry below.
+        if (!testAttribute(Qt::WA_Resized) && !isVisible())
+            adjustSize();
+
+        QTLWExtra *top = d->topData();
+
+        if ((oldstate & Qt::WindowMaximized) != (newstate & Qt::WindowMaximized)) {
+            if (X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ))
+                && X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_VERT))) {
+                if ((newstate & Qt::WindowMaximized) && !(oldstate & Qt::WindowFullScreen))
+                    top->normalGeometry = geometry();
+                qt_change_net_wm_state(this, (newstate & Qt::WindowMaximized),
+                                       ATOM(_NET_WM_STATE_MAXIMIZED_HORZ),
+                                       ATOM(_NET_WM_STATE_MAXIMIZED_VERT));
+            } else if (! (newstate & Qt::WindowFullScreen)) {
+                if (newstate & Qt::WindowMaximized) {
+                    // save original geometry
+                    const QRect normalGeometry = geometry();
+
+                    if (isVisible()) {
+                        data->fstrut_dirty = true;
+                        const QRect maxRect = QApplication::desktop()->availableGeometry(this);
+                        const QRect r = top->normalGeometry;
+                        const QRect fs = d->frameStrut();
+                        setGeometry(maxRect.x() + fs.left(),
+                                    maxRect.y() + fs.top(),
+                                    maxRect.width() - fs.left() - fs.right(),
+                                    maxRect.height() - fs.top() - fs.bottom());
+                        top->normalGeometry = r;
+                    }
+
+                    if (top->normalGeometry.width() < 0)
+                        top->normalGeometry = normalGeometry;
+                } else {
+                    // restore original geometry
+                    setGeometry(top->normalGeometry);
+                }
+            }
+        }
+
+        if ((oldstate & Qt::WindowFullScreen) != (newstate & Qt::WindowFullScreen)) {
+            if (X11->isSupportedByWM(ATOM(_NET_WM_STATE_FULLSCREEN))) {
+                if (newstate & Qt::WindowFullScreen) {
+                    top->normalGeometry = geometry();
+                    top->fullScreenOffset = d->frameStrut().topLeft();
+                }
+                qt_change_net_wm_state(this, (newstate & Qt::WindowFullScreen),
+                                       ATOM(_NET_WM_STATE_FULLSCREEN));
+            } else {
+                needShow = isVisible();
+
+                if (newstate & Qt::WindowFullScreen) {
+                    data->fstrut_dirty = true;
+                    const QRect normalGeometry = geometry();
+                    const QPoint fullScreenOffset = d->frameStrut().topLeft();
+
+                    top->savedFlags = windowFlags();
+                    setParent(0, Qt::Window | Qt::FramelessWindowHint);
+                    const QRect r = top->normalGeometry;
+                    setGeometry(qApp->desktop()->screenGeometry(this));
+                    top->normalGeometry = r;
+
+                    if (top->normalGeometry.width() < 0) {
+                        top->normalGeometry = normalGeometry;
+                        top->fullScreenOffset = fullScreenOffset;
+                    }
+                } else {
+                    setParent(0, top->savedFlags);
+
+                    if (newstate & Qt::WindowMaximized) {
+                        // from fullscreen to maximized
+                        data->fstrut_dirty = true;
+                        const QRect maxRect = QApplication::desktop()->availableGeometry(this);
+                        const QRect r = top->normalGeometry;
+                        const QRect fs = d->frameStrut();
+                        setGeometry(maxRect.x() + fs.left(),
+                                    maxRect.y() + fs.top(),
+                                    maxRect.width() - fs.left() - fs.right(),
+                                    maxRect.height() - fs.top() - fs.bottom());
+                        top->normalGeometry = r;
+                    } else {
+                        // restore original geometry
+                        setGeometry(top->normalGeometry.adjusted(-top->fullScreenOffset.x(),
+                                                                 -top->fullScreenOffset.y(),
+                                                                 -top->fullScreenOffset.x(),
+                                                                 -top->fullScreenOffset.y()));
+                    }
+                }
+            }
+        }
+
+        createWinId();
+        Q_ASSERT(testAttribute(Qt::WA_WState_Created));
+        if ((oldstate & Qt::WindowMinimized) != (newstate & Qt::WindowMinimized)) {
+            if (isVisible()) {
+                if (newstate & Qt::WindowMinimized) {
+                    XEvent e;
+                    e.xclient.type = ClientMessage;
+                    e.xclient.message_type = ATOM(WM_CHANGE_STATE);
+                    e.xclient.display = X11->display;
+                    e.xclient.window = data->winid;
+                    e.xclient.format = 32;
+                    e.xclient.data.l[0] = IconicState;
+                    e.xclient.data.l[1] = 0;
+                    e.xclient.data.l[2] = 0;
+                    e.xclient.data.l[3] = 0;
+                    e.xclient.data.l[4] = 0;
+                    XSendEvent(X11->display,
+                               RootWindow(X11->display,d->xinfo.screen()),
+                               False, (SubstructureNotifyMask|SubstructureRedirectMask), &e);
+                } else {
+                    setAttribute(Qt::WA_Mapped);
+                    XMapWindow(X11->display, effectiveWinId());
+                }
+            }
+
+            needShow = false;
+        }
+    }
+
+    data->window_state = newstate;
+
+    if (needShow)
+        show();
+
+    if (newstate & Qt::WindowActive)
+        activateWindow();
+
+    QWindowStateChangeEvent e(oldstate);
+    QApplication::sendEvent(this, &e);
+}
+
+/*!
+  \internal
+  Platform-specific part of QWidget::show().
+*/
+
+void QWidgetPrivate::show_sys()
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+
+    if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
+        invalidateBuffer(q->rect());
+        q->setAttribute(Qt::WA_Mapped);
+        if (QTLWExtra *tlwExtra = maybeTopData())
+            tlwExtra->waitingForMapNotify = 0;
+        return;
+    }
+
+    if (q->isWindow()) {
+        XWMHints *h = XGetWMHints(X11->display, q->internalWinId());
+        XWMHints  wm_hints;
+        bool got_hints = h != 0;
+        if (!got_hints) {
+            memset(&wm_hints, 0, sizeof(wm_hints)); // make valgrind happy
+            h = &wm_hints;
+        }
+        h->initial_state = q->isMinimized() ? IconicState : NormalState;
+        h->flags |= StateHint;
+        XSetWMHints(X11->display, q->internalWinId(), h);
+        if (got_hints)
+            XFree((char *)h);
+
+        // update WM_NORMAL_HINTS
+        do_size_hints(q, extra);
+
+        // udpate WM_TRANSIENT_FOR
+        if (isTransient(q)) {
+            QWidget *p = q->parentWidget();
+
+#ifndef QT_NO_MENU
+            // hackish ... try to find the main window related to this QMenu
+            if (qobject_cast<QMenu *>(q)) {
+                p = static_cast<QMenuPrivate*>(this)->causedPopup.widget;
+                if (!p)
+                    p = q->parentWidget();
+                if (!p)
+                    p = QApplication::widgetAt(q->pos());
+                if (!p)
+                    p = qApp->activeWindow();
+            }
+#endif
+            if (p)
+                p = p->window();
+            if (p) {
+                // transient for window
+                XSetTransientForHint(X11->display, q->internalWinId(), p->internalWinId());
+            } else {
+                // transient for group
+                XSetTransientForHint(X11->display, q->internalWinId(), X11->wm_client_leader);
+            }
+        }
+
+        // update _MOTIF_WM_HINTS
+        QtMWMHints mwmhints = GetMWMHints(X11->display, q->internalWinId());
+
+        if (data.window_modality != Qt::NonModal) {
+            switch (data.window_modality) {
+            case Qt::WindowModal:
+                mwmhints.input_mode = MWM_INPUT_PRIMARY_APPLICATION_MODAL;
+                break;
+            case Qt::ApplicationModal:
+            default:
+                mwmhints.input_mode = MWM_INPUT_FULL_APPLICATION_MODAL;
+                break;
+            }
+            mwmhints.flags |= MWM_HINTS_INPUT_MODE;
+        } else {
+            mwmhints.input_mode = MWM_INPUT_MODELESS;
+            mwmhints.flags &= ~MWM_HINTS_INPUT_MODE;
+        }
+
+        if (q->minimumSize() == q->maximumSize()) {
+            // fixed size, remove the resize handle (since mwm/dtwm
+            // isn't smart enough to do it itself)
+            mwmhints.flags |= MWM_HINTS_FUNCTIONS;
+            if (mwmhints.functions == MWM_FUNC_ALL) {
+                mwmhints.functions = MWM_FUNC_MOVE;
+            } else {
+                mwmhints.functions &= ~MWM_FUNC_RESIZE;
+            }
+
+            if (mwmhints.decorations == MWM_DECOR_ALL) {
+                mwmhints.flags |= MWM_HINTS_DECORATIONS;
+                mwmhints.decorations = (MWM_DECOR_BORDER
+                                        | MWM_DECOR_TITLE
+                                        | MWM_DECOR_MENU);
+            } else {
+                mwmhints.decorations &= ~MWM_DECOR_RESIZEH;
+            }
+
+            if (q->windowFlags() & Qt::WindowMinimizeButtonHint) {
+                mwmhints.flags |= MWM_HINTS_DECORATIONS;
+                mwmhints.decorations |= MWM_DECOR_MINIMIZE;
+                mwmhints.functions |= MWM_FUNC_MINIMIZE;
+            }
+            if (q->windowFlags() & Qt::WindowMaximizeButtonHint) {
+                mwmhints.flags |= MWM_HINTS_DECORATIONS;
+                mwmhints.decorations |= MWM_DECOR_MAXIMIZE;
+                mwmhints.functions |= MWM_FUNC_MAXIMIZE;
+            }
+            if (q->windowFlags() & Qt::WindowCloseButtonHint)
+                mwmhints.functions |= MWM_FUNC_CLOSE;
+        }
+
+        SetMWMHints(X11->display, q->internalWinId(), mwmhints);
+
+        // update _NET_WM_STATE
+        QVector<Atom> netWmState = getNetWmState(q);
+
+        Qt::WindowFlags flags = q->windowFlags();
+        if (flags & Qt::WindowStaysOnTopHint) {
+            if (flags & Qt::WindowStaysOnBottomHint)
+                qWarning() << "QWidget: Incompatible window flags: the window can't be on top and on bottom at the same time";
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_ABOVE)))
+                netWmState.append(ATOM(_NET_WM_STATE_ABOVE));
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_STAYS_ON_TOP)))
+                netWmState.append(ATOM(_NET_WM_STATE_STAYS_ON_TOP));
+        } else if (flags & Qt::WindowStaysOnBottomHint) {
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_BELOW)))
+                netWmState.append(ATOM(_NET_WM_STATE_BELOW));
+        }
+        if (q->isFullScreen()) {
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_FULLSCREEN)))
+                netWmState.append(ATOM(_NET_WM_STATE_FULLSCREEN));
+        }
+        if (q->isMaximized()) {
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ)))
+                netWmState.append(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ));
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_MAXIMIZED_VERT)))
+                netWmState.append(ATOM(_NET_WM_STATE_MAXIMIZED_VERT));
+        }
+        if (data.window_modality != Qt::NonModal) {
+            if (!netWmState.contains(ATOM(_NET_WM_STATE_MODAL)))
+                netWmState.append(ATOM(_NET_WM_STATE_MODAL));
+        }
+
+        if (!netWmState.isEmpty()) {
+            XChangeProperty(X11->display, q->internalWinId(),
+                            ATOM(_NET_WM_STATE), XA_ATOM, 32, PropModeReplace,
+                            (unsigned char *) netWmState.data(), netWmState.size());
+        } else {
+            XDeleteProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_STATE));
+        }
+
+        // set _NET_WM_USER_TIME
+        Time userTime = X11->userTime;
+        bool setUserTime = false;
+        if (q->testAttribute(Qt::WA_ShowWithoutActivating)) {
+            userTime = 0;
+            setUserTime = true;
+        } else if (userTime != CurrentTime) {
+            setUserTime = true;
+        }
+        if (setUserTime)
+            qt_net_update_user_time(q, userTime);
+
+#ifndef QT_NO_XSYNC
+        if (!topData()->syncUpdateCounter) {
+            XSyncValue value;
+            XSyncIntToValue(&value, 0);
+            topData()->syncUpdateCounter = XSyncCreateCounter(X11->display, value);
+
+            XChangeProperty(X11->display, q->internalWinId(),
+                            ATOM(_NET_WM_SYNC_REQUEST_COUNTER),
+                            XA_CARDINAL,
+                            32, PropModeReplace,
+                            (uchar *) &topData()->syncUpdateCounter, 1);
+
+            topData()->newCounterValueHi = 0;
+            topData()->newCounterValueLo = 0;
+        }
+#endif
+
+        if (!topData()->embedded
+            && (topData()->validWMState || topData()->waitingForMapNotify)
+            && !q->isMinimized()) {
+            X11->deferred_map.append(q);
+            return;
+        }
+
+        if (q->isMaximized() && !q->isFullScreen()
+            && !(X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ))
+                 && X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_VERT)))) {
+            XMapWindow(X11->display, q->internalWinId());
+            data.fstrut_dirty = true;
+            qt_x11_wait_for_window_manager(q);
+
+            // if the wm was not smart enough to adjust our size, do that manually
+            QRect maxRect = QApplication::desktop()->availableGeometry(q);
+
+            QTLWExtra *top = topData();
+            QRect normalRect = top->normalGeometry;
+            const QRect fs = frameStrut();
+
+            q->setGeometry(maxRect.x() + fs.left(),
+                           maxRect.y() + fs.top(),
+                           maxRect.width() - fs.left() - fs.right(),
+                           maxRect.height() - fs.top() - fs.bottom());
+
+            // restore the original normalGeometry
+            top->normalGeometry = normalRect;
+            // internalSetGeometry() clears the maximized flag... make sure we set it back
+            data.window_state = data.window_state | Qt::WindowMaximized;
+            q->setAttribute(Qt::WA_Mapped);
+            return;
+        }
+
+        if (q->isFullScreen() && !X11->isSupportedByWM(ATOM(_NET_WM_STATE_FULLSCREEN))) {
+            XMapWindow(X11->display, q->internalWinId());
+            qt_x11_wait_for_window_manager(q);
+            q->setAttribute(Qt::WA_Mapped);
+            return;
+        }
+    }
+
+    invalidateBuffer(q->rect());
+
+    if (q->testAttribute(Qt::WA_OutsideWSRange))
+        return;
+    q->setAttribute(Qt::WA_Mapped);
+    if (q->isWindow())
+        topData()->waitingForMapNotify = 1;
+
+    if (!q->isWindow()
+        && (!q->autoFillBackground()
+            || q->palette().brush(q->backgroundRole()).style() == Qt::LinearGradientPattern)) {
+        if (q->internalWinId()) {
+            XSetWindowBackgroundPixmap(X11->display, q->internalWinId(), XNone);
+            XMapWindow(X11->display, q->internalWinId());
+            updateSystemBackground();
+        }
+        return;
+    }
+
+    if (q->internalWinId())
+        XMapWindow(X11->display, q->internalWinId());
+
+    // Freedesktop.org Startup Notification
+    if (X11->startupId && q->isWindow()) {
+        QByteArray message("remove: ID=");
+        message.append(X11->startupId);
+        sendStartupMessage(message.constData());
+        X11->startupId = 0;
+    }
+}
+
+/*!
+  \internal
+  Platform-specific part of QWidget::show().
+*/
+
+void QWidgetPrivate::sendStartupMessage(const char *message) const
+{
+    Q_Q(const QWidget);
+
+    if (!message)
+        return;
+
+    XEvent xevent;
+    xevent.xclient.type = ClientMessage;
+    xevent.xclient.message_type = ATOM(_NET_STARTUP_INFO_BEGIN);
+    xevent.xclient.display = X11->display;
+    xevent.xclient.window = q->internalWinId();
+    xevent.xclient.format = 8;
+
+    Window rootWindow = RootWindow(X11->display, DefaultScreen(X11->display));
+    uint sent = 0;
+    uint length = strlen(message) + 1;
+    do {
+        if (sent == 20)
+            xevent.xclient.message_type = ATOM(_NET_STARTUP_INFO);
+
+        for (uint i = 0; i < 20 && i + sent <= length; i++)
+            xevent.xclient.data.b[i] = message[i + sent++];
+
+        XSendEvent(X11->display, rootWindow, false, PropertyChangeMask, &xevent);
+    } while (sent <= length);
+}
+
+void QWidgetPrivate::setNetWmWindowTypes()
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+
+    if (!q->isWindow()) {
+        if (q->internalWinId())
+            XDeleteProperty(X11->display, q->internalWinId(), ATOM(_NET_WM_WINDOW_TYPE));
+        return;
+    }
+
+    QVector<long> windowTypes;
+
+    // manual selection 1 (these are never set by Qt and take precedence)
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDesktop))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DESKTOP));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDock))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DOCK));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeNotification))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NOTIFICATION));
+
+    // manual selection 2 (Qt uses these during auto selection);
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeUtility))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_UTILITY));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeSplash))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_SPLASH));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDialog))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DIALOG));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolTip))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_TOOLTIP));
+
+    // manual selection 3 (these can be set by Qt, but don't have a
+    // corresponding Qt::WindowType). note that order of the *MENU
+    // atoms is important
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeMenu))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_MENU));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDropDownMenu))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DROPDOWN_MENU));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypePopupMenu))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_POPUP_MENU));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolBar))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_TOOLBAR));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeCombo))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_COMBO));
+    if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDND))
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DND));
+
+    // automatic selection
+    switch (q->windowType()) {
+    case Qt::Dialog:
+    case Qt::Sheet:
+        // dialog netwm type
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_DIALOG));
+        break;
+
+    case Qt::Tool:
+    case Qt::Drawer:
+        // utility netwm type
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_UTILITY));
+        break;
+
+    case Qt::ToolTip:
+        // tooltip netwm type
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_TOOLTIP));
+        break;
+
+    case Qt::SplashScreen:
+        // splash netwm type
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_SPLASH));
+        break;
+
+    default:
+        break;
+    }
+
+    if (q->windowFlags() & Qt::FramelessWindowHint) {
+        // override netwm type - quick and easy for KDE noborder
+        windowTypes.append(ATOM(_KDE_NET_WM_WINDOW_TYPE_OVERRIDE));
+    }
+
+    // normal netwm type - default
+    windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NORMAL));
+
+    if (!windowTypes.isEmpty()) {
+        XChangeProperty(X11->display, q->winId(), ATOM(_NET_WM_WINDOW_TYPE), XA_ATOM, 32,
+                        PropModeReplace, (unsigned char *) windowTypes.constData(),
+                        windowTypes.count());
+    } else {
+        XDeleteProperty(X11->display, q->winId(), ATOM(_NET_WM_WINDOW_TYPE));
+    }
+}
+
+/*!
+  \internal
+  Platform-specific part of QWidget::hide().
+*/
+
+void QWidgetPrivate::hide_sys()
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    deactivateWidgetCleanup();
+    if (q->isWindow()) {
+        X11->deferred_map.removeAll(q);
+        if (q->internalWinId()) // in nsplugin, may be 0
+            XWithdrawWindow(X11->display, q->internalWinId(), xinfo.screen());
+        XFlush(X11->display);
+    } else {
+        invalidateBuffer(q->rect());
+        if (q->internalWinId()) // in nsplugin, may be 0
+            XUnmapWindow(X11->display, q->internalWinId());
+    }
+    q->setAttribute(Qt::WA_Mapped, false);
+}
+
+void QWidgetPrivate::setFocus_sys()
+{
+
+}
+
+
+void QWidgetPrivate::raise_sys()
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    if (q->internalWinId())
+        XRaiseWindow(X11->display, q->internalWinId());
+}
+
+void QWidgetPrivate::lower_sys()
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    if (q->internalWinId())
+        XLowerWindow(X11->display, q->internalWinId());
+    if(!q->isWindow())
+        invalidateBuffer(q->rect());
+}
+
+void QWidgetPrivate::stackUnder_sys(QWidget* w)
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    if (q->internalWinId() && w->internalWinId()) {
+        Window stack[2];
+        stack[0] = w->internalWinId();;
+        stack[1] = q->internalWinId();
+        XRestackWindows(X11->display, stack, 2);
+    }
+    if(!q->isWindow() || !w->internalWinId())
+        invalidateBuffer(q->rect());
+}
+
+
+static void do_size_hints(QWidget* widget, QWExtra *x)
+{
+    Q_ASSERT(widget->testAttribute(Qt::WA_WState_Created));
+    XSizeHints s;
+    memset(&s, 0, sizeof(s));
+    if (x) {
+        QRect g = widget->geometry();
+        s.x = g.x();
+        s.y = g.y();
+        s.width = g.width();
+        s.height = g.height();
+        if (x->minw > 0 || x->minh > 0) {
+            // add minimum size hints
+            s.flags |= PMinSize;
+            s.min_width  = qMin(XCOORD_MAX, x->minw);
+            s.min_height = qMin(XCOORD_MAX, x->minh);
+        }
+        if (x->maxw < QWIDGETSIZE_MAX || x->maxh < QWIDGETSIZE_MAX) {
+            // add maximum size hints
+            s.flags |= PMaxSize;
+            s.max_width  = qMin(XCOORD_MAX, x->maxw);
+            s.max_height = qMin(XCOORD_MAX, x->maxh);
+        }
+        if (x->topextra &&
+            (x->topextra->incw > 0 || x->topextra->inch > 0)) {
+            // add resize increment hints
+            s.flags |= PResizeInc | PBaseSize;
+            s.width_inc = x->topextra->incw;
+            s.height_inc = x->topextra->inch;
+            s.base_width = x->topextra->basew;
+            s.base_height = x->topextra->baseh;
+        }
+    }
+    if (widget->testAttribute(Qt::WA_Moved)) {
+        // user (i.e. command-line) specified position
+        s.flags |= USPosition;
+        s.flags |= PPosition;
+    }
+    if (widget->testAttribute(Qt::WA_Resized)) {
+        // user (i.e. command-line) specified size
+        s.flags |= USSize;
+        s.flags |= PSize;
+    }
+    s.flags |= PWinGravity;
+    if (widget->testAttribute(Qt::WA_Moved) && x && x->topextra && !x->topextra->posFromMove) {
+        // position came from setGeometry(), tell the WM that we don't
+        // want our window gravity-shifted
+        s.win_gravity = StaticGravity;
+    } else {
+        // position came from move()
+        s.x = widget->x();
+        s.y = widget->y();
+        s.win_gravity = QApplication::isRightToLeft() ? NorthEastGravity : NorthWestGravity;
+    }
+    if (widget->internalWinId())
+        XSetWMNormalHints(X11->display, widget->internalWinId(), &s);
+}
+
+
+/*
+  Helper function for non-toplevel widgets. Helps to map Qt's 32bit
+  coordinate system to X11's 16bit coordinate system.
+
+  Sets the geometry of the widget to data.crect, but clipped to sizes
+  that X can handle. Unmaps widgets that are completely outside the
+  valid range.
+
+  Maintains data.wrect, which is the geometry of the X widget,
+  measured in this widget's coordinate system.
+
+  if the parent is not clipped, parentWRect is empty, otherwise
+  parentWRect is the geometry of the parent's X rect, measured in
+  parent's coord sys
+ */
+void QWidgetPrivate::setWSGeometry(bool dontShow, const QRect &)
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+
+    /*
+      There are up to four different coordinate systems here:
+      Qt coordinate system for this widget.
+      X coordinate system for this widget (relative to wrect).
+      Qt coordinate system for parent
+      X coordinate system for parent (relative to parent's wrect).
+     */
+    Display *dpy = xinfo.display();
+    QRect validRange(-XCOORD_MAX,-XCOORD_MAX, 2*XCOORD_MAX, 2*XCOORD_MAX);
+    QRect wrectRange(-WRECT_MAX,-WRECT_MAX, 2*WRECT_MAX, 2*WRECT_MAX);
+    QRect wrect;
+    //xrect is the X geometry of my X widget. (starts out in  parent's Qt coord sys, and ends up in parent's X coord sys)
+    QRect xrect = data.crect;
+
+    const QWidget *const parent = q->parentWidget();
+    QRect parentWRect = parent->data->wrect;
+
+    if (parentWRect.isValid()) {
+        // parent is clipped, and we have to clip to the same limit as parent
+        if (!parentWRect.contains(xrect)) {
+            xrect &= parentWRect;
+            wrect = xrect;
+            //translate from parent's to my Qt coord sys
+            wrect.translate(-data.crect.topLeft());
+        }
+        //translate from parent's Qt coords to parent's X coords
+        xrect.translate(-parentWRect.topLeft());
+
+    } else {
+        // parent is not clipped, we may or may not have to clip
+
+        if (data.wrect.isValid() && QRect(QPoint(),data.crect.size()).contains(data.wrect)) {
+            // This is where the main optimization is: we are already
+            // clipped, and if our clip is still valid, we can just
+            // move our window, and do not need to move or clip
+            // children
+
+            QRect vrect = xrect & parent->rect();
+            vrect.translate(-data.crect.topLeft()); //the part of me that's visible through parent, in my Qt coords
+            if (data.wrect.contains(vrect)) {
+                xrect = data.wrect;
+                xrect.translate(data.crect.topLeft());
+                if (data.winid)
+                    XMoveWindow(dpy, data.winid, xrect.x(), xrect.y());
+                return;
+            }
+        }
+
+        if (!validRange.contains(xrect)) {
+            // we are too big, and must clip
+            xrect &=wrectRange;
+            wrect = xrect;
+            wrect.translate(-data.crect.topLeft());
+            //parent's X coord system is equal to parent's Qt coord
+            //sys, so we don't need to map xrect.
+        }
+
+    }
+
+    // unmap if we are outside the valid window system coord system
+    bool outsideRange = !xrect.isValid();
+    bool mapWindow = false;
+    if (q->testAttribute(Qt::WA_OutsideWSRange) != outsideRange) {
+        q->setAttribute(Qt::WA_OutsideWSRange, outsideRange);
+        if (outsideRange) {
+            if (data.winid)
+                XUnmapWindow(dpy, data.winid);
+            q->setAttribute(Qt::WA_Mapped, false);
+        } else if (!q->isHidden()) {
+            mapWindow = true;
+        }
+    }
+
+    if (outsideRange)
+        return;
+
+    bool jump = (data.wrect != wrect);
+    data.wrect = wrect;
+
+
+    // and now recursively for all children...
+    // ### can be optimized
+    for (int i = 0; i < children.size(); ++i) {
+        QObject *object = children.at(i);
+        if (object->isWidgetType()) {
+            QWidget *w = static_cast<QWidget *>(object);
+            if (!w->isWindow() && w->testAttribute(Qt::WA_WState_Created))
+                w->d_func()->setWSGeometry(jump);
+        }
+    }
+
+    if (data.winid) {
+        // move ourselves to the new position and map (if necessary) after
+        // the movement. Rationale: moving unmapped windows is much faster
+        // than moving mapped windows
+        if (jump) //avoid flicker when jumping
+            XSetWindowBackgroundPixmap(dpy, data.winid, XNone);
+        if (!parent->internalWinId())
+            xrect.translate(parent->mapTo(q->nativeParentWidget(), QPoint(0, 0)));
+        XMoveResizeWindow(dpy, data.winid, xrect.x(), xrect.y(), xrect.width(), xrect.height());
+    }
+
+    //to avoid flicker, we have to show children after the helper widget has moved
+    if (jump) {
+        for (int i = 0; i < children.size(); ++i) {
+            QObject *object = children.at(i);
+            if (object->isWidgetType()) {
+                QWidget *w = static_cast<QWidget *>(object);
+                if (!w->testAttribute(Qt::WA_OutsideWSRange) && !w->testAttribute(Qt::WA_Mapped) && !w->isHidden()) {
+                    w->setAttribute(Qt::WA_Mapped);
+                    if (w->internalWinId())
+                        XMapWindow(dpy, w->data->winid);
+                }
+            }
+        }
+    }
+
+
+    if  (jump && data.winid)
+        XClearArea(dpy, data.winid, 0, 0, wrect.width(), wrect.height(), True);
+
+    if (mapWindow && !dontShow) {
+        q->setAttribute(Qt::WA_Mapped);
+        if (data.winid)
+            XMapWindow(dpy, data.winid);
+    }
+}
+
+void QWidgetPrivate::setGeometry_sys(int x, int y, int w, int h, bool isMove)
+{
+    Q_Q(QWidget);
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+    Display *dpy = X11->display;
+
+    if ((q->windowType() == Qt::Desktop))
+        return;
+    if (q->isWindow()) {
+        if (!X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_VERT))
+            && !X11->isSupportedByWM(ATOM(_NET_WM_STATE_MAXIMIZED_HORZ)))
+            data.window_state &= ~Qt::WindowMaximized;
+        if (!X11->isSupportedByWM(ATOM(_NET_WM_STATE_FULLSCREEN)))
+            data.window_state &= ~Qt::WindowFullScreen;
+        if (QTLWExtra *topData = maybeTopData())
+            topData->normalGeometry = QRect(0,0,-1,-1);
+    } else {
+        uint s = data.window_state;
+        s &= ~(Qt::WindowMaximized | Qt::WindowFullScreen);
+        data.window_state = s;
+    }
+    if (extra) {                                // any size restrictions?
+        w = qMin(w,extra->maxw);
+        h = qMin(h,extra->maxh);
+        w = qMax(w,extra->minw);
+        h = qMax(h,extra->minh);
+    }
+    QPoint oldPos(q->pos());
+    QSize oldSize(q->size());
+    QRect oldGeom(data.crect);
+    QRect  r(x, y, w, h);
+
+    // We only care about stuff that changes the geometry, or may
+    // cause the window manager to change its state
+    if (!q->isWindow() && oldGeom == r)
+        return;
+
+    data.crect = r;
+    bool isResize = q->size() != oldSize;
+
+    if (q->isWindow()) {
+        if (w == 0 || h == 0) {
+            q->setAttribute(Qt::WA_OutsideWSRange, true);
+            if (q->isVisible() && q->testAttribute(Qt::WA_Mapped))
+                hide_sys();
+        } else if (q->isVisible() && q->testAttribute(Qt::WA_OutsideWSRange)) {
+            q->setAttribute(Qt::WA_OutsideWSRange, false);
+
+            // put the window in its place and show it
+            if (data.winid)
+                XMoveResizeWindow(dpy, data.winid, x, y, w, h);
+            topData()->posFromMove = false; // force StaticGravity
+            do_size_hints(q, extra);
+            show_sys();
+        } else {
+            q->setAttribute(Qt::WA_OutsideWSRange, false);
+            if (!q->isVisible())
+                do_size_hints(q, extra);
+            if (isMove) {
+                if ((data.window_flags & Qt::X11BypassWindowManagerHint) == Qt::X11BypassWindowManagerHint
+                    // work around 4Dwm's incompliance with ICCCM 4.1.5
+                    || X11->desktopEnvironment == DE_4DWM) {
+                    if (data.winid)
+                        XMoveResizeWindow(dpy, data.winid, x, y, w, h);
+                } else if (q->isVisible()
+                           && topData()->validWMState
+                           && X11->isSupportedByWM(ATOM(_NET_MOVERESIZE_WINDOW))) {
+                    XEvent e;
+                    e.xclient.type = ClientMessage;
+                    e.xclient.message_type = ATOM(_NET_MOVERESIZE_WINDOW);
+                    e.xclient.display = X11->display;
+                    e.xclient.window = q->internalWinId();
+                    e.xclient.format = 32;
+                    e.xclient.data.l[0] = StaticGravity | 1<<8 | 1<<9 | 1<<10 | 1<<11 | 1<<12;
+                    e.xclient.data.l[1] = x;
+                    e.xclient.data.l[2] = y;
+                    e.xclient.data.l[3] = w;
+                    e.xclient.data.l[4] = h;
+                    XSendEvent(X11->display, RootWindow(X11->display, q->x11Info().screen()),
+                               false, (SubstructureNotifyMask | SubstructureRedirectMask), &e);
+                } else if (data.winid) {
+                    // pos() is right according to ICCCM 4.1.5
+                    XMoveResizeWindow(dpy, data.winid, q->pos().x(), q->pos().y(), w, h);
+                }
+            } else if (isResize && data.winid) {
+                if (!q->isVisible()
+                    && topData()->validWMState
+                    && !q->testAttribute(Qt::WA_PendingMoveEvent)) {
+                    /*
+                       even though we've not visible, we could be in a
+                       race w/ the window manager, and it may ignore
+                       our ConfigureRequest. setting posFromMove to
+                       false makes sure that doDeferredMap() in
+                       qapplication_x11.cpp keeps the window in the
+                       right place
+                    */
+                    topData()->posFromMove = false;
+                }
+                XResizeWindow(dpy, data.winid, w, h);
+            }
+        }
+        if (isResize && !q->testAttribute(Qt::WA_DontShowOnScreen)) // set config pending only on resize, see qapplication_x11.cpp, translateConfigEvent()
+            q->setAttribute(Qt::WA_WState_ConfigPending);
+
+    } else {
+        QTLWExtra *tlwExtra = q->window()->d_func()->maybeTopData();
+        const bool inTopLevelResize = tlwExtra ? tlwExtra->inTopLevelResize : false;
+        const bool disableInTopLevelResize = inTopLevelResize && q->internalWinId();
+        if (disableInTopLevelResize) {
+            // Top-level resize optimization does not work for native child widgets;
+            // disable it for this particular widget.
+            tlwExtra->inTopLevelResize = false;
+        }
+
+        if (!isResize && (!inTopLevelResize || disableInTopLevelResize) && q->isVisible()) {
+            moveRect(QRect(oldPos, oldSize), x - oldPos.x(), y - oldPos.y());
+        }
+        if (q->testAttribute(Qt::WA_WState_Created))
+            setWSGeometry();
+
+        if (isResize && (!inTopLevelResize || disableInTopLevelResize) && q->isVisible())
+            invalidateBuffer_resizeHelper(oldPos, oldSize);
+
+        if (disableInTopLevelResize)
+            tlwExtra->inTopLevelResize = true;
+    }
+
+    if (q->isVisible()) {
+        if (isMove && q->pos() != oldPos) {
+            if (X11->desktopEnvironment != DE_4DWM) {
+                // pos() is right according to ICCCM 4.1.5
+                QMoveEvent e(q->pos(), oldPos);
+                QApplication::sendEvent(q, &e);
+            } else {
+                // work around 4Dwm's incompliance with ICCCM 4.1.5
+                QMoveEvent e(data.crect.topLeft(), oldGeom.topLeft());
+                QApplication::sendEvent(q, &e);
+            }
+        }
+        if (isResize) {
+            static bool slowResize = qgetenv("QT_SLOW_TOPLEVEL_RESIZE").toInt();
+            // If we have a backing store with static contents, we have to disable the top-level
+            // resize optimization in order to get invalidated regions for resized widgets.
+            // The optimization discards all invalidateBuffer() calls since we're going to
+            // repaint everything anyways, but that's not the case with static contents.
+            const bool setTopLevelResize = !slowResize && q->isWindow() && extra && extra->topextra
+                                           && !extra->topextra->inTopLevelResize
+                                           && (!extra->topextra->backingStore
+                                               || !extra->topextra->backingStore->hasStaticContents());
+            if (setTopLevelResize)
+                extra->topextra->inTopLevelResize = true;
+            QResizeEvent e(q->size(), oldSize);
+            QApplication::sendEvent(q, &e);
+            if (setTopLevelResize)
+                extra->topextra->inTopLevelResize = false;
+        }
+    } else {
+        if (isMove && q->pos() != oldPos)
+            q->setAttribute(Qt::WA_PendingMoveEvent, true);
+        if (isResize)
+            q->setAttribute(Qt::WA_PendingResizeEvent, true);
+    }
+}
+
+void QWidgetPrivate::setConstraints_sys()
+{
+    Q_Q(QWidget);
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::setConstraints_sys START" << q;
+#endif
+    if (q->testAttribute(Qt::WA_WState_Created)) {
+        do_size_hints(q, extra);
+        QtMWMHints mwmHints = GetMWMHints(X11->display, q->internalWinId());
+        const bool wasFuncResize = mwmHints.functions & MWM_FUNC_RESIZE;
+        if (q->minimumSize() == q->maximumSize())
+            mwmHints.functions &= ~MWM_FUNC_RESIZE;
+        else
+            mwmHints.functions |= MWM_FUNC_RESIZE;
+        if (wasFuncResize != (mwmHints.functions & MWM_FUNC_RESIZE))
+            SetMWMHints(X11->display, q->internalWinId(), mwmHints);
+    }
+#ifdef ALIEN_DEBUG
+    qDebug() << "QWidgetPrivate::setConstraints_sys END" << q;
+#endif
+}
+
+void QWidgetPrivate::scroll_sys(int dx, int dy)
+{
+    Q_Q(QWidget);
+
+    scrollChildren(dx, dy);
+    if (!paintOnScreen()) {
+        scrollRect(q->rect(), dx, dy);
+    } else {
+        scroll_sys(dx, dy, QRect());
+    }
+}
+
+void QWidgetPrivate::scroll_sys(int dx, int dy, const QRect &r)
+{
+    Q_Q(QWidget);
+
+    if (!paintOnScreen()) {
+        scrollRect(r, dx, dy);
+        return;
+    }
+    bool valid_rect = r.isValid();
+    bool just_update = qAbs(dx) > q->width() || qAbs(dy) > q->height();
+    QRect sr = valid_rect ? r : clipRect();
+    if (just_update)
+        q->update();
+    else if (!valid_rect)
+        dirty.translate(dx, dy);
+
+    int x1, y1, x2, y2, w = sr.width(), h = sr.height();
+    if (dx > 0) {
+        x1 = sr.x();
+        x2 = x1+dx;
+        w -= dx;
+    } else {
+        x2 = sr.x();
+        x1 = x2-dx;
+        w += dx;
+    }
+    if (dy > 0) {
+        y1 = sr.y();
+        y2 = y1+dy;
+        h -= dy;
+    } else {
+        y2 = sr.y();
+        y1 = y2-dy;
+        h += dy;
+    }
+
+    if (dx == 0 && dy == 0)
+        return;
+
+    Display *dpy = X11->display;
+    // Want expose events
+    if (w > 0 && h > 0 && !just_update && q->internalWinId()) {
+        GC gc = XCreateGC(dpy, q->internalWinId(), 0, 0);
+        XSetGraphicsExposures(dpy, gc, True);
+        XCopyArea(dpy, q->internalWinId(), q->internalWinId(), gc, x1, y1, w, h, x2, y2);
+        XFreeGC(dpy, gc);
+    }
+
+    if (!valid_rect && !children.isEmpty()) {        // scroll children
+        QPoint pd(dx, dy);
+        for (int i = 0; i < children.size(); ++i) { // move all children
+            register QObject *object = children.at(i);
+            if (object->isWidgetType()) {
+                QWidget *w = static_cast<QWidget *>(object);
+                if (!w->isWindow())
+                    w->move(w->pos() + pd);
+            }
+        }
+    }
+
+    if (just_update)
+        return;
+
+    // Don't let the server be bogged-down with repaint events
+    bool repaint_immediately = (qt_sip_count(q) < 3 && !q->testAttribute(Qt::WA_WState_InPaintEvent));
+
+    if (dx) {
+        int x = x2 == sr.x() ? sr.x()+w : sr.x();
+        if (repaint_immediately)
+            q->repaint(x, sr.y(), qAbs(dx), sr.height());
+        else if (q->internalWinId())
+            XClearArea(dpy, data.winid, x, sr.y(), qAbs(dx), sr.height(), True);
+    }
+    if (dy) {
+        int y = y2 == sr.y() ? sr.y()+h : sr.y();
+        if (repaint_immediately)
+            q->repaint(sr.x(), y, sr.width(), qAbs(dy));
+        else if (q->internalWinId())
+            XClearArea(dpy, data.winid, sr.x(), y, sr.width(), qAbs(dy), True);
+    }
+
+    qt_insert_sip(q, dx, dy); // #### ignores r
+}
+
+int QWidget::metric(PaintDeviceMetric m) const
+{
+    Q_D(const QWidget);
+    int val;
+    if (m == PdmWidth) {
+        val = data->crect.width();
+    } else if (m == PdmHeight) {
+        val = data->crect.height();
+    } else {
+        Display *dpy = X11->display;
+        int scr = d->xinfo.screen();
+        switch (m) {
+            case PdmDpiX:
+            case PdmPhysicalDpiX:
+                if (d->extra && d->extra->customDpiX)
+                    val = d->extra->customDpiX;
+                else if (d->parent)
+                    val = static_cast<QWidget *>(d->parent)->metric(m);
+                else
+                    val = QX11Info::appDpiX(scr);
+                break;
+            case PdmDpiY:
+            case PdmPhysicalDpiY:
+                if (d->extra && d->extra->customDpiY)
+                    val = d->extra->customDpiY;
+                else if (d->parent)
+                    val = static_cast<QWidget *>(d->parent)->metric(m);
+                else
+                    val = QX11Info::appDpiY(scr);
+                break;
+            case PdmWidthMM:
+                val = (DisplayWidthMM(dpy,scr)*data->crect.width())/
+                      DisplayWidth(dpy,scr);
+                break;
+            case PdmHeightMM:
+                val = (DisplayHeightMM(dpy,scr)*data->crect.height())/
+                      DisplayHeight(dpy,scr);
+                break;
+            case PdmNumColors:
+                val = d->xinfo.cells();
+                break;
+            case PdmDepth:
+                val = d->xinfo.depth();
+                break;
+            default:
+                val = 0;
+                qWarning("QWidget::metric: Invalid metric command");
+        }
+    }
+    return val;
+}
+
+void QWidgetPrivate::createSysExtra()
+{
+    extra->compress_events = true;
+    extra->xDndProxy = 0;
+}
+
+void QWidgetPrivate::deleteSysExtra()
+{
+}
+
+void QWidgetPrivate::createTLSysExtra()
+{
+    extra->topextra->spont_unmapped = 0;
+    extra->topextra->dnd = 0;
+    extra->topextra->validWMState = 0;
+    extra->topextra->waitingForMapNotify = 0;
+    extra->topextra->parentWinId = 0;
+    extra->topextra->userTimeWindow = 0;
+#ifndef QT_NO_XSYNC
+    extra->topextra->syncUpdateCounter = 0;
+    extra->topextra->syncRequestTimestamp = 0;
+    extra->topextra->newCounterValueHi = 0;
+    extra->topextra->newCounterValueLo = 0;
+#endif
+}
+
+void QWidgetPrivate::deleteTLSysExtra()
+{
+    // don't destroy input context here. it will be destroyed in
+    // QWidget::destroy() destroyInputContext();
+#ifndef QT_NO_XSYNC
+    if (extra && extra->topextra && extra->topextra->syncUpdateCounter) {
+        XSyncDestroyCounter(X11->display, extra->topextra->syncUpdateCounter);
+        extra->topextra->syncUpdateCounter = 0;
+    }
+#endif
+}
+
+void QWidgetPrivate::registerDropSite(bool on)
+{
+    Q_UNUSED(on);
+}
+
+void QWidgetPrivate::setMask_sys(const QRegion &region)
+{
+    Q_Q(QWidget);
+    if (!q->internalWinId())
+        return;
+
+    if (region.isEmpty()) {
+        XShapeCombineMask(X11->display, q->internalWinId(), ShapeBounding, 0, 0,
+                          XNone, ShapeSet);
+    } else {
+        XShapeCombineRegion(X11->display, q->internalWinId(), ShapeBounding, 0, 0,
+                            region.handle(), ShapeSet);
+    }
+}
+
+/*!
+  \internal
+
+  Computes the frame rectangle when needed.  This is an internal function, you
+  should never call this.
+*/
+
+void QWidgetPrivate::updateFrameStrut()
+{
+    Q_Q(QWidget);
+
+    QTLWExtra *top = topData();
+    if (!top->validWMState) {
+        return;
+    }
+    if (!q->isWindow() && !q->internalWinId()) {
+        data.fstrut_dirty = false;
+        return;
+    }
+
+    Atom type_ret;
+    Window l = q->effectiveWinId(), w = l, p, r; // target window, its parent, root
+    Window *c;
+    int i_unused;
+    unsigned int nc;
+    unsigned char *data_ret;
+    unsigned long l_unused;
+
+    while (XQueryTree(X11->display, w, &r, &p, &c, &nc)) {
+        if (c && nc > 0)
+            XFree(c);
+
+        if (! p) {
+            qWarning("QWidget::updateFrameStrut: No parent");
+            return;
+        }
+
+        // if the parent window is the root window, an Enlightenment virtual root or
+        // a NET WM virtual root window, stop here
+        data_ret = 0;
+        if (p == r ||
+            (XGetWindowProperty(X11->display, p,
+                                ATOM(ENLIGHTENMENT_DESKTOP), 0, 1, False, XA_CARDINAL,
+                                &type_ret, &i_unused, &l_unused, &l_unused,
+                                &data_ret) == Success &&
+             type_ret == XA_CARDINAL)) {
+            if (data_ret)
+                XFree(data_ret);
+
+            break;
+        } else if (X11->isSupportedByWM(ATOM(_NET_VIRTUAL_ROOTS)) && X11->net_virtual_root_list) {
+            int i = 0;
+            while (X11->net_virtual_root_list[i] != 0) {
+                if (X11->net_virtual_root_list[i++] == p)
+                    break;
+            }
+        }
+
+        l = w;
+        w = p;
+    }
+
+    // we have our window
+    int transx, transy;
+    XWindowAttributes wattr;
+    if (XTranslateCoordinates(X11->display, l, w,
+                              0, 0, &transx, &transy, &p) &&
+        XGetWindowAttributes(X11->display, w, &wattr)) {
+        top->frameStrut.setCoords(transx,
+                                  transy,
+                                  wattr.width - data.crect.width() - transx,
+                                  wattr.height - data.crect.height() - transy);
+
+        // add the border_width for the window managers frame... some window managers
+        // do not use a border_width of zero for their frames, and if we the left and
+        // top strut, we ensure that pos() is absolutely correct.  frameGeometry()
+        // will still be incorrect though... perhaps i should have foffset as well, to
+        // indicate the frame offset (equal to the border_width on X).
+        // - Brad
+        top->frameStrut.adjust(wattr.border_width,
+                               wattr.border_width,
+                               wattr.border_width,
+                               wattr.border_width);
+    }
+
+   data.fstrut_dirty = false;
+}
+
+void QWidgetPrivate::setWindowOpacity_sys(qreal opacity)
+{
+    Q_Q(QWidget);
+    ulong value = ulong(opacity * 0xffffffff);
+    XChangeProperty(QX11Info::display(), q->internalWinId(), ATOM(_NET_WM_WINDOW_OPACITY), XA_CARDINAL,
+                    32, PropModeReplace, (uchar*)&value, 1);
+}
+
+const QX11Info &QWidget::x11Info() const
+{
+    Q_D(const QWidget);
+    return d->xinfo;
+}
+
+void QWidgetPrivate::setWindowRole()
+{
+    Q_Q(QWidget);
+    if (!q->internalWinId())
+        return;
+    QByteArray windowRole = topData()->role.toUtf8();
+    XChangeProperty(X11->display, q->internalWinId(),
+                    ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                    (unsigned char *)windowRole.constData(), windowRole.length());
+}
+
+Q_GLOBAL_STATIC(QX11PaintEngine, qt_widget_paintengine)
+QPaintEngine *QWidget::paintEngine() const
+{
+    Q_D(const QWidget);
+    if (qt_widget_paintengine()->isActive()) {
+        if (d->extraPaintEngine)
+            return d->extraPaintEngine;
+        QWidget *self = const_cast<QWidget *>(this);
+        self->d_func()->extraPaintEngine = new QX11PaintEngine();
+        return d->extraPaintEngine;
+    }
+    return qt_widget_paintengine();
+}
+
+QWindowSurface *QWidgetPrivate::createDefaultWindowSurface_sys()
+{
+    return new QX11WindowSurface(q_func());
+}
+
+Qt::HANDLE QWidget::x11PictureHandle() const
+{
+#ifndef QT_NO_XRENDER
+    Q_D(const QWidget);
+    if (!internalWinId() && testAttribute(Qt::WA_WState_Created))
+        (void)winId(); // enforce native window
+    return d->picture;
+#else
+    return 0;
+#endif // QT_NO_XRENDER
+}
+
+#ifndef QT_NO_XRENDER
+XRenderColor QX11Data::preMultiply(const QColor &c)
+{
+    XRenderColor color;
+    const uint A = c.alpha(),
+               R = c.red(),
+               G = c.green(),
+               B = c.blue();
+    color.alpha = (A | A << 8);
+    color.red   = (R | R << 8) * color.alpha / 0x10000;
+    color.green = (G | G << 8) * color.alpha / 0x10000;
+    color.blue  = (B | B << 8) * color.alpha / 0x10000;
+    return color;
+}
+Picture QX11Data::getSolidFill(int screen, const QColor &c)
+{
+    if (!X11->use_xrender)
+        return XNone;
+
+    XRenderColor color = preMultiply(c);
+    for (int i = 0; i < X11->solid_fill_count; ++i) {
+        if (X11->solid_fills[i].screen == screen
+            && X11->solid_fills[i].color.alpha == color.alpha
+            && X11->solid_fills[i].color.red == color.red
+            && X11->solid_fills[i].color.green == color.green
+            && X11->solid_fills[i].color.blue == color.blue)
+            return X11->solid_fills[i].picture;
+    }
+    // none found, replace one
+    int i = qrand() % 16;
+
+    if (X11->solid_fills[i].screen != screen && X11->solid_fills[i].picture) {
+        XRenderFreePicture (X11->display, X11->solid_fills[i].picture);
+        X11->solid_fills[i].picture = 0;
+    }
+
+    if (!X11->solid_fills[i].picture) {
+        Pixmap pixmap = XCreatePixmap (X11->display, RootWindow (X11->display, screen), 1, 1, 32);
+        XRenderPictureAttributes attrs;
+        attrs.repeat = True;
+        X11->solid_fills[i].picture = XRenderCreatePicture (X11->display, pixmap,
+                                                            XRenderFindStandardFormat(X11->display, PictStandardARGB32),
+                                                            CPRepeat, &attrs);
+        XFreePixmap (X11->display, pixmap);
+    }
+
+    X11->solid_fills[i].color = color;
+    X11->solid_fills[i].screen = screen;
+    XRenderFillRectangle (X11->display, PictOpSrc, X11->solid_fills[i].picture, &color, 0, 0, 1, 1);
+    return X11->solid_fills[i].picture;
+}
+#endif
+
+void QWidgetPrivate::setModal_sys()
+{
+}
+
+void qt_x11_getX11InfoForWindow(QX11Info * xinfo, const QX11WindowAttributes &att)
+{
+    QX11InfoData* xd = xinfo->getX11Data(true);
+    const XWindowAttributes &a = *(att.att);
+    // find which screen the window is on...
+    xd->screen = QX11Info::appScreen(); // by default, use the default :)
+    int i;
+    for (i = 0; i < ScreenCount(X11->display); i++) {
+        if (RootWindow(X11->display, i) == a.root) {
+            xd->screen = i;
+            break;
+        }
+    }
+
+    xd->depth = a.depth;
+    xd->cells = DisplayCells(X11->display, xd->screen);
+    xd->visual = a.visual;
+    xd->defaultVisual = (XVisualIDFromVisual((Visual *) a.visual) ==
+                         XVisualIDFromVisual((Visual *) QX11Info::appVisual(xinfo->screen())));
+    xd->colormap = a.colormap;
+    xd->defaultColormap = (a.colormap == QX11Info::appColormap(xinfo->screen()));
+    xinfo->setX11Data(xd);
+}
+
+void QWidgetPrivate::updateX11AcceptFocus()
+{
+    Q_Q(QWidget);
+    if (!q->isWindow() || !q->internalWinId())
+        return;
+
+    XWMHints *h = XGetWMHints(X11->display, q->internalWinId());
+    XWMHints wm_hints;
+    if (!h) {
+        memset(&wm_hints, 0, sizeof(wm_hints)); // make valgrind happy
+        h = &wm_hints;
+    }
+    h->flags |= InputHint;
+    h->input = q->testAttribute(Qt::WA_X11DoNotAcceptFocus) ? False : True;
+
+    XSetWMHints(X11->display, q->internalWinId(), h);
+    if (h != &wm_hints)
+        XFree((char *)h);
+}
+
+QT_END_NAMESPACE
